<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenHY的个人博客</title>
  
  
  <link href="https://born2do.github.io/atom.xml" rel="self"/>
  
  <link href="https://born2do.github.io/"/>
  <updated>2021-05-02T23:25:19.975Z</updated>
  <id>https://born2do.github.io/</id>
  
  <author>
    <name>chenhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>牛客网数据库刷题笔记</title>
    <link href="https://born2do.github.io/2021/05/03/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://born2do.github.io/2021/05/03/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-02T23:24:42.000Z</published>
    <updated>2021-05-02T23:25:19.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一星题"><a href="#一星题" class="headerlink" title="一星题"></a>一星题</h2><ol><li><p><strong>日志文件</strong>用来记录对数据库中数据进行的每一次更新操作。</p></li><li><p>索引是在基本表的列上建立的一种数据库对象，它同基本表分开存储，使用它能够加快数据的（查询）速度。</p></li><li><p>where子句后不能放聚合函数。</p></li><li><p>用二维表来表示实体集及实体集之间联系的数据模型称为关系模型。</p></li><li><p>数据库系统与文件系统的主要区别是：文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决。</p></li><li><p>数据库管理系统DBMS是系统软件。</p></li><li><p>数据库系统一般由数据库、数据库管理系统（DBMS）、应用系统、数据库管理员和用户构成。DBMS是数据库系统的基础和核心。</p></li><li><p>MySQL忘记root密码，不管哪种解决方案，最终都要实现更新mysql数据库下的<strong>user</strong>表。</p></li><li><p>SQL 采用集合操作方式。</p></li><li><p>概念模型是用于信息世界的建模，与具体的 DBMS 无关。</p></li><li><p>数据库系统不仅包括数据库本身,还要包括相应的硬件、软件和各类相关人员。</p></li><li><p>在Access数据库的表设计器中可以修改字段类型、设置索引和增加字段。要想删除表中的记录，需要打开表进行删除。</p></li><li><p>SQL支持的备份类型有四种：</p><ul><li>完全数据库备份 </li><li>差异备份或称增量备份</li><li>事务日志备份</li><li>数据库文件和文件组备份</li></ul></li><li><ul><li>串行读(Serializable):完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞</li><li>未提交读(Read Uncommitted):允许脏读,也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed):只能读取到已经提交的数据</li><li>可重复读(Repeated Read):在同一个事务内的查询都是事务开始时刻一致的</li></ul></li><li><p>数据库分类：</p><ul><li>Mongodb数据库属于文档型非关系数据库</li><li>PostgreSQL属于关系型数据库</li><li>Redis属于KV键值数据库</li><li>Hbase属于列数据库</li></ul></li><li><p>在手机开发中常用的数据库是sqlLite。</p></li><li><p>关系模型中，一个关键字，可由一个或多个其值能惟一标识该关系模式中任何元组的属性组成。</p></li><li><p>在合并分E-R图时必须消除各分图中的不一致。各分E-R图之间的冲突主要有三类，即属性冲突、命名冲突和结构冲突，其中命名冲突是指同名异义或同义异名。</p></li><li><p>在数据系统中，对存取权限的定义称为授权。</p></li><li><p>索引的描述存放在数据字典中。</p></li><li><p>SQL语言具有两种使用方式，分别称为交互式SQL和嵌入式SQL。</p></li><li><p>数据库的物理结构设计的目的是：找到一个有效、可实现的数据库存储结构。</p></li><li><blockquote><p>（1）若视图的字段是来自字段表达式或常数，则不允许对此视图执行INSERT、UPDATE操作，允许执行DELETE操作；<br>（2）若视图的字段是来自库函数，则此视图不允许更新；<br>（3）若视图的定义中有GROUP BY子句或聚集函数时，则此视图不允许更新；<br>（4）若视图的定义中有DISTINCT任选项，则此视图不允许更新；<br>（5）若视图的定义中有嵌套查询，并且嵌套查询的FROM子句中涉及的表也是导出该视图的基表，则此视图不允许更新；<br>（6）若视图是由两个以上的基表导出的，此视图不允许更新；<br>（7）一个不允许更新的视图上定义的视图也不允许更新；<br>（8）由一个基表定义的视图，只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。</p></blockquote></li><li><p>相对于非关系模型，关系数据模型的缺点之一是：存取路径对用户透明，需查询优化。</p></li><li><p>一个关系数据库文件中的各条记录，前后顺序可以任意颠倒，不影响库中的数据关系。</p></li><li><p>不借助第三方工具，通过<code>explain plan</code>查看SQL的执行计划。</p></li><li><p>数据库的<strong>网状模型</strong>应满足的条件是：允许一个以上结点无双亲，也允许一个结点有多个双亲。</p></li><li><p>数据库并发操作带来的数据不一致性包括丢失修改、不可重复读、读“脏”数据。</p></li><li><blockquote><p>事务四大特性(简称ACID) </p><p>1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。<br>2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。<br>3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。<br>4、持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p></blockquote></li><li><p>左连接时，结果集的行数可能大于左表的行数。</p><p>解释：如果 left join on的条件在右表中有所重复，那么最终记录数目会大于原表数量。</p></li><li><p>创建表：CREATE TABLE</p><p>创建视图：CREATE VIEW</p><p>创建索引：CREATE INDEX </p><p>CREATE SCHEMA 是 CREATE DATABASE 的一个代名词。</p></li><li><p>子模式DDL用来描述，数据库的局部逻辑结构。</p></li><li><p>SQL语言是（非过程化）的语言。</p></li><li><blockquote><p>1.等值连接，在两个表中的广义笛卡尔积中选取属性值相等的元组</p><p>2.自然连接（特殊的等值连接），在等值连接的基础上去掉重复项</p><p>3.外连接分为左外连接右外连接</p><p>注：等值连接需要标出具体哪个元组相等</p></blockquote></li><li><p>对数据表进行修改时，删除列可以省略column，添加列必须说明数据类型。</p><p><code>alter table employee drop column age;</code></p><p><code>alter table employee drop age;</code></p></li><li><p>关系模型的三个组成部分，是指关系数据模型的<strong>数据结构、数据操作和完整性约束</strong>。</p></li><li><p>存储过程的好处：重复使用、SQL优化、更加安全。</p></li><li><p>并发控制指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。</p></li><li><blockquote><ol><li>DCL(数据控制语言)：grant revoke   </li><li>DML(数据操纵语言)：insert delete update select   </li><li>DDL(数据定义语言)：create drop alter   </li><li>TCL(事物控制语言)：commit rollback </li></ol></blockquote></li><li><p>物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。</p><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p><p>在数据库系统中，外模式/模式映象保证数据的逻辑独立性，模式/内模式映象保证数据的物理独立性。</p></li><li><p>对于串行调度，各个事务的操作没有交叉，也就没有相互干扰，当然也不会产生并发所引起的。事务对数据库的作用是将数据库从一个一致的状态转变为另一个一致的状态。多个事务串行执行后，数据库仍旧保持一致的状态。 可串行性(Serializability)  是并发事务正确调度的准则。在RDBMS中，作为并发控制的正确性准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p></li><li><p>聚合函数MAX(＜列名＞)用于求某一列值的最大值，它对列名不限制数据类型。</p></li><li><p>数据库保护又叫做数据库控制，是通过四方面实现的，即安全性控制、完整性控制、并发性和数据恢复。</p></li><li><blockquote><p>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。</p><p>第二范式（2NF）：首先是1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><p>第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p></blockquote></li><li><blockquote><p>（1）实体类型的转换<br>将每个实体类型转换成一个关系模式，实体的属性即为关系的属性，实体标识符即为关系的键。<br>（2）联系类型的转换<br>1）实体间的联系是1:1，<br>可以在两个实体类型转换成两个关系模式中的任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。<br>2）实体间的联系是1:N，<br>则在N端实体类型转换成的关系模式中加入1端实体类型转换成的关系模式的键和联系类型的属性。<br>3）实体间的联系是M:N，<br>则将联系类型也转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合。</p></blockquote><p>注意：一对一关系，一对多关系不需要新表。</p></li></ol><h2 id="两星题"><a href="#两星题" class="headerlink" title="两星题"></a>两星题</h2><ol><li><p>为了反映事物本身及事物之间的联系，数据库中的数据必须有一定的结构，这种结构用数据模型来表示，一个具体的数据模型应当正确地反映出数据之间存在的整体逻辑关系，所以数据模型质量的高低直接影响数据库性能的好坏。</p></li><li><p>共享锁：是非独占的，允许其他事物同时读取其锁定的资源（也可再加共享锁），但不允许修改。</p><p>独占锁（即排他锁）：只能自己使用，不允许其他事物读取和修改。</p></li><li><p>如果想使用NULL，则需要使用IS NULL或者IS NOT NULL。如果将NULL与比较运算符，则结果都是NULL。</p></li><li><p>在使用limit子句时，如果没有足够的行，MySQL将只返回它能返回的那么多行。</p></li><li><p>数据库的基本特点是：</p><p>（1）数据可以共享（或数据结构化） （2）数据独立性<br>（3）数据冗余小，易扩充 （4）统一管理和控制</p></li><li><p>数据库是按照一定的数据模型组织的，长期存储在计算机内，可为多个用户共享的数据的聚集。</p></li><li><p>选择是将表进行水平分割的运算，其目的是为了保留某些符合条件的元组。投影是对表进行垂直分割的运算，其目的是实现属性的筛选。</p></li><li><p>关系的描述称为关系模式。对关系的描述，一般表示为：关系名（属性1，属性2…..属性n）。例如：课程(课程号、课程名称、学分、任课老师)</p></li><li><p>限制输入到列的值的范围，应使用CHECK约束。</p></li><li><p>外键中的属性允许为null，只要没有被声明为not null。</p></li><li><p>在数据库的安全控制中，为了保证用户只能存取他有权存取的数据，在授权的定义中数据对象的（范围越小），授权子系统就越灵活 。</p></li><li><p>在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应（加前缀:）。</p></li><li><p>“元组”所表达的概念与二维表的”行”的概念最接近。</p></li><li><p>数据库系统包括数据库和数据库管理系统 [数据库系统&gt;数据库管理系统&gt;数据库]。</p></li><li><blockquote><p>实体完整性指表中行的完整性 </p><p>域完整性指列的值域的完整性，如数据类型、格式、值域范围、是否允许空值等等 </p><p>参照完整性基于外键与被引用主键之间的关系，确保键值在所有表中的一致性 </p></blockquote></li><li><p>数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</p></li><li><table><thead><tr><th>关系术语</th><th>一般表格的术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表格的描述）</td></tr><tr><td>关系</td><td>一张二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>属性名</td><td>列名</td></tr><tr><td>属性值</td><td>列值</td></tr><tr><td>分量</td><td>一条记录中的一个列值</td></tr><tr><td>非规范关系</td><td>大表中嵌着小表</td></tr></tbody></table></li><li><blockquote><p>外模式又称子模式，对应于用户级。外模式反映了数据库的用户观。<br>内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述,它是数据库的存储观<br>模式又称概念模式或逻辑模式，对应于概念级.反映了数据库系统的整体观</p></blockquote></li><li><ul><li>SQL语句关键字顺序为：select, from, where, group by, having, order by, limit</li><li>where增加分组前的限定，having增加分组后的限定</li><li>group by 通常和集合函数SUM()，AVG()，MAX()，MIN()，COUNT()等结合在一起，后接限制条件语句 having,不可用where语句！</li></ul></li><li><blockquote><p>数据库常用的关系运算有三种 </p><p>1、选择  从二维表中选出符合条件的记录，它是从行的角度对关系进行运算 </p><p>2、投影，从二维表中选出所需要的列，它是从列的角度对关系进行运算：从关系中挑选出指定的属性组成新关系的运算 </p><p>3、连接，同时涉及到两个二维表的运算，它是将两个关系在给定的属性上满足一定条件的记录连接起来 从而得到一个新的关系</p></blockquote></li><li><ul><li>聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。</li><li>非聚集索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。</li><li>一个表只能有一个聚集索引和多个非聚集索引。</li></ul></li><li><p>按所使用的数据模型来分，数据库可分为三种模型：层次、关系和网状。</p></li><li><p>在数据库中存储的是数据以及数据之间的联系。</p></li><li><p>数据库系统的数据独立性体现在不会因为数据存储结构与数据逻辑结构的变化而影响应用程序。</p></li><li><ul><li>丢失更新：当两个或多个事物读入同一数据并修改，会发生丢失更新问题，即后一个事物更新的结果被前一事务所做更新覆盖 即当事务A和B同事进行时，事务A对数据已经改变但并未提交时B又对同一数据进行了修改（注意此时数据是A还未提交改变的数据），到时A做的数据改动丢失了</li><li>读‘脏数据’：指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</li><li>不可重复读：这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</li><li>幻读：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</li></ul></li><li><blockquote><p>按照规范的设计方法，一个完整的 数据库设计 一般分为以下六个阶段：<br>⑴需求分析：分析用户的需求，包括数据、功能和性能需求；<br>⑵概念结构设计：主要采用E-R模型进行设计，包括画E-R图；<br>⑶逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；进行关系规范化。<br>⑷数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸数据库的实施：包括编程、测试和试运行；<br>⑹数据库运行与维护：系统的运行与数据库的日常维护。</p></blockquote></li><li><p>数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件、数据库后备副本。</p></li><li><p>数据库中，<code>optimize table TabName;</code>命令可以整理表数据文件的碎片。</p></li><li><p>对数据库中表的字段进行相关操作时，添加时column可以省略，删除时column不能省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tableName DROP COLUMN columnName;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tableName ADD columnName;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三星题"><a href="#三星题" class="headerlink" title="三星题"></a>三星题</h2><ol><li><blockquote><p>1）候选键： 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了。（即该属性组内不应该存在一个真子集也能标识一个元组）。这样的属性组称作候选码。</p><p>2）主键：当有多个候选码时，可以选定一个作为主码，选定的候选码称主键</p><p>3）外键：关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</p></blockquote><p>候选码可以唯一标识一个实体，可以有一个或者多个。 </p><p>主码唯一且非空，也是唯一标识一个实体的码。</p><p>如果候选码有多个，可以从中选定一个主码。</p></li><li><ul><li>模式：只能有一个</li><li>内模式：只能有一个</li><li>外模式：任意多个</li></ul></li><li><p>索引类型分类：</p><p>普通索引：没有任何限制</p><p>唯一索引：不允许建立索引的列有重复的值，但可以有空值</p><p>主索引：特殊的唯一索引，不允许有空值</p><p>候选索引：也要求唯一性，一个表中可以有多个候选索引</p></li><li><p>视图设计的几种方法：   </p><ul><li>自顶向下。先全局框架，然后逐步细化</li><li>自底向上。先局部概念结构，再集成为全局结构</li><li>由里向外。先核心结构，再向外扩张</li><li>混合策略。1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构 </li></ul></li><li><p>对于各种范式之间的关系如下： 5NF⊂ 4NF⊂ BCNF ⊂3NF ⊂ 2NF⊂ 1NF </p></li><li><ul><li>等值连接是从关系R和S的广义笛卡尔积中选取A和B“属性值”相等的元组，所以只要两个关系里面的有元组属性值相等就可以进行</li><li>自然连接是要求R和S中有一个或者多个相同的属性组</li></ul></li><li><blockquote><p>3NF——只消除非主属性对主属性的传递依赖<br>BCNF——消除所有属性对主属性的传递依赖</p></blockquote></li><li><p>为了提高数据库的性能，需要针对系统设计基准测试进行压力测试，那么进行压力测试时需要考虑以下指标：</p><ul><li>响应时间</li><li>并发性</li><li>吞吐量</li></ul></li><li><p>关系运算中花费时间可能最长的运算是笛卡尔积。</p></li><li><p>数据库对象的四种视图模式：详细模式，小图标，大图标，列表。</p></li><li><p>WITH CHECK OPTION 用于限制视图，通过视图进行修改时，必须要能通过该视图看到修改后的结果，即对其的修改要再次满足查询中的条件。</p></li><li><p>若数据库中只包含成功事务提交的结果，则此数据库就称为处于(一致)状态。</p></li><li><p>ACCESS的字段属性，定义字段默认值的含义是该字段值不允许为空。</p></li><li><p>SQL结构化查询语言，是一种数据库查询和<strong>程序设计语言</strong>，用于存取数据以及查询、更新和管理关系数据库系统。</p></li><li><p>规范化过程主要为克服数据库逻辑结构中的插入异常、删除异常以及（冗余度大）的缺陷。</p></li><li><p>关于oracle系统进程和作用的描述：</p><ul><li>数据写进程(dbwr)：负责将更改的数据从数据库缓冲区高速缓存写入数据文件</li><li>监控进程(pmon) ：负责在一个 Oracle 进程失败时清理资源</li><li>归档进程(arcn) ：在每次日志切换时把已满的日志组进行备份或归档</li><li>系统监控(smon) ：检查数据库的一致性，如有必要还会在数据库打开时启动数据库的恢复</li></ul></li><li><p>概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体-联系模型。</p></li><li><p>数据库技术的根本目标是要解决数据共享的问题。</p></li><li><p>ORDB（对象关系数据库）中，同类元素的无序集合，并且允许一个成员可多次出现，称为多集类型。</p><blockquote><p>复合类型有下列五种: </p><p>1.结构类型:  不同类型元素的有序集合。 </p><p>2.集合类型:  相同类型元素的无序集合，并且所有的元素必须是不同的。 </p><p>3.数组类型:  同类元素的有序集合。 </p><p>4.多集类型:  同类元素的无序集合并且允许有重复的元素。 </p><p>(5.列表类型:  类型相同并且允许有重复的元素的有序集合。)</p></blockquote></li><li><p>数据库管理系统的主要功能是定义数据库。</p></li><li><p>在使用left jion时，on和where条件的区别如下： </p><ul><li>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</li><li>where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li></ul></li></ol><h2 id="四星题"><a href="#四星题" class="headerlink" title="四星题"></a>四星题</h2><ol><li><p>约束主要有一下几种:</p><ul><li>NOT NULL : 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE : 控制字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控制字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: FOREIGN KEY 约束用于预防破坏表之间连接的动作，FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li><li>DEFAULT: 用于设置新记录的默认值。</li></ul></li><li><p>共享锁（S锁）：读锁，可查看但无法修改和删除，已加该锁则其他事务只能加S锁；<br>排他锁（X锁）：写锁、独占锁，可写可读，已加该锁则其他事务不能再加任何类型的锁。</p></li><li><p>RDBMS 是SQL的基础，同样也是所有现代数据库系统的基础，比如MS   SQL Server, IBM DB2, Oracle, MySQL以及Microsoft Access。</p><p>hadoop是分布式数据库。</p></li><li><blockquote><p>Access的数据库对象：<br>1、表，主要用于存储数据。<br>2、查询，主要用于提取数据。<br>3、窗体，用户与程序的交互。<br>4、报表，主要用于展示数据。<br>5、页，主要用于数据共享。<br>6、宏，用于自动化完成。</p></blockquote></li><li><p>候选码中属性称为主属性。</p></li><li><p>数据流程图（DFD）是用于描述结构化方法中（需求分析）阶段的工具。</p></li><li><p>sql注入中使用延时注入时常用的语句：</p><table><thead><tr><th>数据库</th><th>延时注入语句</th></tr></thead><tbody><tr><td>MySQL</td><td>1. benchmark(100000000,md5(1))   2. sleep(5)</td></tr><tr><td>Postgresql</td><td>1. pg_sleep(5)   2. generate_series(1,10000)</td></tr><tr><td>Microsoft Sql Server</td><td>waitfor delay ‘0:0:5’</td></tr></tbody></table></li><li><p>事务是 DBMS 的基本单位，它是用户定义的一组逻辑一致的程序序列。 </p></li><li><ul><li>左联结，返回左表中所有记录及右表中联结字段相同的记录。</li><li>同理，右联结，返回右表中所有纪录及左表中联结字段相同的记录。</li><li>内部联结，只返回两个表联结字段相同的记录。</li></ul><blockquote><p>A INNER JOIN B：返回A和B中符合on条件式的记录</p><p>A LEFT JOIN B:返回A中的所有记录和B中符合on条件式的记录</p><p>A RIGHT JOIN B：返回B中的所有记录和A中符合on条件式的记录</p></blockquote></li><li><p>关系规范化中的4个问题：</p><ul><li>数据冗余，浪费很大的存储空间。</li><li>更新异常，由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。</li><li>插入异常，应该插入的数据未被插入</li><li>删除异常，不该删除数据的被删除</li></ul></li><li><p>HAVING子句中应后跟（组条件表达式）。</p></li><li><p>在进行数据库逻辑设计时，可将E-R图中的属性表示为关系模式的属性，实体表示为元组，实体集表示为关系，联系表示为关系。</p><table><thead><tr><th>E-R图</th><th>关系模式</th></tr></thead><tbody><tr><td>属性</td><td>属性</td></tr><tr><td>实体</td><td>元组</td></tr><tr><td>实体集</td><td>关系</td></tr><tr><td>联系</td><td>关系</td></tr></tbody></table></li><li><p>关系型数据库：<br>Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL<br>非关系型数据库：<br>NoSql、Cloudant、MongoDb、redis、HBase</p></li></ol><h1 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h1><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><pre><code>原文档丢失了，恢复回来的就只有这些了。当文档内容被自己亲手覆盖，真的是心痛到无法呼吸，差点就自闭了。想剁了自己的右手，是他点击了“确定”，蓝瘦、香菇。一周的心血毁于一旦，也让我也体会到了，在工作中，一定要细心，有些操作是无法挽回的，造成的后果是可怕的。在细心工作中逐步提高效率，细心、安全是前提。</code></pre>]]></content>
    
    
    <summary type="html">牛客网数据库刷题笔记</summary>
    
    
    
    <category term="刷题" scheme="https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Eclipse、spring插件及反编译插件安装</title>
    <link href="https://born2do.github.io/2021/05/03/Eclipse%E3%80%81spring%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://born2do.github.io/2021/05/03/Eclipse%E3%80%81spring%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2021-05-02T23:18:41.000Z</published>
    <updated>2021-05-02T23:19:13.680Z</updated>
    
    <content type="html"><![CDATA[<p>请提前下载好必要文件，该文主要介绍离线安装。</p><h2 id="Eclipse安装"><a href="#Eclipse安装" class="headerlink" title="Eclipse安装"></a>Eclipse安装</h2><p>根据自己的操作系统以及想要的eclipse版本，在eclipse官网下载<strong>软件压缩包</strong>。</p><p>下载地址：<a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></p><p>下载完成后，解压到本地磁盘即可直接使用。</p><p><img src="https://i.loli.net/2021/05/03/IvtrMd6i7m9aCUX.png" alt="image-20201104234110429.png"></p><h2 id="反编译插件安装"><a href="#反编译插件安装" class="headerlink" title="反编译插件安装"></a>反编译插件安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>地址：<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a></p><p><img src="https://i.loli.net/2021/05/03/r9BcFoMmjVaSlOY.png" alt="image-20201104234747246.png"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p> 将下载好的压缩包解压缩。</p></li><li><p> 打开eclipse，Help-&gt;Install New Software…-&gt;add。</p></li></ol><p><img src="https://i.loli.net/2021/05/03/3VDnKICAtONk8gF.png" alt="image-20201105000155228.png"></p><ol start="3"><li> 选中插件，点击“next”。</li></ol><p><img src="https://i.loli.net/2021/05/03/nEpACzIhPtTWc8D.png" alt="image-20201105000552816.png"></p><ol start="4"><li><p> 一直点击下一步即可。最终安装完成后会提醒重启eclipse，重启就好。</p></li><li><p> 重启后，再次确认jd插件安装成功。Window-&gt;Preference-&gt;Java-&gt;Decompiler，出现JD-eclipse说明安装成功。</p></li></ol><p><img src="https://i.loli.net/2021/05/03/D3beYJFyrBMRHiC.png" alt="image-20201105001352871.png"></p><ol start="6"><li> 最后，进行查看器默认设置修改。直接在左上角搜索“File Associations”，选中“.class without resource”，点击下方的add，找到“JD Class File Viewer”，确认即可。</li></ol><p><img src="https://i.loli.net/2021/05/03/xshNMVK1DqpAlnU.png" alt="image-20201105002039009.png"></p><p><img src="https://i.loli.net/2021/05/03/hbkgIVRQoWfsA7S.png" alt="image-20201105002115734.png"></p><p><img src="https://i.loli.net/2021/05/03/3pDare5SVy62Gqn.png" alt="image-20201105002234975.png"></p><ol start="7"><li> 至此，反编译插件安装完成。</li></ol><h2 id="Spring插件安装"><a href="#Spring插件安装" class="headerlink" title="Spring插件安装"></a>Spring插件安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><ol><li> 查看eclipse版本。Help-&gt;About Eclipse IDE，我的版本是4.14.0。</li></ol><p><img src="https://i.loli.net/2021/05/03/xrbAliEIgGq48uF.png" alt="image-20201106185356251.png"></p><ol start="2"><li> <a href="https://github.com/spring-projects/toolsuite-distribution/wiki/Spring-Tool-Suite-3">https://github.com/spring-projects/toolsuite-distribution/wiki/Spring-Tool-Suite-3</a>，找到版本对应的Spring Tool Suite 3，并下载。</li></ol><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>步骤与反编译插件的安装步骤一致，但是要注意，需要联网，安装时会从网络上再次更新下载部分组件，没有联网的，即使安装完了，也是不完整的，无法使用。</p>]]></content>
    
    
    <summary type="html">Eclipse、spring插件及反编译插件安装</summary>
    
    
    
    <category term="软件安装" scheme="https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Intellij配置</title>
    <link href="https://born2do.github.io/2021/05/03/Intellij%E9%85%8D%E7%BD%AE/"/>
    <id>https://born2do.github.io/2021/05/03/Intellij%E9%85%8D%E7%BD%AE/</id>
    <published>2021-05-02T23:17:46.000Z</published>
    <updated>2021-05-02T23:18:08.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intellij配置"><a href="#Intellij配置" class="headerlink" title="Intellij配置"></a>Intellij配置</h2><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>File | Settings | Appearance &amp; Behavior | Appearance</p><p><img src="https://i.loli.net/2021/05/03/LD7BZTWelOYjAhv.png" alt="Intellij配置-主题设置.png"></p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>File | Settings | Editor | Font</p><p><img src="https://i.loli.net/2021/05/03/9ECUankNJyuLxq4.png" alt="Intellij配置-字体设置.png"></p><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>File | Settings | Keymap</p><h3 id="大小写敏感设置"><a href="#大小写敏感设置" class="headerlink" title="大小写敏感设置"></a>大小写敏感设置</h3><p>File | Settings | Editor | General | Code Completion</p><p>关闭大小写敏感。</p><h3 id="MAVEN设置"><a href="#MAVEN设置" class="headerlink" title="MAVEN设置"></a>MAVEN设置</h3><h3 id="文件编码格式设置"><a href="#文件编码格式设置" class="headerlink" title="文件编码格式设置"></a>文件编码格式设置</h3><p>File | Settings | Editor | File Encodings</p>]]></content>
    
    
    <summary type="html">Intellij配置</summary>
    
    
    
    <category term="软件安装" scheme="https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
  </entry>
  
  <entry>
    <title>【MySQL】The MySQL server is running with the --skip-grant-tables option so it cannot execute this ...</title>
    <link href="https://born2do.github.io/2021/05/02/%E3%80%90MySQL%E3%80%91The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/"/>
    <id>https://born2do.github.io/2021/05/02/%E3%80%90MySQL%E3%80%91The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/</id>
    <published>2021-05-02T00:04:45.000Z</published>
    <updated>2021-05-02T00:05:20.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>新建数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user test identified by &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>然后便报错：</p><p>“ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement”</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>刷新权限表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>再重新新建用户即可。</p>]]></content>
    
    
    <summary type="html">【MySQL】The MySQL server is running with the --skip-grant-tables option so it cannot execute this ...</summary>
    
    
    
    <category term="MySQL" scheme="https://born2do.github.io/categories/MySQL/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java中子类可以继承父类所有的属性和方法</title>
    <link href="https://born2do.github.io/2021/05/02/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://born2do.github.io/2021/05/02/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-02T00:03:51.000Z</published>
    <updated>2021-05-02T00:04:12.722Z</updated>
    
    <content type="html"><![CDATA[<p>某些书本表明“子类只能继承父类的非私有属性和方法”，然而事实并非如此，实际上“Java中子类可以继承父类所有的属性和方法”，只不过因为私有的原因，子类不能调用父类的私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span>+sex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;is speaking!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJava</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Child c = <span class="keyword">new</span> Child();</span><br><span class="line">c.tell();<span class="comment">// tell方法是可以用的</span></span><br><span class="line"><span class="comment">// c.speak();//报错，父类的私有方法不可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到测试类中即使没有给Child类对象的属性进行赋值，tell方法依旧是可用的。如果Child类中没有继承父类的私有属性，那么tell方法应该会报错。由此得出的结论是，子类会继承父类的所有东西，而修饰符只是影响属性或者方法对外是否可见。</p><p>Java官方文档的解释：子类不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的。</p>]]></content>
    
    
    <summary type="html">【Java】Java中子类可以继承父类所有的属性和方法</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://born2do.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】String、StringBuffer、StringBuilder有什么区别</title>
    <link href="https://born2do.github.io/2021/05/01/%E3%80%90Java%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/05/01/%E3%80%90Java%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-30T23:09:06.000Z</published>
    <updated>2021-04-30T23:10:26.429Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>在Java中，String类用于用于创建和操作字符串。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，在这里不作赘述。但值得注意的是，<strong>String 类是不可改变的</strong>，所以你一旦创建了 String 对象，那它的值就无法改变了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Google&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;Baidu&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure><p>上段代码的运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Google</span><br><span class="line">s = Baidu</span><br></pre></td></tr></table></figure><p>看似String类是可以改变的，那为什么又说String类是不可改变的呢？</p><p>答：在这里的变量s，并非String对象，而是指向对象地址的引用。变量s存储在栈空间，而真正的对象存储在堆空间。</p><p><img src="https://i.loli.net/2021/05/01/GWVxvjSqowcfyMg.png" alt="String、StringBuffer、StringBuilder有什么区别.png"></p><p>在执行上图中的两句代码时，堆空间实际上创建了两个对象，变量s改变的是内存中对象的地址，第一个对象的内容并未发生改变，最后也会被垃圾回收机制回收内存。所以说，String 类是不可改变的，你一旦创建了 String 对象，那它的值就无法改变了。对了，String 是被 final 修饰的，他的长度是不可变的。</p><h4 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h4><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h4 id="三者在执行速度方面的比较："><a href="#三者在执行速度方面的比较：" class="headerlink" title="三者在执行速度方面的比较："></a>三者在执行速度方面的比较：</h4><p>StringBuilder &gt; StringBuffer &gt; String</p><h4 id="如何正确地、适当地使用这三个类："><a href="#如何正确地、适当地使用这三个类：" class="headerlink" title="如何正确地、适当地使用这三个类："></a>如何正确地、适当地使用这三个类：</h4><ul><li><p>  如果要求字符串<strong>不可变</strong>，操作少量数据，那么应该选择String类</p></li><li><p>  如果需要字符串<strong>可变</strong>并且是<strong>线程安全</strong>的，操作大量数据，那么应选择StringBuffer类</p></li><li><p>  如果要求字符串<strong>可变</strong>并且<strong>不存在线程安全问题</strong>，操作大量数据，那么应选择StringBuilder类</p></li></ul>]]></content>
    
    
    <summary type="html">【Java】String、StringBuffer、StringBuilder有什么区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="String" scheme="https://born2do.github.io/tags/String/"/>
    
    <category term="StringBuffer" scheme="https://born2do.github.io/tags/StringBuffer/"/>
    
    <category term="StringBuilder" scheme="https://born2do.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>解决CHM文件打不开或者打开以后显示空白</title>
    <link href="https://born2do.github.io/2021/05/01/%E8%A7%A3%E5%86%B3CHM%E6%96%87%E4%BB%B6%E6%89%93%E4%B8%8D%E5%BC%80%E6%88%96%E8%80%85%E6%89%93%E5%BC%80%E4%BB%A5%E5%90%8E%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/"/>
    <id>https://born2do.github.io/2021/05/01/%E8%A7%A3%E5%86%B3CHM%E6%96%87%E4%BB%B6%E6%89%93%E4%B8%8D%E5%BC%80%E6%88%96%E8%80%85%E6%89%93%E5%BC%80%E4%BB%A5%E5%90%8E%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/</id>
    <published>2021-04-30T23:04:57.000Z</published>
    <updated>2021-04-30T23:05:13.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CHM是英语“Compiled Help Manual”的简写，即“已编译的帮助文件”。CHM是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。</p></blockquote><p>从网络上下载了chm格式的帮助文档，但是无法打开。经过一番搜索，完美解决。解决方式如下：</p><p>文件之所以打不开或者打开后显示空白，是因为该文件被加锁了，解锁即可。</p><p>右键chm文件-&gt;属性-&gt;勾选“解除锁定”-&gt;应用即可。</p>]]></content>
    
    
    <summary type="html">解决CHM文件打不开或者打开以后显示空白</summary>
    
    
    
    <category term="error" scheme="https://born2do.github.io/categories/error/"/>
    
    
  </entry>
  
  <entry>
    <title>【Windows】Windows环境生成树形目录结构</title>
    <link href="https://born2do.github.io/2021/04/30/%E3%80%90Windows%E3%80%91Windows%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>https://born2do.github.io/2021/04/30/%E3%80%90Windows%E3%80%91Windows%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2021-04-30T10:03:37.000Z</published>
    <updated>2021-04-30T10:04:35.671Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line"><span class="built_in">TREE</span> [drive:][<span class="built_in">path</span>] [/F] [/A]</span><br><span class="line"></span><br><span class="line">   /F   显示每个文件夹中文件的名称。</span><br><span class="line">   /A   使用 ASCII 字符，而不使用扩展字符。</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> D:\backup\软件 /F &gt; <span class="built_in">tree</span>.txt</span><br></pre></td></tr></table></figure><p>执行tree命令，并将结果重定向到 tree.txt 。</p><p><img src="https://i.loli.net/2021/04/30/sQPW8chavRdo6wG.png" alt="Windows环境生成树形目录结构-tree.png"></p>]]></content>
    
    
    <summary type="html">【Windows】Windows环境生成树形目录结构</summary>
    
    
    
    <category term="Windows" scheme="https://born2do.github.io/categories/Windows/"/>
    
    
    <category term="树形目录结构" scheme="https://born2do.github.io/tags/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>解决从github下载项目速度过慢或下载失败</title>
    <link href="https://born2do.github.io/2021/04/30/%E8%A7%A3%E5%86%B3%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
    <id>https://born2do.github.io/2021/04/30/%E8%A7%A3%E5%86%B3%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/</id>
    <published>2021-04-30T10:02:31.000Z</published>
    <updated>2021-04-30T10:03:10.628Z</updated>
    
    <content type="html"><![CDATA[<p>有时候从github上下载个项目或是文件，几兆大小却花费十几分钟，速度低到极致。遇上个稍微大点的项目，运气好的下载半天好歹给你下载下来了，运气差点的下载到一半甚至90%就给你中止了，提示你网络已断开，你说气人不。</p><p>说到底还是因为那堵墙，不做过多评论。</p><p>直接来干货：将存储于github上的项目克隆到gitee上即可。</p><p>Gitee （中文名：码云 ，原名 Git@OSC ）是开源中国推出的基于 Git 的代码托管服务。因为服务器在国内，速度可不是github能比拟的。</p><p>1.打开码云（<a href="https://gitee.com/">https://gitee.com/</a>），注册并登录。</p><p>2.创建仓库。</p><p><img src="https://i.loli.net/2021/04/30/mRePXTF1uhx5t7i.png" alt="create.png"></p><p>3.在新建仓库页选择 “导入已有仓库”。</p><p><img src="https://i.loli.net/2021/04/30/95ofMkTAxSKu1YJ.png" alt="import.png"></p><p>4.复制需要下载的github项目的链接，如<a href="https://github.com/lehaifeng/T-GCN.git">https://github.com/lehaifeng/T-GCN.git</a>放到导入已有仓库中。</p><p><img src="https://i.loli.net/2021/04/30/yGnUFbV4MpZmulh.png" alt="importFromGitHub.png"></p><p>5.点击创建，然后下载即可。</p><p><img src="https://i.loli.net/2021/04/30/8EctPuBlemkMfbG.png" alt="download.png"></p><p>说明：有些项目在gitee上已经有过的，克隆会比较快，但如果是新项目，会稍稍耗时，但总比我们自己下载要来得快，耐心等待即可。</p><p>图片来自：<a href="https://www.cnblogs.com/USTC-ZCC/p/11163292.html">https://www.cnblogs.com/USTC-ZCC/p/11163292.html</a></p>]]></content>
    
    
    <summary type="html">解决从github下载项目速度过慢或下载失败</summary>
    
    
    
    <category term="下载" scheme="https://born2do.github.io/categories/%E4%B8%8B%E8%BD%BD/"/>
    
    
    <category term="github" scheme="https://born2do.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>localhost、127.0.0.1和本机IP之间的区别</title>
    <link href="https://born2do.github.io/2021/04/29/localhost%E3%80%81127-0-0-1%E5%92%8C%E6%9C%AC%E6%9C%BAIP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/29/localhost%E3%80%81127-0-0-1%E5%92%8C%E6%9C%AC%E6%9C%BAIP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-29T12:44:10.000Z</published>
    <updated>2021-04-29T12:44:36.022Z</updated>
    
    <content type="html"><![CDATA[<p>1、localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 IPv6 后，它同时还指向 IPv6 的地址 [::1] 。</p><p>2、127.0.0.1 是一个IP地址，这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。</p><p>3、本机IP，确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPv4，IPX/Apple Tak消失了，IPv6还没普及，所以通常仅指IP地址甚至IPv4地址。</p><p>4、一般情况下，localhost指向127.0.0.1，无需联网，供本机访问；而本机IP需要联网，供本机或外部访问。</p>]]></content>
    
    
    <summary type="html">localhost、127.0.0.1和本机IP之间的区别</summary>
    
    
    
    <category term="IP" scheme="https://born2do.github.io/categories/IP/"/>
    
    
  </entry>
  
  <entry>
    <title>【Linux】Linux、Unix环境下的环境变量设置</title>
    <link href="https://born2do.github.io/2021/04/29/%E3%80%90Linux%E3%80%91Linux%E3%80%81Unix%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/"/>
    <id>https://born2do.github.io/2021/04/29/%E3%80%90Linux%E3%80%91Linux%E3%80%81Unix%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/</id>
    <published>2021-04-29T12:42:38.000Z</published>
    <updated>2021-04-29T12:43:03.289Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例1. </span><br><span class="line">export JAVA_HOME=&quot;/var/java/lib&quot;</span><br><span class="line"></span><br><span class="line">例2. </span><br><span class="line">export PATH=$&#123;PATH&#125;:/var/java/lib</span><br></pre></td></tr></table></figure><p>说明：</p><p>1、如果是系统已有变量（如PATH），那么采用例2的连接方法。在原有路径后添加新路径，如果不连接原来的${PATH}，那么原有的PATH将被覆盖，后果很严重。</p><p>2、如果是新设置的变量，则按例1设置。</p><p>3、变量名和变量值之间的等号两侧不能有空格，否则报错!</p><p>4、等号右侧的变量值可以加双引号(例1)也可以不加(例2)。</p><p>5、特殊字符简介。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export a=/a/img:aa/img</span><br><span class="line">export B=.:/xiaomi/xiaoai</span><br><span class="line">export A=/ca/car:$A</span><br></pre></td></tr></table></figure><p><code>:</code>    表示并列含义，例如变量值有多个，用:符号进行分隔。</p><p><code>.</code>    表示你操作的当前目录。</p><p><code>$</code>    表示引用已定义好的变量的值。</p><p>6、set命令，显示所有本地定义的shell变量。</p><p>7、常见的环境变量</p><p>PATH:决定了shell将到哪些目录中寻找命令或程序</p><p>HOME:当前用户主目录</p><p>HISTSIZE:是指保存历史命令记录的条数</p><p>LOGNAME:是指当前用户的登录名</p>]]></content>
    
    
    <summary type="html">【Linux】Linux、Unix环境下的环境变量设置</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="环境变量" scheme="https://born2do.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Linux上的tar包拿到Windows下解压缩后新增了PaxHeaders文件夹以及其他文件</title>
    <link href="https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91Linux%E4%B8%8A%E7%9A%84tar%E5%8C%85%E6%8B%BF%E5%88%B0Windows%E4%B8%8B%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%90%8E%E6%96%B0%E5%A2%9E%E4%BA%86PaxHeaders%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6/"/>
    <id>https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91Linux%E4%B8%8A%E7%9A%84tar%E5%8C%85%E6%8B%BF%E5%88%B0Windows%E4%B8%8B%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%90%8E%E6%96%B0%E5%A2%9E%E4%BA%86PaxHeaders%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6/</id>
    <published>2021-04-28T14:23:06.000Z</published>
    <updated>2021-04-28T14:29:27.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>公司项目架构升级，服务器由AIX迁移到了Linux。由硬件差异导致了一系列问题。其中之一就是，本地生成tar包送达目标系统后，无法在目标系统前台查看全部文件，部分文件下载后显示文件损坏。</p></blockquote><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>1.我们项目近期并未改动代码，排除项目源代码问题。<br>2.目标系统近期并未对我方系统送达的文件进行加载策略的更改，排除目标系统的问题。<br>3.既然出发地与目的地均无问题，那就只能是文件的问题或是传输过程中出现问题。</p><blockquote><p>为保证万无一失，我们在新老系统切换时，进行了一个并行运行的操作，一旦出问题，切换到老系统。而这也为我们查找问题提供了依据。</p></blockquote><p>4.原AIX生成的文件大小与新Linux生成的文件大小存在差异。但是在服务器上解压缩后，文件却又是一样的，真的头大了。<br>5.将目标系统的文件拿到Windows服务器下使用7z进行解压缩后发现，莫名多出了几个文件、文件夹。而这个多出的文件夹下的文件的名称与外层的文件名称完全相同，那就有可能是文件加载的问题了。将PaxHeaders下的文件使用notepad++打开后发现是atime、mtime、ctime，相当于文件的元信息。<br>| 简名  | 全名        | 中文名   | 含义                                     |<br>| —– | ———– | ——– | —————————————- |<br>| atime | access time | 访问时间 | 文件中的数据库最后被访问的时间           |<br>| mtime | modify time | 修改时间 | 文件内容被修改的最后时间                 |<br>| ctime | change time | 变化时间 | 文件的元数据发生变化。比如权限，所有者等 |<br>6.从目标系统前台下载对应的有问题的文件，使用notepad++打开后，发现与PaxHeaders文件夹下的同名文件的内容完全一致。<br>7.至此，我找到了问题原因：1）在Linux的命令行生成tar包文件，最终的tar包包含了文件的元信息，在Windows下解压缩后相应的元信息生成了同名文件；2）目标系统的文件加载策略存在些许问题，并不是直接找到该文件，而更像是在某一文件夹下查找目标文件，而且支持子文件夹的查找，并返回找到的第一个文件。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>由于是我们系统架构升级，并且没有提前预测到这种情况的发生，也没有提前告知目标系统，让他们来临时修改加载策略肯定是不可能的了，只能依靠自身来解决了。不过还好，一旦定位到问题原因，解决起来也就更加方便了。<br>Linux下使用tar命令进行打包，既然可以生成元信息文件，那么肯定有参数控制其不生成这些信息文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">man tar</span><br><span class="line">……</span><br><span class="line">-H, --format=FORMAT</span><br><span class="line">  Create archive of the given format.  Valid formats are:</span><br><span class="line"></span><br><span class="line">  gnu    GNU tar 1.13.x format</span><br><span class="line"></span><br><span class="line">  oldgnu GNU format as per tar &lt;= 1.12.</span><br><span class="line"></span><br><span class="line">  pax, posix</span><br><span class="line"> POSIX 1003.1-2001 (pax) format.</span><br><span class="line"></span><br><span class="line">  ustar  POSIX 1003.1-1988 (ustar) format.</span><br><span class="line"></span><br><span class="line">  v7     Old V7 tar format.</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure><p>原来的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf test.tar test</span><br></pre></td></tr></table></figure><p>新的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 指定了打包格式</span><br><span class="line">tar --format&#x3D;gnu -cvf test.tar test</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Linux】Linux上的tar包拿到Windows下解压缩后新增了PaxHeaders文件夹以及其他文件</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="tar" scheme="https://born2do.github.io/tags/tar/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】crontab执行脚本与用户执行脚本存在差异</title>
    <link href="https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91crontab%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%AD%98%E5%9C%A8%E5%B7%AE%E5%BC%82/"/>
    <id>https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91crontab%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%AD%98%E5%9C%A8%E5%B7%AE%E5%BC%82/</id>
    <published>2021-04-28T14:22:16.000Z</published>
    <updated>2021-04-28T14:22:43.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><blockquote><p>最近公司项目在进行架构升级，硬件环境也由原来的AIX迁移到了Linux，硬件环境的不同也导致了较多问题。其中之一就是，crontab调用脚本监控系统运行情况，然而用户执行脚本与crontab执行产生了一定的差异。</p></blockquote><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><ul><li>首先，脚本内容并没有太大改动，仅仅是将一些变量取值的写法更新的更为准确。</li><li>其次，脚本中的第三方命令均使用全路径引用，不存在找不到命令的问题。</li><li>然后，我又比对了crontab与手工执行脚本的运行日志。crontab运行日志的时间戳全部为数字与英文结合，而手工执行的运行日志中的时间戳则是数字与汉字相结合；crontab的运行日志显示连接数据库查询数据失败了，而手工执行的运行日志则显示一切正常。</li></ul><p>经过排查，结果显而易见，crontab执行脚本时缺少用户手工执行脚本时的一些环境变量。用户在登录服务器时，会默认加载当前用户的环境变量（用户环境变量的配置以及加载不在此做过多赘述）。而crontab就不一定了，以老的AIX环境为例，crontab是会拥有当前用户的环境变量的，这也是为什么之前都是正常运行的；而新的Linux环境，明显就是必须要显示地引入当前用户的环境变量，否则会出现一系列问题。</p><p>实际上，一开始我是不建议将当前用户的所有环境变量都引入的，毕竟权限大了，谁也控制不住。我的想法是引入部分必要的环境变量就好，其他的环境变量，要用时再说。但是作为一名开发人员，我对Linux运维这块并不是过多了解，于是就找了公司里相关的运维老师。然而，在重试多次后，那位运维老师直接将当前用户的所有环境变量都引入了，简单粗暴。然后我就在嘀咕“问题原因我早就找到了，我只是想要一个最优解，然而你却把我最初的想法告诉了我，那我岂不是舍近求远？？？”。最后在项目组成员都本着“能正常运行就行”的基本原则，还是采用了全量引入当前用户环境变量的方法。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>有两种引入方式：<br>1.在crontab中引用当前用户环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在引入环境变量的同时，也可以指定脚本的解释器</span></span><br><span class="line">20 03 * * * (. /etc/profile;/bin/sh /var/test.sh)</span><br><span class="line">20 03 * * * (. ~/.profile;/bin/sh /var/test.sh)</span><br></pre></td></tr></table></figure><p>2.在脚本中引用当前用户环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Linux】crontab执行脚本与用户执行脚本存在差异</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="crontab" scheme="https://born2do.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>Page指令</title>
    <link href="https://born2do.github.io/2021/04/26/Page%E6%8C%87%E4%BB%A4/"/>
    <id>https://born2do.github.io/2021/04/26/Page%E6%8C%87%E4%BB%A4/</id>
    <published>2021-04-25T16:11:09.000Z</published>
    <updated>2021-04-25T16:11:32.292Z</updated>
    
    <content type="html"><![CDATA[<p>page指令称为页面指令，用来定义JSP页面的全局属性，该配置会作用于整个页面。</p><p>page指令的属性可以定义MIME类型、定义需要导入的包、错误页的指定等。</p><p>page指令的语法格式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@page</span> 属性<span class="number">1</span>=<span class="string">&quot;属性值1&quot;</span> 属性<span class="number">2</span>=<span class="string">&quot;属性值2&quot;</span> ...... %&gt;</span><br></pre></td></tr></table></figure><h2 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h2><p>page指令是针对当前页面的指令，常用的page指令如下：</p><blockquote><p>1.&lt;%@page language=”java”%&gt; 设置jsp中用到的语言，用到的是java，也是目前唯一有效的设定。</p><p>2.&lt;%@page extends=”mypackage.myclass”%&gt; 设置目前jsp要继承的父类，一般不需要设置，在默认情况下，jsp页面默认的父类是HttpJspBase。</p><p>3.&lt;%@page import=”java.sql.*”% &gt; jsp页面所用到的类。</p><p>4.&lt;%@page errorPage=”error.jsp”%&gt; 设置该jsp页面出现异常时所要转到的页面，如果没设定，容器将使用当前的页面显示错误信息。</p><p>5.&lt;%@page isErrorPage=”true”%&gt; 设置该jsp页面是否作为错误显示页面，默认是false，如果设置为true，容器则会在当前页面生成一个exception对象，和4搭配使用。</p><p>6.&lt;%@page contentType=”text/html;charset=gb2312”%&gt; 设置页面文件格式和编码方式。</p><p>7.&lt;%@page isThreadSafe=”true”% &gt; 设置容器以多线程还是单线程运行该jsp页面，默认是true，是多线程。设置为false，则以单线程的方式运行该jsp页面。</p><p>8.&lt;%@page session=”true”% &gt; 设置该jsp页面是否可以用到session对象(jsp内置对象，为web容器创建)，默认是true，能用到session；设置为false，则用不到。</p></blockquote><h2 id="page指令属性"><a href="#page指令属性" class="headerlink" title="page指令属性"></a>page指令属性</h2><p>page指令属性说明：</p><table><thead><tr><th>属性</th><th>定义</th></tr></thead><tbody><tr><td>language=”ScriptLanguage”</td><td>指定JSP Container用什么语言来编译，目前只支持JAVA语言。默认为JAVA</td></tr><tr><td>extends=”className”</td><td>定义此JSP网页产生的Servlet是继承哪个</td></tr><tr><td>import=”importList”</td><td>定义此JSP网页要使用哪些Java API</td></tr><tr><td>session=”true|false”</td><td>决定此页面是否使用session对象。默认为true</td></tr><tr><td>buffer=”none|size in kb”</td><td>决定输出流(Input stream)是否又缓冲区。默认为8kb</td></tr><tr><td>autoFlush=”true|false”</td><td>决定输出流的缓冲区慢了后是否需要自动清除，缓冲区慢了后会产生异常错误(Exception).默认为true</td></tr><tr><td>isThreadSafe=”true|false”</td><td>是否支持线程。默认为true</td></tr><tr><td>errorPage=”url”</td><td>如果此页发生异常，网页会重新指向一个url</td></tr><tr><td>isErrorPage=”true|false”</td><td>表示此页面是否为错误处理页面。默认为false</td></tr><tr><td>contentType=”text/html;charset=gb2312”</td><td>表示MIME类型和JSP的编码方式。笔者使用例左</td></tr><tr><td>pageEncoding=”ISO-8859-1”</td><td>编码方式。（笔者已经加入使用的编码）</td></tr><tr><td>isELLgnored=”true|false”</td><td>表示是否在此JSP页面中EL表达式。true则忽略，反之false则支持。默认为false</td></tr></tbody></table><p>language：定义要使用的脚本语言，目前只能是“java”，即language=”java”。</p><p>import：和一般的Java import意义一样，用于引入要使用的类，只是用逗号“,”隔开包或者类列表。默认省略，即不引入其他类或者包。例如，import=”java.io.*,java.util.Hashtable”。</p><p>session：指定所在页面是否参与HTTP会话。默认值为true，session=”true”。</p><p>buffer：指定到客户输出流的缓冲模式。如果为none，则不缓冲；如果指定数值，那么输出就用不小于这个值的缓冲区进行缓冲。与autoFlash一起使用。默认不小于8KB，根据不同的服务器可设置。例如，buffer=”64kb”。</p><p>autoFlash：如果为true缓冲区满时，到客户端输出被刷新；如果为false缓冲区满时，出现运行异常，表示缓冲区溢出。默认为true，例如autoFlash=”true”。</p><p>info：关于JSP页面的信息，定义一个字符串，可以使用servlet.getServletInfo()获得。 默认省略。例如，info=”测试页面”。</p><p>isErrorPage：表明当前页是否为其他页的errorPage目标。如果被设置为true，则可以使用exception对象。相反，如果被设置为false，则不可以使用exception对象。默认为false，例如，isErrorPage=”true”。</p><p>errorPage：定义此页面出现异常时调用的页面。默认忽略，例如errorPage=”error.jsp”。</p><p>isThreadSafe：用来设置JSP文件是否能多线程使用。如果设置为true，那么一个JSP能够同时处理多个用户的请求；相反，如果设置为false，一个JSP只能一次处理一个请求。例如，isThreadSafe=”true”。</p><p>contentType：定义JSP字符编码和页面响应的MIME类型。TYPE=MIME TYPE;charset=CHARSET。默认为TYPE=text/html,CHARSET=iso8859-1。例如contentType=”text/html;charset=gb2312”</p><p>pageEncoding：JSP页面的字符编码 ，默认值为pageEncoding=”iso-8859-1”，例如pageEncoding=”gb2312”。</p><p>isELIgnored：指定EL（表达式语言）是否被忽略。如果为true，则容器忽略”${}”表达式的计算。默认值由web.xml描述文件的版本确定，servlet2.3以前的版本将忽略。例如isELIgnored=”true”。</p>]]></content>
    
    
    <summary type="html">Page指令</summary>
    
    
    
    <category term="JSP" scheme="https://born2do.github.io/categories/JSP/"/>
    
    
    <category term="Page" scheme="https://born2do.github.io/tags/Page/"/>
    
  </entry>
  
  <entry>
    <title>【Java】System.out.println()简析</title>
    <link href="https://born2do.github.io/2021/04/26/%E3%80%90Java%E3%80%91System-out-println-%E7%AE%80%E6%9E%90/"/>
    <id>https://born2do.github.io/2021/04/26/%E3%80%90Java%E3%80%91System-out-println-%E7%AE%80%E6%9E%90/</id>
    <published>2021-04-25T16:09:44.000Z</published>
    <updated>2021-04-25T16:10:18.249Z</updated>
    
    <content type="html"><![CDATA[<p>Java编程中，我们经常用<code>System.out.println();</code>来向控制台输出变量值或是字符串，但是这条语句，究竟是什么样的，你深究过吗？</p><p>首先，System是java.lang包中的一个类；</p><p>其次，out是System类的一个静态成员变量，而且这个成员变量是java.io.PrintStream类的引用。</p><p><img src="https://i.loli.net/2021/04/26/vnRQKjUpAGTuLDI.png" alt="System.out.println__简析.png"></p><p>最后，println()是java.io.PrintStream类里的一个方法，它的作用是向控制台输出信息。</p><p>总结：被关键字static修饰的成员变量可以直接通过”类名.成员名”来引用，而无需创建类的实例。所以System.out是调用了System类的静态成员变量out。又因为System.out是java.io.PrintStream类的实例的引用，所以可以通过 System.out.println(); 来调用此方法。</p>]]></content>
    
    
    <summary type="html">【Java】System.out.println()简析</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="println" scheme="https://born2do.github.io/tags/println/"/>
    
  </entry>
  
  <entry>
    <title>vue无法加载文件vue.ps1，因为在此系统上禁止运行脚本</title>
    <link href="https://born2do.github.io/2021/04/25/vue%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6vue-ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/"/>
    <id>https://born2do.github.io/2021/04/25/vue%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6vue-ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/</id>
    <published>2021-04-25T00:43:45.000Z</published>
    <updated>2021-04-25T00:44:18.104Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vue : 无法加载文件 C:\Users\born2do\AppData\Roaming\npm\vue.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?Link </span><br><span class="line">ID&#x3D;135170 中的 about_Execution_Policies。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ vue create hotel-manager</span><br><span class="line">    + CategoryInfo          : SecurityError: (:) []，PSSecurityException</span><br><span class="line">    + FullyQualifiedErrorId : UnauthorizedAccess</span><br></pre></td></tr></table></figure><p>使用VS Code命令终端新建VUE项目，报错如题。</p><ul><li>出错原因<br>被系统禁止运行脚本。</li><li>解决</li></ul><ol><li>右键桌面左下角的小窗口，点击“Windows PowerShell(管理员)(A)”。</li><li>执行：set-ExecutionPolicy RemoteSigned （签名或运行这些脚本），在对话框中输入“y”，确认更改策略。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS C:\WINDOWS\system32&gt; set-ExecutionPolicy RemoteSigned</span><br><span class="line"></span><br><span class="line">执行策略更改</span><br><span class="line">执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170</span><br><span class="line">中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?</span><br><span class="line">[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): y</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <summary type="html">vue无法加载文件vue.ps1，因为在此系统上禁止运行脚本</summary>
    
    
    
    <category term="VUE" scheme="https://born2do.github.io/categories/VUE/"/>
    
    
    <category term="VUE" scheme="https://born2do.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>无法将vue项识别为 cmdlet、函数、脚本文件或可运行程序的名称</title>
    <link href="https://born2do.github.io/2021/04/25/%E6%97%A0%E6%B3%95%E5%B0%86vue%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0/"/>
    <id>https://born2do.github.io/2021/04/25/%E6%97%A0%E6%B3%95%E5%B0%86vue%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0/</id>
    <published>2021-04-25T00:40:58.000Z</published>
    <updated>2021-04-25T00:41:31.330Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。</span><br><span class="line">所在位置 行:1 字符: 1</span><br><span class="line">+ vue create hotel-manager</span><br><span class="line">+ ~~~</span><br><span class="line">    + FullyQualifiedErrorId : CommandNotFoundException</span><br></pre></td></tr></table></figure><p>使用VS Code命令终端新建VUE项目，报错如题。</p><ul><li>出错原因<br>第一次学习VUE，未安装VUE程序。</li><li>解决：</li></ul><ol><li>安装node.js 。<br>从官网下载对应版本的安装包，无脑安装即可。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 查看node版本号</span><br><span class="line">C:\Program Files&gt;node -v</span><br><span class="line">v12.19.0</span><br><span class="line">&#x2F;&#x2F; 查看npm版本号</span><br><span class="line">C:\Program Files&gt;npm -v</span><br><span class="line">6.14.8</span><br></pre></td></tr></table></figure></li><li>安装vue 。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Vue CLI 2.x 安装</span><br><span class="line">npm install vue-cli -g</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Vue CLI 3 安装</span><br><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 若想将2.x升级至3</span><br><span class="line">npm uninstall -g vue-cli</span><br><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 查看vue版本号</span><br><span class="line">C:\Program Files&gt;vue -V</span><br><span class="line">@vue&#x2F;cli 4.5.12</span><br></pre></td></tr></table></figure></li><li>配置环境变量<br>将node以及vue命令所在位置配置到环境变量Path中。<br>全局搜索下npm.cmd和vue.cmd文件，将其路径添加至Path中即可。</li></ol>]]></content>
    
    
    <summary type="html">无法将vue项识别为 cmdlet、函数、脚本文件或可运行程序的名称</summary>
    
    
    
    <category term="VUE" scheme="https://born2do.github.io/categories/VUE/"/>
    
    
    <category term="VUE" scheme="https://born2do.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL安装教程</title>
    <link href="https://born2do.github.io/2021/04/24/%E3%80%90MySQL%E3%80%91MySQL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>https://born2do.github.io/2021/04/24/%E3%80%90MySQL%E3%80%91MySQL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</id>
    <published>2021-04-24T04:57:35.000Z</published>
    <updated>2021-04-24T04:58:07.129Z</updated>
    
    <content type="html"><![CDATA[<p>对于MySQL的安装，个人建议使用zip压缩包解压缩安装，在线安装很有问题（你连接不了外网，很多东西无法下载）。</p><p>在此只进行压缩包安装方式的讲解。</p><ol><li><p> 下载压缩包并解压。从官网（<a href="https://dev.mysql.com/downloads/mysql/">https://dev.mysql.com/downloads/mysql/</a>）下载你自己想要的版本，下载后自行解压。</p></li><li><p>配置环境变量。</p><ul><li><p>  新建MYSQL_HOME变量，变量名为你的解压路径名。</p></li><li><p>  编辑path变量，在末尾加上<code>;%MYSQL_HOME%\bin;</code>。</p></li></ul></li><li><p>创建配置文件my.ini。</p><p> 在MySQL文件夹下创建my.ini文件，并编辑。内容如下：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">port &#x3D; 3306</span><br><span class="line"># 设置为自己MYSQL的安装目录</span><br><span class="line">basedir&#x3D;D:\tools\mysql-5.7.24-winx64</span><br><span class="line"># 设置MYSQL的数据目录，不要自己创建，后续操作会根据my.ini自动生成</span><br><span class="line">datadir&#x3D;D:\tools\mysql-5.7.24-winx64&#x2F;data</span><br><span class="line">max_connections&#x3D;200</span><br><span class="line">character-set-server&#x3D;utf8</span><br><span class="line">default-storage-engine&#x3D;INNODB</span><br><span class="line">sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line">default-character-set&#x3D;utf8</span><br></pre></td></tr></table></figure><ol start="4"><li><p>安装MySQL服务以及初始化。</p><ul><li><p>  以管理员身份运行cmd.exe（位置为C:\Windows\System32\cmd.exe），cd到你的MySQL安装目录的bin目录下（<strong>以下所有命令都需要进入到mysql安装目录的bin目录下进行！！！</strong>）。</p></li><li><p>执行安装mysql服务的命令：<code>mysqld --install</code></p><p>  成功安装后，会有“Service successfully installed”提示。</p></li><li><p>初始化MySQL：<code>mysqld --initialize</code></p><p>  在该步骤会初始化生成data文件夹，所以在前面我提示了不要自己创建文件夹。</p></li><li><p>  启动MySQL：<code>net start mysql</code></p></li><li><p>MySQL登录：<code>mysql -u root -p</code></p><p>  在该步骤会提示你创建密码，输入你自己设定的密码即可，下次登陆时即可使用。</p></li></ul></li></ol><p><strong>MySQL安装完成。</strong></p>]]></content>
    
    
    <summary type="html">【MySQL】MySQL安装教程</summary>
    
    
    
    <category term="MySQL" scheme="https://born2do.github.io/categories/MySQL/"/>
    
    
    <category term="软件安装" scheme="https://born2do.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java中private、default、protected、public的访问权限范围</title>
    <link href="https://born2do.github.io/2021/04/24/%E3%80%90Java%E3%80%91Java%E4%B8%ADprivate%E3%80%81default%E3%80%81protected%E3%80%81public%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4/"/>
    <id>https://born2do.github.io/2021/04/24/%E3%80%90Java%E3%80%91Java%E4%B8%ADprivate%E3%80%81default%E3%80%81protected%E3%80%81public%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4/</id>
    <published>2021-04-24T04:56:35.000Z</published>
    <updated>2021-04-24T04:57:18.862Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java中private、default、protected、public的访问权限范围"><a href="#Java中private、default、protected、public的访问权限范围" class="headerlink" title="Java中private、default、protected、public的访问权限范围"></a>Java中private、default、protected、public的访问权限范围</h3><p>访问权限：private&lt;default&lt;protected&lt;public</p><p>四种修饰符的访问权限范围：</p><table><thead><tr><th align="center">权限</th><th align="center">类内</th><th align="center">同包</th><th align="center">不同包子类</th><th align="center">不同包非子类</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">√</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">default</td><td align="center">√</td><td align="center">√</td><td align="center">×</td><td align="center">×</td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">【Java】Java中private、default、protected、public的访问权限范围</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="访问修饰符" scheme="https://born2do.github.io/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Java】HashTable和HashMap的区别</title>
    <link href="https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-23T12:46:34.000Z</published>
    <updated>2021-04-23T12:47:11.257Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>关于HashMap的一些说法：<br> a)  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br> b)  HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。<br> c)  HashMap实现不同步，线程不安全。  HashTable线程安全<br> d)  HashMap中的key-value都是存储在Entry中的。<br> e)  HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<br> f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。<br> 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br> 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>   拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。 </p></li><li><p>Hashtable和HashMap的区别：<br> a)   继承不同。<br>  public class Hashtable extends Dictionary implements Map<br> public class HashMap extends  AbstractMap implements Map<br> b)  Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br> c)  Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。<br> d)  两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br> e)  哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br> f)  Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 </p></li></ol><p>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。<br>     HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。 </p>]]></content>
    
    
    <summary type="html">【Java】HashTable和HashMap的区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="HashTable" scheme="https://born2do.github.io/tags/HashTable/"/>
    
    <category term="HashMap" scheme="https://born2do.github.io/tags/HashMap/"/>
    
  </entry>
  
</feed>
