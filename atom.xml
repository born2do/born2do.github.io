<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenHY的个人博客</title>
  
  
  <link href="https://born2do.github.io/atom.xml" rel="self"/>
  
  <link href="https://born2do.github.io/"/>
  <updated>2021-04-23T12:47:11.257Z</updated>
  <id>https://born2do.github.io/</id>
  
  <author>
    <name>chenhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Java】HashTable和HashMap的区别</title>
    <link href="https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-23T12:46:34.000Z</published>
    <updated>2021-04-23T12:47:11.257Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>关于HashMap的一些说法：<br> a)  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br> b)  HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。<br> c)  HashMap实现不同步，线程不安全。  HashTable线程安全<br> d)  HashMap中的key-value都是存储在Entry中的。<br> e)  HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<br> f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。<br> 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br> 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>   拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。 </p></li><li><p>Hashtable和HashMap的区别：<br> a)   继承不同。<br>  public class Hashtable extends Dictionary implements Map<br> public class HashMap extends  AbstractMap implements Map<br> b)  Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。<br> c)  Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。<br> d)  两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。<br> e)  哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。<br> f)  Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 </p></li></ol><p>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。<br>     HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。 </p>]]></content>
    
    
    <summary type="html">【Java】HashTable和HashMap的区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="HashTable" scheme="https://born2do.github.io/tags/HashTable/"/>
    
    <category term="HashMap" scheme="https://born2do.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java报错Illegal modifier for parameter x; only final is permitted</title>
    <link href="https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91Java%E6%8A%A5%E9%94%99Illegal-modifier-for-parameter-x-only-final-is-permitted/"/>
    <id>https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91Java%E6%8A%A5%E9%94%99Illegal-modifier-for-parameter-x-only-final-is-permitted/</id>
    <published>2021-04-23T12:45:41.000Z</published>
    <updated>2021-04-23T12:46:15.100Z</updated>
    
    <content type="html"><![CDATA[<p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 报错：Illegal modifier for parameter x; only final is permitted</span></span><br><span class="line"><span class="comment">// private int x = 1;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在main方法中定义了整型变量x，并使用private进行了修饰，系统报错，报错提示为：Illegal modifier for parameter x; only final is permitted。</p><p>事实上，在java语法里，方法的形参以及方法体中的变量都是局部变量，不能使用访问权限修饰符public、private或protected。解决方法就是把main方法里的访问权限修饰符private删除或换成final。除此之外不能用其他的修饰符修饰，包括static也会报同样的错误。</p>]]></content>
    
    
    <summary type="html">【Java】Java报错Illegal modifier for parameter x; only final is permitted</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="报错" scheme="https://born2do.github.io/tags/%E6%8A%A5%E9%94%99/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Echo详解</title>
    <link href="https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91Echo%E8%AF%A6%E8%A7%A3/"/>
    <id>https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91Echo%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-04-22T14:18:10.000Z</published>
    <updated>2021-04-22T14:18:32.512Z</updated>
    
    <content type="html"><![CDATA[<p>官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       echo - display a line of text</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       echo [SHORT-OPTION]... [STRING]...</span><br><span class="line">       echo LONG-OPTION</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Echo the STRING(s) to standard output.</span><br><span class="line"></span><br><span class="line">       -n     do not output the trailing newline</span><br><span class="line"></span><br><span class="line">       -e     enable interpretation of backslash escapes</span><br><span class="line"></span><br><span class="line">       -E     disable interpretation of backslash escapes (default)</span><br><span class="line"></span><br><span class="line">       --help display this help and exit</span><br><span class="line"></span><br><span class="line">       --version</span><br><span class="line">              output version information and exit</span><br><span class="line"></span><br><span class="line">       If -e is in effect, the following sequences are recognized:</span><br><span class="line"></span><br><span class="line">       \\     backslash</span><br><span class="line"></span><br><span class="line">       \a     alert (BEL)</span><br><span class="line"></span><br><span class="line">       \b     backspace</span><br><span class="line"></span><br><span class="line">       \c     produce no further output</span><br><span class="line"></span><br><span class="line">       \e     escape</span><br><span class="line"></span><br><span class="line">       \f     form feed</span><br><span class="line"></span><br><span class="line">       \n     new line</span><br><span class="line"></span><br><span class="line">       \r     carriage return</span><br><span class="line"></span><br><span class="line">       \t     horizontal tab</span><br><span class="line"></span><br><span class="line">       \v     vertical tab</span><br><span class="line"></span><br><span class="line">       \0NNN  byte with octal value NNN (1 to 3 digits)</span><br><span class="line"></span><br><span class="line">       \xHH   byte with hexadecimal value HH (1 to 2 digits)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n     不换行输出</span><br><span class="line"></span><br><span class="line">-e     激活转义字符</span><br><span class="line"></span><br><span class="line">-E     不激活转义字符(default)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Linux】Echo详解</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="Echo" scheme="https://born2do.github.io/tags/Echo/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】chmod命令给脚本赋权限</title>
    <link href="https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91chmod%E5%91%BD%E4%BB%A4%E7%BB%99%E8%84%9A%E6%9C%AC%E8%B5%8B%E6%9D%83%E9%99%90/"/>
    <id>https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91chmod%E5%91%BD%E4%BB%A4%E7%BB%99%E8%84%9A%E6%9C%AC%E8%B5%8B%E6%9D%83%E9%99%90/</id>
    <published>2021-04-22T14:17:07.000Z</published>
    <updated>2021-04-22T14:17:45.306Z</updated>
    
    <content type="html"><![CDATA[<p>Linux环境下不同的文件类型会有不同的颜色：</p><ul><li>蓝色表示目录；</li><li>绿色表示可执行文件，可执行的程序；</li><li>红色表示压缩文件或包文件；</li><li>浅蓝色表示链接文件；</li><li>灰色表示其它文件；</li><li>红色闪烁表示链接的文件有问题了；</li><li>黄色表示设备文件。</li></ul><p>在Linux环境下编写并保存脚本，该脚本将会是灰色的，是无法执行的，需要为其赋权限，可执行的权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x shfile.sh</span><br></pre></td></tr></table></figure><p>即为shfile.sh赋了可执行的权限。此时文件将会显示为绿色的。</p><p>不过，大多数情况下，我都是直接 <code>chmod 777 filename </code> ，简单快捷。</p>]]></content>
    
    
    <summary type="html">【Linux】chmod命令给脚本赋权限</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="chmod" scheme="https://born2do.github.io/tags/chmod/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java关键字</title>
    <link href="https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91Java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91Java%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-04-21T13:46:26.000Z</published>
    <updated>2021-04-21T13:47:23.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java关键字"><a href="#Java关键字" class="headerlink" title="Java关键字"></a>Java关键字</h2><p><img src="https://i.loli.net/2021/04/21/FK5cPRpNAUdeBZl.png" alt="Java关键字.png"></p><p>java全部关键字及含义：</p><p><img src="https://i.loli.net/2021/04/21/R1InDQJdy5kaeXc.png" alt="java全部关键字及含义.png"></p>]]></content>
    
    
    <summary type="html">【Java】Java关键字</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="关键字" scheme="https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>【Java】ArrayList和LinkedList</title>
    <link href="https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91ArrayList%E5%92%8CLinkedList/"/>
    <id>https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91ArrayList%E5%92%8CLinkedList/</id>
    <published>2021-04-21T13:45:03.000Z</published>
    <updated>2021-04-21T13:45:50.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><ul><li><p>  ArrayList与LinkedList都实现了List接口，继承了AbstractList类。</p></li><li><p>  ArrayList底层是动态数组是实现，随机位置添加和删除，都需要移动数组的数据，而LinkedList底层是双向链表，只需要修改Node节点的引用。</p></li><li><p>  随机访问数组要比链表快。</p></li></ul><p>ArrayList和LinkedList的区别：</p><p><img src="https://i.loli.net/2021/04/21/m2KcylOLqPUu6Hz.png" alt="ArrayList和LinkedList的区别.png"></p>]]></content>
    
    
    <summary type="html">【Java】ArrayList和LinkedList</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="ArrayList" scheme="https://born2do.github.io/tags/ArrayList/"/>
    
    <category term="LinkedList" scheme="https://born2do.github.io/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Navicat导入数据库</title>
    <link href="https://born2do.github.io/2021/04/20/Navicat%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://born2do.github.io/2021/04/20/Navicat%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</id>
    <published>2021-04-20T13:37:37.000Z</published>
    <updated>2021-04-20T13:37:58.051Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>右键数据库连接（我这里命名为MySQL），点击“新建数据库”，数据库名使用你即将导入的数据库名称，字符集使用“Default character set”或“utf8 – UTF-8 Unicode”（后者更为常用，但取决于你要导入的数据库的编码方式），点击“确定”完成数据库的创建。</p><p><img src="https://i.loli.net/2021/04/20/knQDC68cwqlL4Md.png" alt="Navicat导入数据库01.png"></p><p><img src="https://i.loli.net/2021/04/20/WPIY97hzVqrLTle.png" alt="Navicat导入数据库02.png"></p></li><li><p>双击新建的数据库，再右键数据库，点击“运行SQL文件”，选择要导入的<code>.sql</code>文件，点击“开始”，待运行完，即可完成数据库的导入。</p><p> <img src="https://i.loli.net/2021/04/20/J9cBZ4nMKmf3s1L.png" alt="Navicat导入数据库03.png"></p><p><img src="https://i.loli.net/2021/04/20/pj6PginMEemXKhH.png" alt="Navicat导入数据库04.png"></p></li></ol>]]></content>
    
    
    <summary type="html">Navicat导入数据库</summary>
    
    
    
    <category term="Navicat" scheme="https://born2do.github.io/categories/Navicat/"/>
    
    
    <category term="Navicat" scheme="https://born2do.github.io/tags/Navicat/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL学习Day01</title>
    <link href="https://born2do.github.io/2021/04/20/%E3%80%90MySQL%E3%80%91MySQL%E5%AD%A6%E4%B9%A0Day01/"/>
    <id>https://born2do.github.io/2021/04/20/%E3%80%90MySQL%E3%80%91MySQL%E5%AD%A6%E4%B9%A0Day01/</id>
    <published>2021-04-20T13:36:38.000Z</published>
    <updated>2021-04-20T13:37:08.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL在DOS下的基本操作"><a href="#MySQL在DOS下的基本操作" class="headerlink" title="MySQL在DOS下的基本操作"></a>MySQL在DOS下的基本操作</h2><ol><li><p>启动MySQL服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><p>关闭MySQL服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql</span><br></pre></td></tr></table></figure><p>注意：上述两个命令均不是以分号结尾。</p></li><li><p>登陆MySQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure><p>然后会让你输入密码，密码正确后即可进入MySQL。注意：该命令不是以分号结尾。</p><p>注意：有的登陆命令会是<code>mysql -h localhost -u root -p</code>，具体取决于你当时是怎么装MySQL的。</p></li><li><p>显示所有数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p>注意：<strong>从该步骤开始，每条命令均以分号结尾。</strong></p></li><li><p>进入数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure></li><li><p>查看该数据库中所有的表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure></li><li><p>创建数据库，并且指定编码utf-8：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database testdb default character set &#39;utf8&#39;;</span><br></pre></td></tr></table></figure><p>该处的“testdb”是数据库名。</p></li><li><p>创建表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table student(</span><br><span class="line">id int auto_increment primary key,</span><br><span class="line">name varchar(20) not null,</span><br><span class="line">age int</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查看表结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">describe student;</span><br></pre></td></tr></table></figure></li><li><p>查看当前数据库编码方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &#39;character_set_database&#39;;</span><br></pre></td></tr></table></figure></li><li><p>修改当前数据库编码方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database testdb character set gb2312;</span><br></pre></td></tr></table></figure><p>该处的“testdb”是数据库名。</p></li><li><p>查看MySQL的各种数据的编码方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like &quot;%character%&quot;;</span><br></pre></td></tr></table></figure><p>查询结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------------------------+----------------------------------------+</span><br><span class="line">| Variable_name            | Value                                  |</span><br><span class="line">+--------------------------+----------------------------------------+</span><br><span class="line">| character_set_client     | utf8                                   |</span><br><span class="line">| character_set_connection | utf8                                   |</span><br><span class="line">| character_set_database   | utf8                                   |</span><br><span class="line">| character_set_filesystem | binary                                 |</span><br><span class="line">| character_set_results    | utf8                                   |</span><br><span class="line">| character_set_server     | utf8                                   |</span><br><span class="line">| character_set_system     | utf8                                   |</span><br><span class="line">| character_sets_dir       | D:\mysql-5.7.25-winx64\share\charsets\ |</span><br><span class="line">+--------------------------+----------------------------------------+</span><br><span class="line">8 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>注意：最好在安装MySQL的时候就将数据库编码方式改为utf-8，不然后续会很麻烦。</p></li></ol>]]></content>
    
    
    <summary type="html">【MySQL】MySQL学习Day01</summary>
    
    
    
    <category term="MySQL" scheme="https://born2do.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://born2do.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Typora修改内容字体样式</title>
    <link href="https://born2do.github.io/2021/04/19/Typora%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/"/>
    <id>https://born2do.github.io/2021/04/19/Typora%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/</id>
    <published>2021-04-19T11:02:53.000Z</published>
    <updated>2021-04-19T11:03:48.580Z</updated>
    
    <content type="html"><![CDATA[<p>Typora文档编辑器，近年来越来越受到广大编程人员的喜爱，使用起来极易上手，文档格式编辑也更美观。但是，默认的中文字体样式是“宋体”，就本人而言，不喜欢。但是怎么修改呢？</p><h2 id="字体样式修改教程"><a href="#字体样式修改教程" class="headerlink" title="字体样式修改教程"></a>字体样式修改教程</h2><ol><li><p>在 Typora 中依次打开 文件-&gt;偏好设置-&gt;打开主题文件夹。</p><hr></li></ol><p><img src="https://i.loli.net/2021/04/19/A6Pq84aRdTEmfJK.png" alt="Typora01.png"></p><pre><code>* * *</code></pre><p><img src="https://i.loli.net/2021/04/19/Pxny5Kfug3osaIe.png" alt="Typora02.png"></p><pre><code>* * *</code></pre><p><img src="https://i.loli.net/2021/04/19/uf1k95XZ3ztLNBe.png" alt="Typora03.png"></p><ol start="2"><li><p>这里以GitHub主题为例，修改字体样式。</p><p> 用Sublime或WebStorm打开github.css，大约在40行左右有body标签样式，在font-family添加上你自己想要的字体名称，注意所有标点要用英文字符（名称是汉字的除外）。我这里增加了”楷体”。修改后保存关闭文件，再打开Typora，内容字体样式成功修改。</p></li></ol><p><img src="https://i.loli.net/2021/04/19/e7NcDVtURHrXh2p.png" alt="Typora04.png"></p>]]></content>
    
    
    <summary type="html">Typora修改内容字体样式</summary>
    
    
    
    <category term="Typora" scheme="https://born2do.github.io/categories/Typora/"/>
    
    
    <category term="Typora" scheme="https://born2do.github.io/tags/Typora/"/>
    
  </entry>
  
  <entry>
    <title>WebStorm找不到文件chrome</title>
    <link href="https://born2do.github.io/2021/04/19/WebStorm%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6chrome/"/>
    <id>https://born2do.github.io/2021/04/19/WebStorm%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6chrome/</id>
    <published>2021-04-19T11:01:49.000Z</published>
    <updated>2021-04-19T11:02:11.294Z</updated>
    
    <content type="html"><![CDATA[<p>最近重装了系统，软件也都重新装了一遍，但是在使用WebStorm的时候突然出现了无法使用google chrome，提示”windows 找不到文件chrome，请确定文件名是否正确后，再试一次”，这个问题的本质是WebStorm中关于chrome浏览器的路径是错误的，修改浏览器路径即可。</p><ol><li> 找到你本机中chrome浏览器的位置。右击桌面上的chrome浏览器图标，找到属性–&gt;快捷方式–&gt;目标，复制路径（即chrome浏览器.exe文件的路径）。</li></ol><p><img src="https://i.loli.net/2021/04/19/j6hTXsdGimNvegC.png" alt="WebStorm找不到文件chrome01.png"></p><ol start="2"><li> 修改WebStorm中chrome浏览器的路径。打开WebStorm软件，找到file–&gt;settings–&gt;Web Browsers，在chrome那一栏最右边的path中粘贴之前复制的路径，点击OK,问题即可解决。</li></ol><p><img src="https://i.loli.net/2021/04/19/gUmS9u5ZOy3MvK1.png" alt="WebStorm找不到文件chrome02.png"></p>]]></content>
    
    
    <summary type="html">WebStorm找不到文件chrome</summary>
    
    
    
    <category term="WebStorm" scheme="https://born2do.github.io/categories/WebStorm/"/>
    
    
    <category term="WebStorm" scheme="https://born2do.github.io/tags/WebStorm/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java中重写与重载的区别</title>
    <link href="https://born2do.github.io/2021/04/18/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/18/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-18T10:47:24.000Z</published>
    <updated>2021-04-18T10:47:56.533Z</updated>
    
    <content type="html"><![CDATA[<ol><li>重写<ul><li>发生在父类与子类之间 </li><li>方法名，参数列表，返回类型（除子类中方法的返回类型是父类中返回类型的子类）必须相同 </li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) </li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ul></li><li>重载<ul><li>重载Overload是一个类中多态性的一种表现 </li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) </li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ul></li><li>总结</li></ol><table><thead><tr><th></th><th>重载</th><th>重写（也称覆盖）</th></tr></thead><tbody><tr><td>英文</td><td>overloading</td><td>overriding</td></tr><tr><td>定义</td><td>方法名相同，参数列表不同（参数的类型、个数甚至顺序不同），对返回值无要求</td><td>方法名称，参数列表，返回值类型，完全相同</td></tr><tr><td>权限</td><td>对权限没有要求</td><td>被重写的方法不能拥有比父类更加严格的权限</td></tr><tr><td>范围</td><td>发生在同一个类中</td><td>发生在继承中</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">【Java】Java中重写与重载的区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="重写" scheme="https://born2do.github.io/tags/%E9%87%8D%E5%86%99/"/>
    
    <category term="重载" scheme="https://born2do.github.io/tags/%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>【基金】基金基础专业术语解释</title>
    <link href="https://born2do.github.io/2021/04/17/%E3%80%90%E5%9F%BA%E9%87%91%E3%80%91%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/"/>
    <id>https://born2do.github.io/2021/04/17/%E3%80%90%E5%9F%BA%E9%87%91%E3%80%91%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/</id>
    <published>2021-04-17T11:04:06.000Z</published>
    <updated>2021-04-17T11:04:28.349Z</updated>
    
    <content type="html"><![CDATA[<p>1.仓位说明<br>建仓：开始买进一些<br>加仓：继续买进，会拉高成本价（也即拉高成本净值）<br>补仓：跌了买一些<br>减仓：卖一些<br>全仓：投入所有资金<br>重仓：买进自有资产的80%左右<br>半仓：用掉所有资金一半买进<br>轻仓：只买了一小部分，比如20%-30%<br>2.操作说明<br>止损：亏钱卖出<br>追涨：基金一直涨，仍一直买进<br>杀跌：基金跌了，忍不住卖掉<br>踏空：一直在看，没上车买进<br>3.常见术语<br>累计净值：基金成立到现在的价格<br>交易确定日：确定你买入基金份额的日期<br>北上资金：北是沪深的股票，从香港股票流入大陆股市的资金<br>南下资金：南是香港的股票，从大陆股票流入香港股市的资金<br>现金分红：直接获取现金分红，免个人所得税，落袋为安</p>]]></content>
    
    
    <summary type="html">【基金】基金基础专业术语解释</summary>
    
    
    
    <category term="基金" scheme="https://born2do.github.io/categories/%E5%9F%BA%E9%87%91/"/>
    
    
    <category term="专业术语" scheme="https://born2do.github.io/tags/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>【MD】Typora快捷键</title>
    <link href="https://born2do.github.io/2021/04/17/%E3%80%90MD%E3%80%91Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://born2do.github.io/2021/04/17/%E3%80%90MD%E3%80%91Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2021-04-17T03:30:37.000Z</published>
    <updated>2021-04-17T03:31:14.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Typora快捷键"><a href="#Typora快捷键" class="headerlink" title="Typora快捷键"></a>Typora快捷键</h1><ol><li><p> 无序列表：输入“-”之后输入空格</p></li><li><p> 有序列表：输入数字+“.”之后输入空格</p></li><li><p>代码：</p><ol><li><p> 单行：一对 “`”</p></li><li><p> 多行：一对 “```”</p></li></ol></li><li><p> 任务列表：-[空格]空格 文字</p></li><li><p> 标题：ctrl+数字</p></li><li><p> 表格：ctrl+t</p></li><li><p> 引用：&gt;+空格</p></li><li><p> 生成目录：[TOC]按回车</p></li><li><p> 选中一整行：ctrl+l</p></li><li><p> 选中单词：ctrl+d</p></li><li><p> 选中相同格式的文字：ctrl+e</p></li><li><p> 跳转到文章开头：ctrl+home</p></li><li><p> 跳转到文章结尾：ctrl+end</p></li><li><p> 搜索：ctrl+f</p></li><li><p> 替换：ctrl+h</p></li><li><p> 引用：输入&gt;之后输入空格</p></li><li><p> 代码块：ctrl+alt+f</p></li><li><p> 加粗：ctrl+b</p></li><li><p> 倾斜：ctrl+i</p></li><li><p> 下划线：ctrl+u</p></li><li><p> 删除线：alt+shift+5</p></li><li><p> 插入图片：直接拖动到指定位置即可或者ctrl+shift+i</p></li><li><p> 插入链接：ctrl+k</p></li><li><p> 一级标题：输入#之后输入空格，然后再输入内容</p></li><li><p> Typora支持<a href="http://jekyllrb.com/docs/frontmatter/">YAML Front Matter</a>， 在<strong>文章开头</strong>输入<code>---</code>，然后按回车即可。</p></li></ol><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><p>1.怎么退出“无序列表”？</p><p>答：回车删除前面的点之后，用Shift+Tab去除缩进即可。</p>]]></content>
    
    
    <summary type="html">【MD】Typora快捷键</summary>
    
    
    
    <category term="MD" scheme="https://born2do.github.io/categories/MD/"/>
    
    
    <category term="快捷键" scheme="https://born2do.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>【Java】内部类</title>
    <link href="https://born2do.github.io/2021/04/17/%E3%80%90Java%E3%80%91%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://born2do.github.io/2021/04/17/%E3%80%90Java%E3%80%91%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2021-04-17T03:27:18.000Z</published>
    <updated>2021-04-17T03:27:47.561Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。<br>1.成员内部类<br>（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；<br>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量  或  外部类.this.成员方法】；<br>（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；<br>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；<br>（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。<br>2.局部内部类<br>（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；<br>（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。<br>3.匿名内部类<br>（1）一般使用匿名内部类的方法来编写事件监听代码；<br>（2）匿名内部类是不能有访问修饰符和static修饰符的；<br>（3）匿名内部类是唯一一种没有构造器的类；<br>（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。<br>4.内部静态类<br>（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；<br>（2）不能使用外部类的非static成员变量或者方法。 </p><p>提醒：<br>大多数企业级应用开发是要求减少内部类的使用，毕竟能用内部类实现的，基本类都是可以实现的。内部类并没有太大的优势体现出来。</p><h3 id="Java内部类思维导图"><a href="#Java内部类思维导图" class="headerlink" title="Java内部类思维导图"></a>Java内部类思维导图</h3><p><img src="https://i.loli.net/2021/04/17/Iwaks3vntSYpbWr.png" alt="Java内部类思维导图.png"></p>]]></content>
    
    
    <summary type="html">【Java】内部类</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="内部类" scheme="https://born2do.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>C语言零碎知识</title>
    <link href="https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/</id>
    <published>2021-04-16T09:41:01.000Z</published>
    <updated>2021-04-16T09:41:25.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="printf-格式字符"><a href="#printf-格式字符" class="headerlink" title="printf()格式字符"></a>printf()格式字符</h2><table><thead><tr><th>printf()格式字符</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>character</td><td>以字符形式输出单个字符</td></tr><tr><td>%s</td><td>string</td><td>输出一个字符串</td></tr><tr><td>%d</td><td>decimal</td><td>以带符号十进制整数输出</td></tr><tr><td>%f</td><td>float</td><td>以小数形式输出浮点数（6位小数）</td></tr><tr><td>%e</td><td>exponent</td><td>以标准指数形式输出（6位小数）</td></tr><tr><td>%g</td><td></td><td>选用%f，%e中输出宽度较小的一种格式</td></tr><tr><td>%o</td><td>octal</td><td>以八进制无符号整数输出（无前导0）</td></tr><tr><td>%x</td><td>hex</td><td>以十六进制无符号整数输出（无前导0x）</td></tr><tr><td>%u</td><td>unsigned</td><td>以十进制无符号整数输出</td></tr></tbody></table><h2 id="printf-的格式修饰符"><a href="#printf-的格式修饰符" class="headerlink" title="printf()的格式修饰符"></a>printf()的格式修饰符</h2><table><thead><tr><th>printf()格式修饰符</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>表示数据占用的最小宽度。数据宽度大于m，按实际宽度输出；数据宽度小于m时，补空格。</td></tr><tr><td>n</td><td>对实数表示输出n位小数。对字符串表示最多输出的字符个数。</td></tr><tr><td>l</td><td>长整型整数，加在d、o、x、u前</td></tr><tr><td>L</td><td>long double型数，加在f、e、g前</td></tr><tr><td>-</td><td>改变输出内容的对齐方式为左对齐，默认为右对齐</td></tr></tbody></table><h2 id="scanf-的格式字符"><a href="#scanf-的格式字符" class="headerlink" title="scanf()的格式字符"></a>scanf()的格式字符</h2><table><thead><tr><th>scanf()格式字符</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>以字符形式输入单个字符</td></tr><tr><td>%s</td><td>输入字符串,以非空字符开始,遇第一个空白字符结束</td></tr><tr><td>%d</td><td>以带符号十进制形式输入整型数据</td></tr><tr><td>%f</td><td>以小数形式输入浮点数</td></tr><tr><td>%e</td><td>以标准指数形式输入</td></tr><tr><td>%o</td><td>以八进制无符号形式输入（无前导0）</td></tr><tr><td>%x</td><td>以十六进制无符号形式输入（无前导0x）</td></tr></tbody></table><h2 id="scanf-的格式修饰符"><a href="#scanf-的格式修饰符" class="headerlink" title="scanf()的格式修饰符"></a>scanf()的格式修饰符</h2><table><thead><tr><th>scanf()格式修饰符</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>表示数据占用的宽度</td></tr><tr><td>l</td><td>加在d、o、x、u前：输入长整型；加在f、e 前：输入双精度型</td></tr><tr><td>L</td><td>加在f、e 前：输入long double型</td></tr><tr><td>h</td><td>加在d、o、x 前:输入短整型</td></tr><tr><td>*</td><td>本输入项在读入后不赋给相应的变量</td></tr></tbody></table><h2 id="文件打开方式（mode）："><a href="#文件打开方式（mode）：" class="headerlink" title="文件打开方式（mode）："></a>文件打开方式（mode）：</h2><p>①对应文本文件<br>“r”    只读    必须是已存在的文件<br>“w”    只写    不论该文件是否存在，都新建一个文件<br>“a”    追加    向文本文件尾增加数据，该文件必须存在<br>“r+”   读写    打开一个已存在的文件，用于读写<br>“w+”  读写    建立一个新文件，可读可写<br>“a+”   读写    向文件尾追加数据，也可读<br>②对应二进制文件<br>“rb”<br>“wb”<br>“ab”<br>“rb+”<br>“wb+”<br>“ab+”</p>]]></content>
    
    
    <summary type="html">C语言零碎知识</summary>
    
    
    
    <category term="C语言" scheme="https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="零碎知识" scheme="https://born2do.github.io/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言关键字</title>
    <link href="https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-04-16T09:38:58.000Z</published>
    <updated>2021-04-16T09:39:22.807Z</updated>
    
    <content type="html"><![CDATA[<p>由ANSI标准定义的C语言关键字共32个 : </p><p>auto  double  int  struct  break  else  long  switch</p><p>case  enum  register  typedef  char  extern  return  union</p><p>const  float  short  unsigned  continue  for  signed  void</p><p>default  goto  sizeof  volatile  do  if  while  static </p><p>根据关键字的作用，可以将关键字分为数据类型关键字和流程控制关键字两大类。</p><p>1． 数据类型关键字</p><p>A基本数据类型（5个）</p><p>void ：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</p><p>char ：字符型类型数据，属于整型数据的一种</p><p>int ：整型数据，通常为编译器指定的机器字长</p><p>float ：单精度浮点型数据，属于浮点数据的一种</p><p>double ：双精度浮点型数据，属于浮点数据的一种</p><p>B 类型修饰关键字（4个）</p><p>short ：修饰int，短整型数据，可省略被修饰的int。</p><p>long ：修饰int，长整形数据，可省略被修饰的int。</p><p>signed ：修饰整型数据，有符号数据类型</p><p>unsigned ：修饰整型数据，无符号数据类型</p><p>C 复杂类型关键字（5个）</p><p>struct ：结构体声明</p><p>union ：共用体声明</p><p>enum ：枚举声明</p><p>typedef ：声明类型别名</p><p>sizeof ：得到特定类型或特定类型变量的大小</p><p>D 存储级别关键字（6个）</p><p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</p><p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</p><p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</p><p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的韵蟮囊桓觥耙?谩?</p><p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</p><p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</p><p>2． 流程控制关键字</p><p>A 跳转结构（4个）</p><p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）</p><p>continue ：结束当前循环，开始下一轮循环</p><p>break ：跳出当前循环或switch结构</p><p>goto ：无条件跳转语句</p><p>B 分支结构（5个）</p><p>if ：条件语句</p><p>else ：条件语句否定分支（与if连用）</p><p>switch ：开关语句（多重分支语句）</p><p>case ：开关语句中的分支标记</p><p>default ：开关语句中的“其他”分治，可选。</p><p>C 循环结构（3个）</p><p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件</p><p>do ：do循环结构，do 1 while(2); 的执行顺序是 1-&gt;2-&gt;1…循环，2为循环条件</p><p>while ：while循环结构，while(1) 2; 的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件</p><p>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p>]]></content>
    
    
    <summary type="html">C语言关键字</summary>
    
    
    
    <category term="C语言" scheme="https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="关键字" scheme="https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>XML初识</title>
    <link href="https://born2do.github.io/2021/04/14/XML%E5%88%9D%E8%AF%86/"/>
    <id>https://born2do.github.io/2021/04/14/XML%E5%88%9D%E8%AF%86/</id>
    <published>2021-04-14T14:08:16.000Z</published>
    <updated>2021-04-14T14:09:19.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-XML"><a href="#1-什么是-XML" class="headerlink" title="1.什么是 XML?"></a>1.什么是 XML?</h3><ul><li><p>  XML 指可扩展标记语言（EXtensible Markup Language）</p></li><li><p>  XML 是一种标记语言，很类似 HTML</p></li><li><p>  XML 的设计宗旨是传输数据，而非显示数据</p></li><li><p>  XML 标签没有被预定义。需要自行定义标签。</p></li><li><p>  XML 被设计为具有自我描述性。</p></li><li><p>  XML 是 W3C 的推荐标准</p></li></ul><h3 id="2-XML-与-HTML-的主要差异"><a href="#2-XML-与-HTML-的主要差异" class="headerlink" title="2.XML 与 HTML 的主要差异"></a>2.XML 与 HTML 的主要差异</h3><ul><li><p>  XML 不是 HTML 的替代。</p></li><li><p>XML 和 HTML 为不同的目的而设计：</p><ul><li><p>  XML 被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>  HTML 被设计用来显示数据，其焦点是数据的外观。</p></li><li><p>  HTML 旨在显示信息，而 XML 旨在传输信息。</p></li></ul></li></ul><h3 id="3-没有任何行为的-XML"><a href="#3-没有任何行为的-XML" class="headerlink" title="3.没有任何行为的 XML"></a>3.没有任何行为的 XML</h3><p>XML 是不作为的。  也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。  下面是 John 写给 George 的便签，存储为 XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这条便签具有自我描述性。它拥有标题以及留言，同时包含了发送者和接受者的信息。  但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p><h3 id="4-XML-仅仅是纯文本"><a href="#4-XML-仅仅是纯文本" class="headerlink" title="4.XML 仅仅是纯文本"></a>4.XML 仅仅是纯文本</h3><p>XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。  不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。</p><h3 id="5-通过-XML-你可以发明自己的标签"><a href="#5-通过-XML-你可以发明自己的标签" class="headerlink" title="5.通过 XML 你可以发明自己的标签"></a>5.通过 XML 你可以发明自己的标签</h3><p>上例中的标签没有在任何 XML 标准中定义过（比如 <code>&lt;to&gt;</code> 和 <code>&lt;from&gt;</code>）。这些标签是由文档的创作者发明的。  这是因为 XML 没有预定义的标签。  在 HTML 中使用的标签（以及 HTML 的结构）是预定义的。HTML 文档只使用在 HTML 标准中定义过的标签（比如 <code>&lt;p&gt;</code> 、<code>&lt;h1&gt;</code> 等等）。  XML 允许创作者定义自己的标签和自己的文档结构。</p><h3 id="6-XML-不是对-HTML-的替代"><a href="#6-XML-不是对-HTML-的替代" class="headerlink" title="6.XML 不是对 HTML 的替代"></a>6.XML 不是对 HTML 的替代</h3><p>XML 是对 HTML 的补充。  XML 不会替代 HTML，理解这一点很重要。在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。  对 XML 最好的描述是：  XML 是独立于软件和硬件的信息传输工具。</p><p>参考文章：<a href="http://www.w3school.com.cn/xml/xml_intro.asp">http://www.w3school.com.cn/xml/xml_intro.asp</a></p>]]></content>
    
    
    <summary type="html">XML初识</summary>
    
    
    
    <category term="XML" scheme="https://born2do.github.io/categories/XML/"/>
    
    
    <category term="XML" scheme="https://born2do.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>【Java】JSF中Bean的作用域</title>
    <link href="https://born2do.github.io/2021/04/14/%E3%80%90Java%E3%80%91JSF%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://born2do.github.io/2021/04/14/%E3%80%90Java%E3%80%91JSF%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-04-14T14:02:55.000Z</published>
    <updated>2021-04-14T14:03:23.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSF-2-x"><a href="#JSF-2-x" class="headerlink" title="JSF 2.x"></a>JSF 2.x</h1><p>从JSF 2.x开始，有4个Bean范围：<br>@ViewScoped<br>@RequestScoped<br>@SessionScoped<br>@ApplicationScoped</p><p>ViewScope： View范围是在JSF 2.0中添加的。 重新显示相同的JSF页面时，视图范围内的bean仍然存在。 （JSF规范将术语“视图”用于JSF页面。）一旦用户导航到另一个页面，Bean就会超出范围。</p><p>RequestScope：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。</p><p>SessionScoped：会话范围从建立会话到会话终止一直存在。 如果Web应用程序在HttpSession对象上调用invalidate方法，或者会话超时，则会话终止。</p><p>ApplicationScope：应用程序作用域在Web应用程序的整个过程中一直存在。 该范围在所有请求和所有会话之间共享。 如果应在Web应用程序的所有实例之间共享单个bean，则将托管bean放入应用程序范围。 Bean是在应用程序的任何用户首次请求时构造的，并且一直保持活动状态，直到从应用程序服务器中删除Web应用程序为止。</p><p>根据需要选择范围。</p><h1 id="JSF-2-3"><a href="#JSF-2-3" class="headerlink" title="JSF 2.3"></a>JSF 2.3</h1><p>从JSF 2.3开始，已弃用javax.faces.bean包中定义的所有bean作用域，以使作用域与CDI对齐。 此外，它们仅在您的bean使用@ManagedBean注释时才适用。 如果您使用的JSF版本低于2.3，请参考最后的遗留答案。</p><p>从JSF 2.3开始，这里是可以在JSF Backing Bean上使用的范围：</p><ol><li><p>@javax.enterprise.context.ApplicationScoped ：应用程序作用域在Web应用程序的整个持续时间内一直存在。 该范围在所有请求和所有会话之间共享。 当您拥有整个应用程序的数据时，这很有用。</p></li><li><p>@javax.enterprise.context.SessionScoped ：会话范围从建立会话的时间一直持续到会话终止为止。 会话上下文在同一HTTP会话中发生的所有请求之间共享。 当您不想为特定会话保存特定客户端的数据时，此功能很有用。</p></li><li><p>@javax.enterprise.context.ConversationScoped ：对话范围随着bean的存在而保持为日志。 范围提供2种方法： Conversation.begin()和Conversation.end() 。 这些方法应显式调用，以开始或结束Bean的生命。</p></li><li><p>@javax.enterprise.context.RequestScoped ：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。</p></li><li><p>@javax.faces.flow.FlowScoped ：只要Flow存在，Flow范围就会持续存在。 流可以定义为一组包含页面（或视图）的页面，这些页面定义了一个工作单元。 只要用户在Flow中进行导航，作用域就可以激活。</p></li><li><p>@javax.faces.view.ViewScoped ：视图范围内的Bean在重新显示同一JSF页面时仍然存在。 一旦用户导航到另一个页面，Bean就会超出范围。</p></li></ol><p>转载自 <a href="https://my.oschina.net/u/3797416/blog/3166873">https://my.oschina.net/u/3797416/blog/3166873</a> 。</p>]]></content>
    
    
    <summary type="html">【Java】JSF中Bean的作用域</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="JSF" scheme="https://born2do.github.io/tags/JSF/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Spring中注解可以在哪些地方</title>
    <link href="https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/</id>
    <published>2021-04-13T13:13:37.000Z</published>
    <updated>2021-04-13T13:55:13.291Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中的注解根据所在位置主要分为两类：</p><p>类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。</p><p>类内部的注解：如@Autowired、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。</p><p>正常情况下，接口以及抽象类文件中是不能使用注解的。<br>因为spring的原理是启动服务器时读取配置文件，取得类名后利用反射机制在spring上下文中生成一个单例的对象，由spring注入属性并维护此对象的状态，抽象类/接口在反射生成对象时就已经失败了，spring无法注入，后续的其他操作也将不会进行。</p>]]></content>
    
    
    <summary type="html">【Java】Spring中注解可以在哪些地方</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="注解" scheme="https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Spring项目中相关注解</title>
    <link href="https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
    <id>https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-04-13T13:12:35.000Z</published>
    <updated>2021-04-13T13:13:10.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-声明bean的注解"><a href="#1-声明bean的注解" class="headerlink" title="1.声明bean的注解"></a>1.声明bean的注解</h1><p>@Controller 在表现层使用，控制器（注入服务）<br>用于标注控制层。</p><p>@Service 在业务逻辑层使用，服务（注入dao）<br>用于标注服务层，主要用来进行业务的逻辑处理。</p><p>@Repository 在数据访问层使用，（实现dao访问）<br>用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件。</p><p>@Component 组件，通用的注解方式<br>泛指各种组件，也即当我们的类不属于任何一种归类（@Controller、@Service等）的时候，但我们又要将该类实例化到spring容器中，我们就可以使用@Component来标注这个类。</p><h1 id="2-注入bean的注解"><a href="#2-注入bean的注解" class="headerlink" title="2.注入bean的注解"></a>2.注入bean的注解</h1><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上。</p><h1 id="3-java配置类相关注解"><a href="#3-java配置类相关注解" class="headerlink" title="3.java配置类相关注解"></a>3.java配置类相关注解</h1><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置(类上)</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式(方法上)</p><p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean(类上)</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的(类上)</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><h1 id="4-切面-AOP-相关注解"><a href="#4-切面-AOP-相关注解" class="headerlink" title="4.切面(AOP)相关注解"></a>4.切面(AOP)相关注解</h1><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面(类上)</p><p>使用@After、@Before、@Around定义建言(advice)，可直接将拦截规则(切点)作为参数。</p><p>@After 在方法执行之后执行(方法上) @Before 在方法执行之前执行(方法上) @Around 在方法执行之前与之后执行(方法上)</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持(类上)</p><h1 id="5-Bean的属性支持"><a href="#5-Bean的属性支持" class="headerlink" title="5.@Bean的属性支持"></a>5.@Bean的属性支持</h1><p>@Scope 设置Spring容器如何新建Bean实例(方法上要有@Bean)</p><blockquote><p>其设置类型包括：<br>· Singleton (单例，一个Spring容器中只有一个bean实例，默认模式),<br>· Protetype (每次调用新建一个bean),<br>· Request (web项目中，给每个http request新建一个bean),<br>· Session (web项目中，给每个http session新建一个bean),<br>· GlobalSession(给每一个 global http session新建一个Bean实例)</p></blockquote><p>@StepScope 在Spring Batch中有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p>]]></content>
    
    
    <summary type="html">【Java】Spring项目中相关注解</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="注解" scheme="https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
</feed>
