<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenHY的个人博客</title>
  
  
  <link href="https://born2do.github.io/atom.xml" rel="self"/>
  
  <link href="https://born2do.github.io/"/>
  <updated>2021-05-13T12:43:56.683Z</updated>
  <id>https://born2do.github.io/</id>
  
  <author>
    <name>chenhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【DB2】DB2基础_表空间和缓冲池</title>
    <link href="https://born2do.github.io/2021/05/13/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <id>https://born2do.github.io/2021/05/13/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%93%E5%86%B2%E6%B1%A0/</id>
    <published>2021-05-13T12:43:06.000Z</published>
    <updated>2021-05-13T12:43:56.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于刚涉足 DB2 领域的 DBA 或未来的 DBA 而言，新数据库的设计和性能选择可能会很令人困惑。在本文中，我们将讨论 DBA 要做出重要选择的两个方面：表空间和缓冲池。表空间和缓冲池的设计和调优会对 DB2 服务器的性能产生深远的影响，因此我们将着重讨论这些活动。</p><p>在我们的示例中，我们将使用 DB2 V8.1 企业服务器版。大多数示例也适用于低级版本。我们会让您知道某个示例是否只适用于 V8.1。</p><p>在 第 1 节中，我们将从定义表空间的类型开始，并将说明 DB2 如何将数据存储在表空间中。我们将介绍配置选项并向您介绍创建和管理表空间的整个过程。接下来，我们将着重讨论 缓冲池，介绍缓冲池是什么以及如何创建和使用它。在 第 2 节中，我们将结合这两个方面并讨论该如何组织缓冲池和表空间才能获得最佳性能。</p><h2 id="第-1-节：定义"><a href="#第-1-节：定义" class="headerlink" title="第 1 节：定义"></a>第 1 节：定义</h2><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>数据库中的所有数据都存储在许多表空间中。可以认为表空间是孩子而数据库是其父母，其中表空间（孩子）不能有多个数据库（父母）。由于表空间有不同用途，因此根据它们的用途和管理方式将它们分类。根据用途有五种不同的表空间：</p><ul><li><p><strong>目录表空间</strong></p><p>每个数据库只有一个目录表空间，它是在发出 CREATE DATABASE 命令时创建的。目录表空间被 DB2 命名为 SYSCATSPACE，它保存了系统目录表。总是在创建数据库时创建该表空间。</p></li><li><p><strong>常规表空间</strong></p><p>常规表空间保存表数据和索引。它还可以保存诸如大对象（Large Object，LOB）之类的长数据，除非这些数据显式地存储在长表空间中。如果某些表空间是数据库管理的空间（Database Managed Space，DMS），则可以将表及其索引分别放到单独的常规表空间中。我们将在本文后面定义 DMS 和系统管理的空间（System Managed Space，SMS）之间的区别。每个数据库中必须至少有一个常规表空间。创建数据库时指定该表空间的缺省名为 USERSPACE1。</p></li><li><p><strong>长表空间</strong></p><p>长表空间用于存储长型或 LOB 表列，它们必须驻留在 DMS 表空间中。它们还可以存储结构化类型的列或索引数据。如果没有定义长表空间，那么将把 LOB 存储在常规表空间中。长表空间是可选的，缺省情况下一个都不创建。</p></li><li><p><strong>系统临时表空间</strong></p><p>系统临时表空间用于存储 SQL 操作（比如排序、重组表、创建索引和连接表）期间所需的内部临时数据。每个数据库必须至少有一个系统临时表空间。随数据库创建的系统临时表空间的缺省名为 TEMPSPACE1。</p></li><li><p><strong>用户临时表空间</strong></p><p>用户临时表空间存储已声明的全局临时表。创建数据库时不存在用户临时表空间。至少应当创建一个用户临时表空间以允许定义已声明的临时表。用户临时表空间是可选的，缺省情况下一个都不创建。</p></li></ul><h3 id="表空间管理"><a href="#表空间管理" class="headerlink" title="表空间管理"></a>表空间管理</h3><p>可以用两种不同的方式管理表空间：</p><ul><li><p><strong>系统管理的空间（SMS）</strong></p><p>SMS 表空间由操作系统进行管理。容器被定义成常规操作系统文件，并且是通过操作系统调用访问的。这意味着所有的常规操作系统功能将处理以下内容：操作系统将缓冲 I/O；根据操作系统约定分配空间；如有必要就自动扩展表空间。但是，不能从 SMS 表空间删除容器，并且仅限于将新的容器添加到分区的数据库。前一节中所说明的那三个缺省表空间都是 SMS。</p></li><li><p><strong>数据库管理的空间（DMS）</strong></p><p>DMS 表空间是由 DB2 管理的。可以将容器定义成文件（在创建表空间时将把给定的大小全部分配给它们）或设备。分配方法和操作系统允许多少 I/O，DB2 就可以管理多少 I/O。可以通过使用 altER TABLESPACE 命令来扩展容器。还可以释放未使用的那部分 DMS 容器（从 V8 开始）。</p></li></ul><p>下面是一个示例，向您说明该如何增大容器大小（V7 和 V8 都支持此功能）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE TS1 RESIZE (FILE <span class="string">&#x27;/conts/cont0&#x27;</span> <span class="number">2000</span>, DEVICE <span class="string">&#x27;/dev/rcont1&#x27;</span> <span class="number">2000</span>, FILE <span class="string">&#x27;cont2&#x27;</span> <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>请注意，只有 V8 才支持将原始容器的大小调整得更小。</p><h3 id="如何创建和查看表空间"><a href="#如何创建和查看表空间" class="headerlink" title="如何创建和查看表空间"></a>如何创建和查看表空间</h3><p>当您创建数据库时，将创建三个表空间（SYSCATSPACE、TEMPSPACE1 和 USERSPACE1）。通过使用 DB2 命令窗口（Command Window）或 UNIX 命令行，创建一个名为 testdb 的数据库，连接至该数据库，然后列出表空间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testdb <span class="keyword">CONNECT</span> <span class="keyword">TO</span> testdb LIST TABLESPACES</span><br></pre></td></tr></table></figure><p>下面的 清单 1显示了 LIST TABLESPACES 命令的输出。</p><p><em>清单 1. LIST TABLESPACES 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespaces for Current Database Tablespace ID &#x3D; 0 Name &#x3D; SYSCATSPACE Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 1 Name &#x3D; TEMPSPACE1 Type &#x3D; System managed space Contents &#x3D; System Temporary data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal</span><br></pre></td></tr></table></figure><p>上面所示的这三个表空间是通过 CREATE DATABASE 命令自动创建的。用户可以通过在该命令中包含表空间说明来覆盖缺省的表空间创建，但是在创建数据库时必须创建一个目录表空间和至少一个常规表空间，以及至少一个系统临时表空间。通过使用 CREATE DATABASE 命令或以后使用 CREATE TABLESPACE 命令，可以创建更多的所有类型的表空间（目录表空间除外）。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>每个表空间都有一个或多个容器。重申一次，您可以认为容器是孩子，而表空间是其父母。每个容器只能属于一个表空间，但是一个表空间可以拥有许多容器。可以将容器添加到 DMS 表空间，或者从 DMS 表空间中删除容器，而且可以更改容器的大小。只能将容器添加到某个分区中分区数据库上的 SMS 表空间，在添加之前该分区还未给表空间分配容器。添加新的容器时，将启动一个自动的重新均衡操作以便将数据分布到所有容器上。重新均衡操作不会妨碍对数据库的并发访问。</p><h3 id="表空间设置"><a href="#表空间设置" class="headerlink" title="表空间设置"></a>表空间设置</h3><p>可以在创建表空间时给它们指定许多设置，或者也可以稍后使用 altER TABLESPACE 语句时指定其设置。</p><ul><li><p><strong>页大小（Page size）</strong></p><p>定义表空间所使用的页大小。所支持的大小为 4K、8K、16K 和 32K。页大小根据下表限定了可放到表空间中的表的行长度和列数：</p><p><em>表 1. 页大小的含义</em></p><table><thead><tr><th>页大小</th><th>行大小</th><th>限制列数</th><th>限制最大容量</th></tr></thead><tbody><tr><td>4 KB</td><td>4 005</td><td>500</td><td>64 GB</td></tr><tr><td>8 KB</td><td>8 101</td><td>1 012</td><td>128 GB</td></tr><tr><td>16 KB</td><td>16 293</td><td>1 012</td><td>256 GB</td></tr><tr><td>32 KB</td><td>32 677</td><td>1 012</td><td>512 GB</td></tr></tbody></table><p>表空间最多可包含 16384 个页，因此选择较大的页大小可以增加表空间的容量。</p></li><li><p><strong>扩展块大小（Extent size）</strong></p><p>指定在跳到下一个容器之前将写到当前容器中的页数。存储数据时数据库管理器反复循环使用所有容器。该参数只有在表空间中有多个容器时才起作用。</p></li><li><p><strong>预取大小（Prefetch size）</strong></p><p>指定当执行数据预取时将从表空间读取的页数。预取操作在查询引用所需的数据之前读入这些数据，这样一来查询就不必等待执行 I/O 了。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，它就选择预取操作。</p></li><li><p><strong>开销（Overhead）和传送速率（Transfer rate）</strong></p><p>这些值用于确定查询优化期间的 I/O 成本。这两个值的测量单位都是毫秒，而且它们应当分别是所有容器开销和传送速率的平均值。开销是与 I/O 控制器活动、磁盘寻道时间和旋转延迟时间相关联的时间。传送速率是将一个页读入内存所必需的时间量。它们的缺省值分别是 24.1 和 0.9。可以根据硬件规格计算这些值。</p></li></ul><h3 id="CREATE-TABLESPACE-语句的示例"><a href="#CREATE-TABLESPACE-语句的示例" class="headerlink" title="CREATE TABLESPACE 语句的示例"></a>CREATE TABLESPACE 语句的示例</h3><p>下列语句将创建一个常规表空间。所讨论的所有设置都是为了进行说明。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE USERSPACE3 PAGESIZE <span class="number">8</span>K MANAGED <span class="keyword">BY</span> <span class="keyword">SYSTEM</span> <span class="keyword">USING</span> (<span class="string">&#x27;d:\\usp3_cont1&#x27;</span>, <span class="string">&#x27;e:\\usp3_cont2&#x27;</span>, <span class="string">&#x27;f:\\usp3_cont3&#x27;</span>) EXTENTSIZE <span class="number">64</span> PREFETCHSIZE <span class="number">32</span> BUFFERPOOL BP3 OVERHEAD <span class="number">24.1</span> TRANSFERRATE <span class="number">0.9</span></span><br></pre></td></tr></table></figure><h3 id="如何查看表空间的属性和容器"><a href="#如何查看表空间的属性和容器" class="headerlink" title="如何查看表空间的属性和容器"></a>如何查看表空间的属性和容器</h3><p>指定 LIST TABLESPACES 命令的 SHOW DETAIL 选项将显示其它信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST TABLESPACES SHOW DETAIL</span><br></pre></td></tr></table></figure><p>清单 2显示了 USERSPACE1 表空间的输出。缺省情况下，将列出创建数据库时所创建的那三个表空间。</p><p><em>清单 2. LlST TABLESPACES SHOW DETAIL 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespaces for Current Database Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Total pages &#x3D; 336 Useable pages &#x3D; 336 Used pages &#x3D; 336 Free pages &#x3D; Not applicable High water mark (pages) &#x3D; Not applicable Page size (bytes) &#x3D; 4096 Extent size (pages) &#x3D; 32 Prefetch size (pages) &#x3D; 16 Number of containers &#x3D; 1</span><br></pre></td></tr></table></figure><p>要列出容器，我们需要使用以上输出中的 Tablespace ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST TABLESPACE CONTAINERS FOR 2</span><br></pre></td></tr></table></figure><p><em>清单 3. LIST TABLESPACE CONTAINERS 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespace Containers for Tablespace 2 Container ID &#x3D; 0 Name &#x3D; C:\\DB2\\NODE0000\\SQL00004\\SQLT0002.0 Type &#x3D; Path</span><br></pre></td></tr></table></figure><p>该命令将列出指定表空间中的所有容器。如上所示的路径指向容器物理上所在的位置。</p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>一个缓冲池是与单个数据库相关联的，可以被多个表空间使用。当考虑将缓冲池用于一个或多个表空间时，必须保证表空间页大小和缓冲池页大小对于缓冲池所“服务”的所有表空间而言都是一样的。一个表空间只能使用一个缓冲池。</p><p>创建数据库时，会创建一个名为 IBMDEFAULTBP 的缺省缓冲池，所有的表空间都共享该缓冲池。可以使用 CREATE BUFFERPOOL 语句添加更多的缓冲池。缓冲池的缺省大小是 BUFFPAGE 数据库配置参数所指定的大小，但是可以通过在 CREATE BUFFERPOOL 命令中指定 SIZE 关键字来覆盖该缺省值。足够的缓冲池大小是数据库拥有良好性能的关键所在，因为它可以减少磁盘 I/O 这一最耗时的操作。大型缓冲池还会对查询优化产生影响，因为更多的工作可在内存中完成。</p><p><strong>基于块的缓冲池</strong><br>V8 允许您留出缓冲池的一部分（最高可达 98%）用于基于块的预取操作。基于块的 I/O 可以通过将块读入相邻的内存区而不是将它分散装入单独的页，来提高预取操作的效率。每个缓冲池的块大小必须相同，并且由 BLOCKSIZE 参数进行控制。该值等于块的大小（单位为页），从 2 到 256，缺省值为 32。</p><p><strong>扩展存储器</strong><br>DB2 不将扩展存储器用于缓冲区。但是，可以用扩展存储器来高速缓存内存页，使得从内存移出页变得更快。</p><h3 id="CREATE-BUFFERPOOL-语句的示例"><a href="#CREATE-BUFFERPOOL-语句的示例" class="headerlink" title="CREATE BUFFERPOOL 语句的示例"></a>CREATE BUFFERPOOL 语句的示例</h3><p>下面是 CREATE BUFFERPOOL 语句的一个示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> BUFFERPOOL BP3 SIZE <span class="number">2000</span> PAGESIZE <span class="number">8</span>K</span><br></pre></td></tr></table></figure><p>该缓冲池被分配给上面的 CREATE TABLESPACE 示例上的 USERSPACE3，并且在创建表空间之前创建该缓冲池。请注意，缓冲池和表空间的页大小都是 8K，两者是相同的。如果您在创建缓冲池之后创建表空间，则可以省去 CREATE TABLESPACE 语句中的 BUFFER POOL BP3 语法。相反，可以使用 altER TABLESPACE 命令将缓冲池添加到现有的表空间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE USERSPACE3 BUFFERPOOL BP3</span><br></pre></td></tr></table></figure><h3 id="如何查看缓冲池属性"><a href="#如何查看缓冲池属性" class="headerlink" title="如何查看缓冲池属性"></a>如何查看缓冲池属性</h3><p>通过查询 SYSCAT.BUFFERPOOLS 系统视图可以列出缓冲池信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM SYSCAT.BUFFERPOOLS BPNAME BUFFERPOOLID NGNAME NPAGES PAGESIZE ES ------------------ ------------ ------------------ ----------- ----------- -- IBMDEFAULTBP 1 - 250 4096 N 1 record(s) selected.</span><br></pre></td></tr></table></figure><p>要找出哪个缓冲池被分配给了表空间，请运行下面这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TBSPACE, BUFFERPOOLID FROM SYSCAT.TABLESPACES TBSPACE BUFFERPOOLID ------------------ ------------ SYSCATSPACE 1 TEMPSPACE1 1 USERSPACE1 1 3 record(s) selected.</span><br></pre></td></tr></table></figure><p>可以在上一个查询中找到 BUFFERPOOLID，该查询使您能够看到每个表空间与哪个缓冲池相关联。</p><h3 id="数据库如何保存表空间的可视化图表"><a href="#数据库如何保存表空间的可视化图表" class="headerlink" title="数据库如何保存表空间的可视化图表"></a>数据库如何保存表空间的可视化图表</h3><p>既然我们已经描述了表空间和缓冲池是什么以及如何创建它们，那么就让我们研究一下有关如何在数据库中将它们直观地组织起来的示例。</p><p>图 1. 表空间和缓冲池</p><p><img src="https://i.loli.net/2021/05/13/IQUgrfiT45c6Wlu.gif" alt="wieser1.gif"></p><p>该数据库有 5 个表空间：一个目录表空间、两个常规表空间、一个长表空间和一个系统临时表空间。没有创建用户临时表空间。另外有 8 个容器。</p><p>在这个方案中，缓冲池可能如下分配：<br>将 BP1（4K）分配给 SYSCATSPACE 和 USERSPACE2<br>将 BP2（8K）分配给 USERSPACE1<br>将 BP3（32K）分配给 LARGESPACE 和 SYSTEMP1</p><h2 id="第-2-节：性能含义"><a href="#第-2-节：性能含义" class="headerlink" title="第 2 节：性能含义"></a>第 2 节：性能含义</h2><p>一般而言，在物理设备上设计如何放置表空间和容器时，目标是使 I/O 并行性和缓冲区利用率达到最优。要实现这个目标，应当全面了解数据库设计和应用程序。只有这样您才能确定类似于下面这样的问题：将两张表分隔到不同的设备会不会产生并行 I/O，或者，是否应当在单独的表空间中创建表以便可以对它进行完全缓冲。</p><p>设计新数据库的物理布局应当从设计表空间的组织开始：</p><ol><li>第一步是确定表设计所给出的约束。这些可能会导致必须使用多个常规表空间。</li><li>第二步是考虑如果让表空间中的表具有不同的设置，是否有可能显著提高性能。</li><li>一旦作出了一个试验性的表空间设计，那么就必须考虑缓冲池的利用率。这可能会使前面的表空间设计产生一些变化。</li><li>最后，必须给表空间分配容器。</li></ol><p>这个是一个有反复的过程，应该通过压力测试和基准测试验证该设计。很显然，实现最佳的设计可能需要花费大量精力，并且仅当数据库性能必须可能是最佳时才能证明设计是最佳的。通常：</p><ul><li>从最简单的可行设计入手。</li><li>只有根据测试证明有充分的性能理由时才增加复杂性。</li></ul><p>通常，为了降低管理和保持一个较为简单的数据库设计的复杂性，稍微降低一点性能是值得的。DB2 具有一种非常成熟的资源管理逻辑，往往不用进行精心的设计就能产生非常好的性能。</p><h3 id="表空间组织"><a href="#表空间组织" class="headerlink" title="表空间组织"></a>表空间组织</h3><p>通常应该将目录表空间和系统临时表空间作为 SMS 分配。没有必要拥有多个具有相同页大小的临时表空间，通常只需一个具有最大页大小的临时表空间就够了。</p><p>突出的问题在于是否要将用户数据分割到多个表空间中。一个考虑因素是页的利用率。不能将行分割到不同的页，因此具有长行的表需要有合适的页大小。但是，一个页上的行不能超过 255 个，因此具有较短行的表不能利用整个页。例如，在页大小为 32K 的表空间中放置行长度为 12 字节的表，它大约只能利用每个页的 10%（即，（255 行 * 12 字节 + 91 字节的开销） / 32k 页大小 = ~10%）。</p><p>如果表很大，这只是一个考虑因素，因此浪费的空间就非常大。它还会使 I/O 和缓存的效率降低，因为每个页的实际有用内容很少。如果可以将表放到具有较小页的表空间中，以及可以充分利用较大的页大小，那么最常用的访问方法将确定哪一个更好。如果通常是顺序访问大量行（该表可能进行了群集），那么比较大的页大小会比较有效。如果随机访问行，那么较小的页大小可以允许 DB2 更好地利用缓冲区，因为同样的存储区域可以容纳更多页。</p><p>一旦根据页大小对表进行了分组，那么访问频率和类型将确定把数据进一步分组到独立的表空间中是否有意义。每张表根据自己被最频繁访问的方式，可以具有一组最有效的表空间设置：PAGESIZE、EXTENTSIZE 和 PREFETCHSIZE。上面已介绍了 PAGESIZE。EXTENTSIZE 是在将数据写入到下一个容器之前写入到当前容器中的数据的页数（如果表空间中存在多个容器的话）。</p><p>PREFETCHSIZE 指定在执行数据预取时将从表空间读取的页数。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，会使用预取操作（通常是大型表扫描）。比较好的做法是将 PREFETCHSIZE 值显式地设置成表空间的 EXTENTSIZE 值与表空间容器数的乘积的倍数。例如，如果 EXTENTSIZE 是 32，并且表空间中有 4 个容器，那么理想的 PREFETCHSIZE 应当是 128、256 等等。如果一个或多个频繁使用的表需要的这组参数的值不同于那些最适用于表空间其它表的性能的参数值，那么将这些表放入单独的表空间可能会提高整体性能。</p><p>如果预取操作是表空间中的重要因素，那么请考虑留出一部分缓冲区用于基于块的 I/O。块大小应当等于 PREFETCHSIZE。</p><h3 id="缓冲池的利用率"><a href="#缓冲池的利用率" class="headerlink" title="缓冲池的利用率"></a>缓冲池的利用率</h3><p>使用多个用户表空间的最重要原因是管理缓冲区的利用率。一个表空间只能与一个缓冲池相关联，而一个缓冲池可用于多个表空间。</p><p>缓冲池调优的目标是帮助 DB2 尽可能好地利用可用于缓冲区的内存。整个缓冲区大小对 DB2 性能有巨大影响，这是因为大量的页可以显著地减少 I/O 这一最耗时的操作。但是，如果总的缓冲区大小太大，并且没有足够的存储器可用来分配给它们，那么将为每种页大小分配最少的缓冲池，性能就会急剧下降。要计算最大的缓冲区大小，DB2、操作系统以及其它任何应用程序都必须考虑其它所有存储器的利用率。一旦确定了总的可用大小，就可以将这个区域划分成不同的缓冲池以提高利用率。如果有一些具有不同页大小的表空间，那么每种页大小必须至少有一个缓冲池。</p><p>拥有多个缓冲池可以将数据保存在缓冲区中。例如，让我们假设一个数据库有许多频繁使用的小型表，这些表通常全部都位于缓冲区中，因此访问起来就非常快。现在让我们假设有一个针对非常大的表运行的查询，它使用同一个缓冲池并且需要读取比总的缓存区大小还多的页。当查询运行时，来自这些频繁使用的小型表的页将会丢失，这使得再次需要这些数据时就必须重新读取它们。</p><p>如果小型表拥有自己的缓冲池，那么它们就必须拥有自己的表空间，因此大型查询就不能覆盖它们的页。这有可能产生更好的整体系统性能，虽然这会对大型查询造成一些小的负面影响。经常性地进行调优是为了实现整体的性能提高而在不同的系统功能之间做出的权衡。区分功能的优先级并记住总吞吐量和使用情况，同时对系统性能进行调整，这是非常重要的。</p><p>V8 所引入的新功能能够在不关闭数据库的情况下更改缓冲池大小。带有 IMMEDIATE 选项的 altER BUFFERPOOL 语句会立刻生效，只要数据库共享的内存中有足够的保留空间可以分配给新空间。可以使用这个功能，根据使用过程中的周期变化（例如从白天的交互式使用转换到夜间的批处理工作）来调优数据库性能。</p><h3 id="物理存储器组织"><a href="#物理存储器组织" class="headerlink" title="物理存储器组织"></a>物理存储器组织</h3><p>一旦将表分布到多个表空间中，就必须决定它们的物理存储器。表空间可以存储在多个容器中，并且它可以是 SMS 或 DMS。SMS 更容易管理，对于包含许多不同的小型表的表空间（例如目录表空间），尤其是那些包含 LOB 的表的表空间而言，SMS 可能是个不错的选择。为了降低每次一页地扩展 SMS 容器的开销，应当运行 <strong>db2empfa</strong>命令。这会将数据库配置参数 MULTIPAGE_ALLOC 的值设置成 YES。</p><p>DMS 通常有更好的性能，并且它提供了分别地存储索引和 LOB 数据的灵活性。通常应当将一个表空间的多个容器分开存放在单独的物理卷上。这可以提高某些 I/O 的并行性。当有多个用户表空间和多个设备时，应当考虑应用程序逻辑，这样就可以尽可能平均地在这些设备上分配工作负载。</p><p>RAID 设备有它们自己的特殊考虑。EXTENTSIZE 应该等于 RAID 条带大小或者是它的倍数。PREFETCHSIZE 应该等于 RAID 条带大小乘以 RAID 并行设备数（或者等于该乘积的倍数），这个值应该是 EXTENTSIZE 的倍数。DB2 提供了自己的注册表变量，允许您增强您的特定环境。通过执行下面这个命令，可以在一个容器中启用 I/O 并行性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2set DB2_PARALLEL_IO&#x3D;*</span><br></pre></td></tr></table></figure><p>另一个注册表变量 DB2_STRIPED_CONTAINERS=ON 可以将容器标记大小从一个页更改成整个扩展块，因此就能使表空间扩展块和 RAID 条带一致。</p><p>至于性能评估的其它方面，要知道某个更改是否有益，唯一稳妥的方法就是进行基准测试。如果物理组织发生了更改，那么执行该任务稍微有些复杂，这是因为这时要更改表空间必须要付出相当大的精力。最实用的方法就是减少设计阶段中的案例数，这样的话稍后需要进行基准测试的案例就比较少了。只有在性能极其重要并且不同的设计之间有可能存在显著的性能差别时，才值得花时间和精力进行严格的基准测试来比较设计。应当把重点放在缓冲池上，确保没有将它们分配到虚拟内存中，并确保以最有效的方式利用它们。</p><h3 id="有关移动数据库的考虑事项"><a href="#有关移动数据库的考虑事项" class="headerlink" title="有关移动数据库的考虑事项"></a>有关移动数据库的考虑事项</h3><p>在将数据库移到另一个系统之前，始终应该重新评估它的调优参数和物理组织，即便这些系统是同一种平台也应如此。在实际情况中，DBA 将经过良好调优的数据库从具有 1 GB 内存的 Windows 服务器复制到具有 256 MB 内存的膝上型计算机中。在服务器上进行连接所花的时间小于一秒，而在膝上型计算机中却要用掉 45 分钟。通过减少缓冲池大小和其它内存参数就能解决这个问题。</p><p>如果平台不一样，那么这个问题就变得更难了。即使是在 UNIX 和 Windows 之间进行移动，在一个系统上已是最佳性能，在另一个系统上却未必如此。如果复制数据库是为了进行生产，那么应当重复调优过程。如果必须将数据库移到 zSeries™，那么这里讨论的某些内容则不适用，而应该参考有关的手册和红皮书。在 iSeries 系统上，物理设置和调优是在数据库环境之外一起完成的，应当参考 iSeries™ 系统管理手册。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们在本文中介绍了许多内容，但是您应当了解的有关数据库设计和性能的知识决不仅限于此。我们着重讨论了数据库设计的两个比较大的问题，而没有深入研究查询优化和应用程序考虑事项的细节。设计数据库是第一位的，因为这是其它所有事情的前提，因此您的初始规划应该非常全面。为了方便您的学习，我们在下面提供了其它联机参考资料，这样您就可以继续学习有关本主题的内容。</p><p>本文转载自IBM官方网站，原文地址：<a href="https://www.ibm.com/developerworks/cn/data/library/techarticles/0212wieser/0212wieser.html">https://www.ibm.com/developerworks/cn/data/library/techarticles/0212wieser/0212wieser.html</a></p>]]></content>
    
    
    <summary type="html">【DB2】DB2基础_表空间和缓冲池</summary>
    
    
    
    <category term="DB2" scheme="https://born2do.github.io/categories/DB2/"/>
    
    
    <category term="表空间" scheme="https://born2do.github.io/tags/%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    
    <category term="缓冲池" scheme="https://born2do.github.io/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【VUE+SpringBoot】前台更改数据后，报错，但是数据库明明更改了</title>
    <link href="https://born2do.github.io/2021/05/11/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%98%8E%E6%9B%B4%E6%94%B9%E4%BA%86/"/>
    <id>https://born2do.github.io/2021/05/11/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%98%8E%E6%9B%B4%E6%94%B9%E4%BA%86/</id>
    <published>2021-05-11T13:30:30.000Z</published>
    <updated>2021-05-11T13:30:56.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前台操作，更改了数据，显示失败。但是数据库中数据的的确确更改掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">editUserInfo() &#123;</span><br><span class="line">    this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if(!valid) &#123; return; &#125;</span><br><span class="line">        const &#123;data: res&#125; &#x3D; this.$http.put(&quot;editUser&quot;, this.editForm);</span><br><span class="line">        if(res&#x3D;&#x3D;&quot;success&quot;) &#123;</span><br><span class="line">            this.$message.success(&quot;操作成功&quot;);</span><br><span class="line">            this.editDialogVisible &#x3D; false;</span><br><span class="line">            this.getUserList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message.error(&quot;操作失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>数据库中数据被更改掉了，说明前端的put请求是成功的，后台也正常处理掉了。</li><li>在前端控制台打印日志，查看访问后台后返回的数据是否正常。然而，控制台报错undefined 。<br>仔细查看前端的数据处理，发现缺少await关键字。这也是为什么报错“undefined ”的原因了，根本就没有对后台返回的数据进行接收处理。<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2>添加上await关键字即可。最终代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">editUserInfo() &#123;</span><br><span class="line">    this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if(!valid) &#123; return; &#125;</span><br><span class="line">        const &#123;data: res&#125; &#x3D; await this.$http.put(&quot;editUser&quot;, this.editForm);</span><br><span class="line">        if(res&#x3D;&#x3D;&quot;success&quot;) &#123;</span><br><span class="line">            this.$message.success(&quot;操作成功&quot;);</span><br><span class="line">            this.editDialogVisible &#x3D; false;</span><br><span class="line">            this.getUserList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message.error(&quot;操作失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2>async + await 组合，用于异步处理后台返回的数据。</li></ul>]]></content>
    
    
    <summary type="html">【VUE+SpringBoot】前台更改数据后，报错，但是数据库明明更改了</summary>
    
    
    
    <category term="VUE+SpringBoot" scheme="https://born2do.github.io/categories/VUE-SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【VUE+SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致</title>
    <link href="https://born2do.github.io/2021/05/10/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>https://born2do.github.io/2021/05/10/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2021-05-10T13:04:07.000Z</published>
    <updated>2021-05-10T13:04:36.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>后台从数据库中查询到的数据，转换成JSON字符串传到前端后，缺少部分字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUpdateUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUpdateUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    User user = userDao.getUpdateUser(id);</span><br><span class="line">    String string = JSON.toJSONString(user);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async showEditDialog(id) &#123;</span><br><span class="line">    const &#123;data: res&#125; = await this.$http.get(&quot;/getUpdateUser?id=&quot;+id);</span><br><span class="line">    this.editForm = res;// 查询用户信息，回填用户编辑表单</span><br><span class="line">    this.editDialogVisible = true;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>打印出后台从数据库中查询出的数据，发现字段是完整的，并无缺失。</li><li>打印JSON字符串，发现缺少字段，定位到问题入口。</li><li>查看JSON.toJSONString()方法后，并未发现异常。</li><li>将该模块的所有文件重新审阅一遍后发现，实体类User.java中有个布尔类型的成员变量的get方法不对头，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> state; <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并不是我们平常的get方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这就导致JSON将User对象转换成json字符串时，无法通过反射获取到其state字段，最终给前端的json数据也就没有该字段。<h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1>重写实体类User的get、set方法并检验，确保不再出错。重启后，测试显示正常。<h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><blockquote><p>对于布尔类型的成员变量，在使用IDEA生成get方法后，需要进行修改。否则，将无法通过一般的反射获取其全部成员变量，项目容易出问题。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">【VUE+SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致</summary>
    
    
    
    <category term="VUE+SpringBoot" scheme="https://born2do.github.io/categories/VUE-SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】Project &#39;org.springframework.boot:spring-boot-starter-parent:2.4.5&#39; not found</title>
    <link href="https://born2do.github.io/2021/05/09/%E3%80%90SpringBoot%E3%80%91Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/"/>
    <id>https://born2do.github.io/2021/05/09/%E3%80%90SpringBoot%E3%80%91Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/</id>
    <published>2021-05-09T15:21:43.000Z</published>
    <updated>2021-05-09T15:22:10.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>新建SpringBoot项目后，项目正常运行，但是pom.xml文件提示“Project ‘org.springframework.boot:spring-boot-starter-parent:2.4.5’ not found” 。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>出现这种问题，是由于在当前的仓库中找不到指定的版本Jar包。<br>通常我们在本地会将远程仓库配置成阿里云镜像，如果pom.xml文件中指定的版本过高，可能阿里云镜像仓库中会没有，也就导致了该错误。降低版本即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【SpringBoot】Project &#39;org.springframework.boot:spring-boot-starter-parent:2.4.5&#39; not found</summary>
    
    
    
    <category term="SpringBoot" scheme="https://born2do.github.io/categories/SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【前后端分离】跨域问题</title>
    <link href="https://born2do.github.io/2021/05/08/%E3%80%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://born2do.github.io/2021/05/08/%E3%80%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-08T13:07:55.000Z</published>
    <updated>2021-05-08T13:08:28.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>VUE前端项目和SpringBoot后端项目起起来后，发现前端无法访问后台地址。报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:9000&#x2F;test&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8080&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">&#x2F;&#x2F; 添加全局样式</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;css&#x2F;global.css&#39;</span><br><span class="line">&#x2F;&#x2F; 引入iconfont</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;font&#x2F;iconfont.css&#39;</span><br><span class="line">&#x2F;&#x2F; 导入axios</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">&#x2F;&#x2F; 挂载axios</span><br><span class="line">Vue.prototype.$http &#x3D; axios</span><br><span class="line">&#x2F;&#x2F; 设置访问路径(后端地址)</span><br><span class="line">axios.defaults.baseURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;login_container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;login_box&quot;&gt;</span><br><span class="line">            &lt;!-- 头像 --&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;avatar_box&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;!-- 登陆表单 --&gt;</span><br><span class="line">            &lt;el-form ref&#x3D;&quot;loginFormRef&quot; :rules&#x3D;&quot;loginRules&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;login_form&quot; label-width&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">                    &lt;el-input  v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-usercenter&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">                    &lt;el-input v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-unlock&quot; type&#x3D;&quot;password&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item class&#x3D;&quot;btns&quot;&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;login()&quot;&gt;提交&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;resetLoginForm()&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;el-form&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x2F;&#x2F; 表单数据</span><br><span class="line">            loginForm: &#123;</span><br><span class="line">                username: &quot;admin&quot;,</span><br><span class="line">                password: &quot;123456&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F; 表单校验</span><br><span class="line">            loginRules: &#123;</span><br><span class="line">                username: [</span><br><span class="line">                    &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">                    &#123; min: 5, max: 12, message: &#39;长度在 5 到 12 个字符&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">                ],</span><br><span class="line">                password: [</span><br><span class="line">                    &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">                    &#123; min: 6, max: 10, message: &#39;长度在 6 到 10 个字符&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        resetLoginForm() &#123;</span><br><span class="line">            this.$refs.loginFormRef.resetFields();</span><br><span class="line">        &#125;,</span><br><span class="line">        login() &#123;</span><br><span class="line">            this.$refs.loginFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">                if(!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                const &#123;data: res&#125; &#x3D; await this.$http.post(&quot;test&quot;);</span><br><span class="line">                console.log(res);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.login_container &#123;</span><br><span class="line">    background-color: #2b4b6b;</span><br><span class="line">    height: 100%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.login_box &#123;</span><br><span class="line">    width: 450px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">    .avatar_box &#123;</span><br><span class="line">        width: 130px;</span><br><span class="line">        height: 130px;</span><br><span class="line">        border: 1px solid #eee;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        box-shadow: 0 0 10px #ddd;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">        background-color: #eee;</span><br><span class="line">        img &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            border-radius: 50%;</span><br><span class="line">            background-color: #eee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.btns &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line">.login_form &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0%;</span><br><span class="line">    width: 100%;</span><br><span class="line">    padding: 0 10px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>后端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sport.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  全局配置类--配置跨域请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Webconfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.域访问路径</span></span><br><span class="line"><span class="comment">     * 2.请求来源</span></span><br><span class="line"><span class="comment">     * 3.方法</span></span><br><span class="line"><span class="comment">     * 4.允许携带token等信息</span></span><br><span class="line"><span class="comment">     * 5.设置生命周期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:8080/&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTION&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sport.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;测试成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原因查找"><a href="#原因查找" class="headerlink" title="原因查找"></a>原因查找</h2><p>根据报错，很明显是跨域问题。那么到底在哪里出错了？前端还是后端？</p><ul><li>一开始以为是浏览器的问题，从edge转到谷歌浏览器后，问题仍然存在。</li><li>查看了前端的axios挂载以及请求的情况，请求路径没有问题。</li><li>那么就是后端的问题了。<br>我尝试着按照网上的博客来修改Webconfig .java文件，但是没有用（自己太垃圾，没改对而已）。<br>然后，我尝试着将跨域的注解直接放到方法上面：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:8080&quot;, maxAge = 3600)</span></span><br></pre></td></tr></table></figure>重启后，项目竟然可以正常访问了！！！<br>这个时候，我再回看之前的跨域配置文件Webconfig .java，发现竟然是url在最后多出一条斜杠的原因。<br>需要将<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost:8080/&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br></pre></td></tr></table></figure>修改为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost:8080&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">【前后端分离】跨域问题</summary>
    
    
    
    <category term="前后端分离" scheme="https://born2do.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
    <category term="跨域" scheme="https://born2do.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>【vue】在lang=less的style中编写样式报错</title>
    <link href="https://born2do.github.io/2021/05/08/%E3%80%90vue%E3%80%91%E5%9C%A8lang-less%E7%9A%84style%E4%B8%AD%E7%BC%96%E5%86%99%E6%A0%B7%E5%BC%8F%E6%8A%A5%E9%94%99/"/>
    <id>https://born2do.github.io/2021/05/08/%E3%80%90vue%E3%80%91%E5%9C%A8lang-less%E7%9A%84style%E4%B8%AD%E7%BC%96%E5%86%99%E6%A0%B7%E5%BC%8F%E6%8A%A5%E9%94%99/</id>
    <published>2021-05-07T16:04:40.000Z</published>
    <updated>2021-05-07T16:05:06.270Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在学习vue，照着B站上的一个项目直接进行实战学习。<br>链接：<a href="https://www.bilibili.com/video/BV1q5411s7wH?t=93">https://www.bilibili.com/video/BV1q5411s7wH?t=93</a><br>前端项目建好，创建登录页面，更改样式的时候报错了。<br>报错截图：<br><img src="https://i.loli.net/2021/05/07/qjxiFgsPBSUI9rH.png" alt="20210310224437734.png"><br>源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;login_container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;login_box&quot;&gt;</span><br><span class="line">            &lt;!-- 头像 --&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;avatar_box&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;!-- 登陆表单 --&gt;</span><br><span class="line">            &lt;el-form ref&#x3D;&quot;loginFormRef&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;login_form&quot; label-width&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;el-form-item&gt;</span><br><span class="line">                    &lt;el-input  v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-usercenter&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item&gt;</span><br><span class="line">                    &lt;el-input v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-unlock&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item class&#x3D;&quot;btns&quot;&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot;&gt;提交&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;info&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;el-form&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            loginForm: &#123;</span><br><span class="line">                username: &quot;username&quot;,</span><br><span class="line">                password: &quot;password&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.login_container &#123;</span><br><span class="line">    background-color: #2b4b6b;</span><br><span class="line">    height: 100%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.login_box &#123;</span><br><span class="line">    width: 450px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据报错信息，很快便定位到是版本问题。<br>在网上查找了相关的博客，大多表示是由于less-loader版本过高。<br>我尝试着将less-loader的版本降低，但是仍然报错。<br>然后，我按照视频中up主使用的版本，将less以及less-loader卸载后重新安装低版本，项目正常编译。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall less-loader</span><br><span class="line">npm uninstall less</span><br><span class="line"></span><br><span class="line">npm install less@3.11.1  --save  </span><br><span class="line">npm install less-loader@6.1.0 --save</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【vue】在lang=less的style中编写样式报错</summary>
    
    
    
    <category term="vue" scheme="https://born2do.github.io/categories/vue/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【DB2】DB2基础_表分区</title>
    <link href="https://born2do.github.io/2021/05/06/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%88%86%E5%8C%BA/"/>
    <id>https://born2do.github.io/2021/05/06/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%88%86%E5%8C%BA/</id>
    <published>2021-05-06T12:49:05.000Z</published>
    <updated>2021-05-06T12:50:02.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p><code>CREATE TABLE</code> 语句的 PARTITION BY 子句指定了表数据的分区。该定义中使用的列被称为表分区键列。</p><p>关于该特性的详细说明可参见 “<a href="http://www.ibm.com/developerworks/db2/library/techarticle/dm-0605ahuja2/">Table partitioning in DB2 9</a>”（developerWorks，2006 年 5 月）。</p><p>表分区特性提供以下收益：</p><ul><li>表数据可轻易实现转入和转出</li><li>对大型表的管理更加轻松</li><li>灵活的索引放置</li><li>更高的业务智能样式查询的性能</li></ul><h3 id="关于本教程"><a href="#关于本教程" class="headerlink" title="关于本教程"></a>关于本教程</h3><p>本教程中的练习将引领您使用表分区特性，并演示了表数据的转入转出、更轻松的大型表管理、灵活的索引放置和对业务智能样式查询的性能改善。</p><p>这些练习旨在演示上述各领域内的一个或多个任务。</p><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>本教程的目标是在以下方面探究 DB2 9 范围分区的特性和优点：</p><ul><li>创建范围分区表</li><li>分区的转入和转出</li><li>分区表的管理</li><li>索引管理和放置</li></ul><h3 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h3><p>本教程的目标读者是那些技能和经验刚刚迈入中级水平的 DB2 专业人员。要学习本教程，您应该熟悉 DB2 命令行、DB2 管理工具的使用，还应具备 SQL 实践经验。</p><h3 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h3><p>要运行本教程的示例，需要具备以下条件：</p><ul><li><a href="http://www-306.ibm.com/software/data/db2/express/download.html">DB2 9 Data Server</a></li><li>Microsoft® Windows® 2000 或更高版本，以及一个具有管理员权限的帐户，或具有根访问权限的 Linux®（<a href="http://www-306.ibm.com/software/data/db2/linux/validate/">验证版</a>）。</li><li>确保系统中的 Java Runtime Environment 是 1.4.2 或更高版本。</li><li>参考 DB2 9 <a href="http://www-306.ibm.com/software/data/db2/9/sysreqs.html">系统需求页面</a> 确保您的硬件符合要求。</li></ul><p>可通过上面的链接获取 DB2 9 Express C。关于安装 DB2 的步骤请参考 “<a href="http://www.ibm.com/developerworks/cn/views/db2/tutorials.jsp?cv_doc_id=110099">DB2 XML 评估指南</a>”（developerWorks，2006 年 6 月）。若未改动 DB2 的配置，安装后 DB2 将自动启动。</p><p>使用 partition.zip 文件提供的示例脚本和数据演示本教程的概念。将其内容解压缩到 scripts 子目录（C:\scripts 或 home/userid/scripts）。本教程中将该目录简称为 stmm_scripts。教程假设您使用的是 DB2 默认安装目录，并且所有的 DB2 练习都通过一个数据库管理员 ID 执行。</p><h2 id="创建分区表"><a href="#创建分区表" class="headerlink" title="创建分区表"></a>创建分区表</h2><p>这个实验将探讨创建分区表、将数据载入分区表以及使用 <code>describe</code> 命令来说明表范围的方法：</p><ol><li>您将登录并为所有的练习设置基本环境。</li><li>您将创建不同格式的分区表并加载数据。</li><li>您将使用 DB2 命令和 SQL 查看结果。</li><li>将对 DB2 9 表范围分区进行概述。</li></ol><h3 id="登录和基本指令"><a href="#登录和基本指令" class="headerlink" title="登录和基本指令"></a>登录和基本指令</h3><ol><li><p>登录到您的机器，如图 1 所示，使用 db2inst1。</p><p>图 1. 基本设置</p><p><img src="https://i.loli.net/2021/05/06/b6xAGm7Szhlr3n5.jpg" alt="s5.jpg"></p></li><li><p>打开终端窗口（Linux）或 DB2 命令窗口（windows）。</p></li><li><p>切换到 scripts 子目录。</p><p>清单 1. 切换目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /scripts or </span><br><span class="line">cd c:\scripts</span><br></pre></td></tr></table></figure></li><li><p>使用<code>db2start</code>命令启动 DB2，并连接到 SAMPLE 数据库。</p><p>清单 2. StartDB2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db2start</span><br><span class="line">db2 connect to SAMPLE</span><br></pre></td></tr></table></figure></li></ol><h3 id="创建基本分区表"><a href="#创建基本分区表" class="headerlink" title="创建基本分区表"></a>创建基本分区表</h3><p>这一节将介绍分区表的基本创建和加载。您将创建不同格式的表、验证创建结果、加载数据并对表进行查询。</p><ol><li><p>使用如下的数据定义语言（DDL）创建具有四个范围的 LINEITEM 表：</p><p>清单 3. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LINEITEM </span><br><span class="line">( l_orderkey         <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  l_partkey          <span class="type">INTEGER</span>,</span><br><span class="line">  l_suppkey          <span class="type">INTEGER</span>,</span><br><span class="line">  l_linenumber       <span class="type">INTEGER</span>,</span><br><span class="line">  l_quantity         <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_extendedprice    <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_discount         <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_tax              <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_returnflag       <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_linestatus       <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_shipdate         <span class="type">DATE</span>,</span><br><span class="line">  l_commitdate       <span class="type">DATE</span>,</span><br><span class="line">  l_receiptdate      <span class="type">DATE</span>,</span><br><span class="line">  l_shipinstruct     <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line">  l_shipmode         <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">  l_comment          <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line">( STARTING <span class="string">&#x27;1/1/1992&#x27;</span> ENDING <span class="string">&#x27;30/06/1992&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/7/1992&#x27;</span> ENDING <span class="string">&#x27;31/12/1992&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/1/1993&#x27;</span> ENDING <span class="string">&#x27;30/6/1993&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/7/1993&#x27;</span> ENDING <span class="string">&#x27;31/12/1993&#x27;</span>)</span><br></pre></td></tr></table></figure><p>创建该表的 SQL 语句位于 EX1-6.sql 文件中，可使用如下命令运行该文件：</p><p>清单 4. 运行 EX1-6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-6.sql</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令说明为 LINEITEM 表创建的分区的范围：</p><p>清单 5. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 <span class="keyword">describe</span> data partitions <span class="keyword">for</span> <span class="keyword">table</span> LINEITEM</span><br></pre></td></tr></table></figure><p>图 2. 说明为 LINEITEM 表创建的分区范围</p><p><img src="https://i.loli.net/2021/05/06/9AlKZx1HbseqzN4.jpg" alt="s6.jpg"></p><p>注意：创建了四个数据分区。其中的范围包括边界值。</p></li><li><p>将数据导入到 LINEITEM 表。该操作的导入命令位于 EX1-8.sql 文件中，可使用如下命令运行：</p><p>清单 6. 带有拒绝的加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-8.sql</span><br></pre></td></tr></table></figure><p>图 3. 将数据导入到 LINEITEM 表</p><p><img src="https://i.loli.net/2021/05/06/c2wuhXxoFCjAPq5.jpg" alt="s7.jpg"></p><p>注意：导入时拒绝了 729 行数据，这是因为它们不具有位于当前 LINEITEM 表的数据分区定义范围内的 l_shipdate。</p></li><li><p>标量函数可用于显示行所属的数据分区号（datapartitionnum）。执行以下示例 SQL 查看标量函数的输出：</p><p>清单 7. 查询 - 匹配日期的分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select datapartitionnum(l_shipdate) as PartitionId, l_shipdate from lineitem </span><br><span class="line">        where l_shipdate between &#x27;01/06/1992&#x27; and &#x27;31/07/1992&#x27;</span><br><span class="line">        order by l_shipdate&quot;</span><br></pre></td></tr></table></figure><p>图 4. 标量函数的输出</p><p><img src="https://i.loli.net/2021/05/06/wmBUzikZLpCXgHn.jpg" alt="s8.jpg"></p><p>注意：标量函数（datapartitionnum）返回的值和<code>describe</code> 命令返回的是同一个 PartitionId。该语句的子句间使用的谓词范围超出了 PartitionId 0 和 PartitionId 1 的边界</p></li></ol><h3 id="具有全部范围的分区表"><a href="#具有全部范围的分区表" class="headerlink" title="具有全部范围的分区表"></a>具有全部范围的分区表</h3><ol><li><p>创建具有两个额外数据分区的新 LINEITEM 表，其中一个分区用来捕获低于当前范围的值，另一个分区用来捕获高于当前范围的值。首先使用下面的命令删除现有的 LINEITEM 分区表：</p><p>清单 8. 删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 drop TABLE LINEITEM</span><br></pre></td></tr></table></figure><p>然后使用如下 DDL 创建 LINEITEM 表的新版本：</p><p>清单 9. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LINEITEM </span><br><span class="line">( l_orderkey         <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  l_partkey          <span class="type">INTEGER</span>,</span><br><span class="line">  l_suppkey          <span class="type">INTEGER</span>,</span><br><span class="line">  l_linenumber       <span class="type">INTEGER</span>,</span><br><span class="line">  l_quantity         <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_extendedprice    <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_discount         <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_tax              <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_returnflag       <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_linestatus       <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_shipdate         <span class="type">DATE</span>,</span><br><span class="line">  l_commitdate       <span class="type">DATE</span>,</span><br><span class="line">  l_receiptdate      <span class="type">DATE</span>,</span><br><span class="line">  l_shipinstruct     <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line">  l_shipmode         <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">  l_comment          <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line">( STARTING MINVALUE,</span><br><span class="line">  STARTING <span class="string">&#x27;1/1/1992&#x27;</span> ENDING <span class="string">&#x27;30/06/1992&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/7/1992&#x27;</span> ENDING <span class="string">&#x27;31/12/1992&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/1/1993&#x27;</span> ENDING <span class="string">&#x27;30/6/1993&#x27;</span>,</span><br><span class="line">  STARTING <span class="string">&#x27;1/7/1993&#x27;</span> ENDING <span class="string">&#x27;31/12/1993&#x27;</span>,</span><br><span class="line">  ENDING MAXVALUE)</span><br></pre></td></tr></table></figure><p>创建该表的 SQL 位于 EX1-10.sql 文件中，可使用下列命令运行：</p><p>清单 10. 运行 EX1-10</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-10.sql</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令说明为 LINEITEM 表创建的分区范围。</p><p>清单 11. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM</span><br></pre></td></tr></table></figure><p>图 5. 说明为 LINEITEM 表创建的分区范围</p><p><img src="https://i.loli.net/2021/05/06/3jhaoKMdQb5tUkP.jpg" alt="s10a.jpg"></p><p>注意：新的 MINVALUE 范围具有一个最高值，该值和下一个数据分区开始部分的值相等，但它并不包含该值。MAXVALUE 范围具有一个最低值，该值和前一个范围结束部分的值相等，但它不包含该值。这将创建一个无间隙的连续范围。</p></li><li><p>将数据导入到 LINEITEM 表中。该操作的导入命令位于 EX1-8.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 12. 全面加载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-8.sql</span><br></pre></td></tr></table></figure><p>图 6. 将数据导入到 LINEITEM 表中</p><p><img src="https://i.loli.net/2021/05/06/SuLlYUCAW6XdHIz.jpg" alt="s10b.jpg"></p></li></ol><h3 id="具有生成范围的分区表"><a href="#具有生成范围的分区表" class="headerlink" title="具有生成范围的分区表"></a>具有生成范围的分区表</h3><ol><li><p>创建一个新 LINEITEM 表，它具有从 1992 年 1 月 1 日到 1998 年 12 月 31 日按月划分的数据分区生成范围。同样，添加 minvalue 和 maxvalue 范围来存放具有超过此范围的 l_shipdate 的值的行。首先使用以下命令删除现有的 LINEITEM 分区表：</p><p>清单 13. 删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 drop TABLE LINEITEM</span><br></pre></td></tr></table></figure><p>然后使用如下 DDL 创建 LINEITEM 表的新版本：</p><p>清单 14. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> lineitem</span><br><span class="line">(l_orderkey            <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  l_cpartkey      <span class="type">INTEGER</span>,</span><br><span class="line">  l_suppkey       <span class="type">INTEGER</span>,</span><br><span class="line">  l_linenumber    <span class="type">INTEGER</span>,</span><br><span class="line">  l_quantity      <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_extendedprice <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_discount      <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_tax           <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_returnflag    <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_linestatus    <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_shipdate      <span class="type">DATE</span>,</span><br><span class="line">  l_commitdate    <span class="type">DATE</span>,</span><br><span class="line">  l_receiptdate   <span class="type">DATE</span>,</span><br><span class="line">  l_shipinstruct  <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line">  l_shipmode      <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">  l_comment       <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line"> (STARTING MINVALUE,</span><br><span class="line"> STARTING <span class="string">&#x27;1/1/1992&#x27;</span> ENDING <span class="string">&#x27;31/12/1998&#x27;</span> </span><br><span class="line">                <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">MONTH</span>,</span><br><span class="line"> ENDING MAXVALUE);</span><br></pre></td></tr></table></figure><p>创建该表的 SQL 位于 EX1-13.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 15. 运行 EX1-13</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-13.sql</span><br></pre></td></tr></table></figure></li><li><p>使用如下命令来说明为 LINEITEM 表创建的分区范围：</p><p>清单 16. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM</span><br></pre></td></tr></table></figure><p>图 7. 说明为 LINEITEM 表创建的分区范围</p><p><img src="https://i.loli.net/2021/05/06/fu8WxdRC3OJa6Dv.jpg" alt="s12a.jpg"></p><p>注意：创建了 86 个数据分区，但是没有包括这些范围的最高值，因为这些最高值将和之后的数据分区的最低值重叠。</p></li><li><p>将数据导入到 LINEITEM 表。此操作的导入命令位于 EX1-8.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 17. 加载并生成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-8.sql</span><br></pre></td></tr></table></figure><p>图 8. 将数据导入到 LINEITEM 表</p><p><img src="https://i.loli.net/2021/05/06/Oo8uCWkp9YvIh3l.jpg" alt="s12b.jpg"></p></li><li><p>使用下面的 SQL 来验证 LINEITEM 表每一个数据分区的行数：</p><p>清单 18. 查询数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select year(l_shipdate) as year, month(l_shipdate) as month, </span><br><span class="line">count(*) as count from lineitem</span><br><span class="line">  group by year(l_shipdate), month(l_shipdate)</span><br><span class="line">  order by 1, 2&quot;</span><br></pre></td></tr></table></figure><p>使用以下的 SQL 语句验证 LINEITEM 表的每一个数据分区的行数：</p><p>清单 19. 查询数据脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX1-16.sql</span><br></pre></td></tr></table></figure><p>图 9. 检验行数</p><p><img src="https://i.loli.net/2021/05/06/gshciMUwj7REH9u.jpg" alt="s13.jpg"></p><p>注意：执行加载操作后，86 个范围中有 82 个范围包含一个或多个行。</p></li></ol><h2 id="放置分区表"><a href="#放置分区表" class="headerlink" title="放置分区表"></a>放置分区表</h2><p>该实验探讨放置分区表以及使用 <code>describe</code> 命令说明表内的范围和放置情况的方法：</p><ol><li>您将为数据放置练习创建新的表空间。</li><li>你将创建不同格式的分区表。</li><li>您将使用 db2 命令和 SQL 查看结果。</li></ol><h3 id="基本环境设置"><a href="#基本环境设置" class="headerlink" title="基本环境设置"></a>基本环境设置</h3><ol><li><p>使用<code>describe data partitions</code>命令以及<code>show detail</code>方法来显示表空间的分区放置。</p><p>清单 20. 创建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 10. 表空间的分区放置</p><p><img src="https://i.loli.net/2021/05/06/PBUhwQtWbaNemq9.jpg" alt="s14.jpg"></p><p>注意：TableSpID 列给出了包含分区的表空间的 ID 号。在本例中，TableSpID 是 ‘3’。</p></li><li><p>使用<code>list tablespaces</code>命令标识与 TableSpId 相关联的表空间。</p><p>清单 21. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 list tablespaces</span><br></pre></td></tr></table></figure><p>图 11. 标识表空间</p><p><img src="https://i.loli.net/2021/05/06/5W4zksUH8JCIvl9.jpg" alt="s15.jpg"></p><p>注意：相应值为 ‘2’ 的 TableSpID 是 USERSPACE1 或默认的表空间。</p></li><li><p>现在将创建五个表空间来说明不同的放置选项。使用如下命令：</p><p>清单 22. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db2 <span class="keyword">create</span> <span class="keyword">table</span>space dms_d1 managed <span class="keyword">by</span> database <span class="keyword">using</span> (file <span class="string">&#x27;c:\ts1&#x27;</span> <span class="number">10000</span>);</span><br><span class="line">db2 <span class="keyword">create</span> <span class="keyword">table</span>space dms_d2 managed <span class="keyword">by</span> database <span class="keyword">using</span> (file <span class="string">&#x27;c:\ts2&#x27;</span> <span class="number">10000</span>);</span><br><span class="line">db2 <span class="keyword">create</span> <span class="keyword">table</span>space dms_d3 managed <span class="keyword">by</span> database <span class="keyword">using</span> (file <span class="string">&#x27;c:\ts3&#x27;</span> <span class="number">10000</span>);</span><br><span class="line">db2 <span class="keyword">create</span> <span class="keyword">table</span>space dms_d4 managed <span class="keyword">by</span> database <span class="keyword">using</span> (file <span class="string">&#x27;c:\ts4&#x27;</span> <span class="number">10000</span>);</span><br><span class="line">db2 <span class="keyword">create</span> <span class="keyword">table</span>space dms_i1 managed <span class="keyword">by</span> database <span class="keyword">using</span> (file <span class="string">&#x27;c:\ts5&#x27;</span> <span class="number">10000</span>);</span><br></pre></td></tr></table></figure><p>创建该表空间的 SQL 位于 EX2-3.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 23. 查询数据脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX2-3.sql</span><br></pre></td></tr></table></figure></li><li><p>创建一个新的 LINEITEM 表，具有位于 dms_d1 和 dms_d2 表空间的生成分区集。首先，使用如下命令删除现有的 LINEITEM 分区表：</p><p>清单 24. 删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 drop TABLE LINEITEM</span><br></pre></td></tr></table></figure><p>然后，使用下面的 DDL 创建 LINEITEM 表的新版本：</p><p>清单 25. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LINEITEM</span><br><span class="line">(l_orderkey      <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> l_partkey       <span class="type">INTEGER</span>,</span><br><span class="line"> l_suppkey       <span class="type">INTEGER</span>,</span><br><span class="line"> l_linenumber    <span class="type">INTEGER</span>,</span><br><span class="line"> l_quantity      <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_extendedprice <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_discount      <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_tax           <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_returnflag    <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> l_linestatus    <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> l_shipdate      <span class="type">DATE</span>,</span><br><span class="line"> l_commitdate    <span class="type">DATE</span>,</span><br><span class="line"> l_receiptdate   <span class="type">DATE</span>,</span><br><span class="line"> l_shipinstruct  <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line"> l_shipmode      <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"> l_comment       <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line"> <span class="keyword">IN</span> DMS_D1, DMS_D2</span><br><span class="line"> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line">(STARTING MINVALUE,</span><br><span class="line"> STARTING <span class="string">&#x27;1/1/1992&#x27;</span> </span><br><span class="line">      ENDING <span class="string">&#x27;31/12/1998&#x27;</span> <span class="keyword">EVERY</span> <span class="number">1</span> <span class="keyword">MONTH</span>,</span><br><span class="line"> ENDING MAXVALUE);</span><br></pre></td></tr></table></figure><p>创建该表的 SQL 位于 EX2-4.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 26. 运行 EX2-4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX2-4.sql</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令说明为 LINEITEM 表创建的分区范围：</p><p>清单 27. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 12. 说明为 LINEITEM 表创建的分区范围</p><p><img src="https://i.loli.net/2021/05/06/UBCWpRxN6S41MYc.jpg" alt="s17a.jpg"></p><p>图 13. 分区</p><p><img src="https://i.loli.net/2021/05/06/wT7DyqZAgRsfICF.jpg" alt="s17b.jpg"></p><p>注意：TableSpID 列给出了包含分区的表空间的 ID 号。在本例中，TableSpID 为 4（对应于 DMS_D1）或 5（对应于 DMS_D2）。本例中将生成的分区依次分配给指定的表空间。</p></li></ol><h3 id="分区的显式放置"><a href="#分区的显式放置" class="headerlink" title="分区的显式放置"></a>分区的显式放置</h3><ol><li><p>创建一个具有四个数据分区的新 LINEITEM 表，每一个数据分区被显式地放在表空间中。首先使用如下命令删除现有的 LINEITEM 表：</p><p>清单 28. 删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 drop TABLE LINEITEM</span><br></pre></td></tr></table></figure><p>然后使用下面的 DDL 创建 LINEITEM 表的新版本：</p><p>清单 29. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LINEITEM</span><br><span class="line"> (l_orderkey          <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  l_partkey           <span class="type">INTEGER</span>,</span><br><span class="line">  l_suppkey           <span class="type">INTEGER</span>,</span><br><span class="line">  l_linenumber        <span class="type">INTEGER</span>,</span><br><span class="line">  l_quantity          <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_extendedprice     <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_discount          <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_tax               <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line">  l_returnflag        <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_linestatus        <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line">  l_shipdate          <span class="type">DATE</span>,</span><br><span class="line">  l_commitdate        <span class="type">DATE</span>,</span><br><span class="line">  l_receiptdate       <span class="type">DATE</span>,</span><br><span class="line">  l_shipinstruct      <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line">  l_shipmode          <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line">  l_comment           <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line"> <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line"> ( STARTING MINVALUE <span class="keyword">IN</span> DMS_D1,</span><br><span class="line">   STARTING <span class="string">&#x27;1/1/1992&#x27;</span> ENDING <span class="string">&#x27;31/12/1992&#x27;</span> <span class="keyword">IN</span> DMS_D2,</span><br><span class="line">   STARTING <span class="string">&#x27;1/1/1993&#x27;</span> ENDING <span class="string">&#x27;31/12/1993&#x27;</span> <span class="keyword">IN</span> DMS_D3,</span><br><span class="line">   ENDING MAXVALUE <span class="keyword">IN</span> DMS_D4 );</span><br></pre></td></tr></table></figure><p>创建表的 SQL 位于 EX2-6.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 30. 运行 EX2-6</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX2-6.sql</span><br></pre></td></tr></table></figure></li><li><p>使用下面的命令说明为 LINEITEM 表创建的分区范围：</p><p>清单 31. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 14. 说明为 LINEITEM 表创建的分区范围</p><p><img src="https://i.loli.net/2021/05/06/WTGucEVhmjbQxkF.jpg" alt="s19.jpg"></p><p>注意：在本例中，每一个分区被放置在一个不同的 TableSpID 中，这个 TableSpID 和创建表的 DDL 中指定的表空间是相对应的。</p></li><li><p>创建一个具有四个数据分区的 LINEITEM 表，每一个数据分区被显式地放在表空间并且索引被放在表空间 DMS_I1 中。 在这一步中，将引入命名分区的概念，而不是使用默认的生成名称。 首先，使用下面的命令删除现有的 LINEITEM 分区表：</p><p>清单 32. 删除表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 drop TABLE LINEITEM</span><br></pre></td></tr></table></figure><p>然后，使用以下的 DDL 创建 LINEITEM 表的新版本：</p><p>清单 33. 创建表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> LINEITEM</span><br><span class="line">(l_orderkey           <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">0</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"> l_partkey            <span class="type">INTEGER</span>,</span><br><span class="line"> l_suppkey            <span class="type">INTEGER</span>,</span><br><span class="line"> l_linenumber         <span class="type">INTEGER</span>,</span><br><span class="line"> l_quantity           <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_extendedprice      <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_discount           <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_tax                <span class="type">DECIMAL</span>(<span class="number">12</span>,<span class="number">2</span>),</span><br><span class="line"> l_returnflag         <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> l_linestatus         <span class="type">CHAR</span>(<span class="number">1</span>),</span><br><span class="line"> l_shipdate           <span class="type">DATE</span>,</span><br><span class="line"> l_commitdate         <span class="type">DATE</span>,</span><br><span class="line"> l_receiptdate        <span class="type">DATE</span>,</span><br><span class="line"> l_shipinstruct       <span class="type">CHAR</span>(<span class="number">25</span>),</span><br><span class="line"> l_shipmode           <span class="type">CHAR</span>(<span class="number">10</span>),</span><br><span class="line"> l_comment            <span class="type">VARCHAR</span>(<span class="number">44</span>))</span><br><span class="line">INDEX <span class="keyword">IN</span> DMS_I1</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(l_shipdate)</span><br><span class="line">( PART JAN1992 STARTING <span class="string">&#x27;1/1/1992&#x27;</span>  ENDING <span class="string">&#x27;30/6/1992&#x27;</span> <span class="keyword">IN</span> DMS_D1,</span><br><span class="line">  PART JULY1992 STARTING <span class="string">&#x27;1/7/1992&#x27;</span> ENDING <span class="string">&#x27;31/12/1992&#x27;</span> <span class="keyword">IN</span> DMS_D2,</span><br><span class="line">  PART JAN <span class="number">1993</span> STARTING <span class="string">&#x27;1/1/1993&#x27;</span> ENDING <span class="string">&#x27;30/6/1993&#x27;</span> <span class="keyword">IN</span> DMS_D3,</span><br><span class="line">  PART JULY1993 STARTING <span class="string">&#x27;1/7/1993&#x27;</span> ENDING <span class="string">&#x27;31/12/1993&#x27;</span> <span class="keyword">IN</span> DMS_D4);</span><br></pre></td></tr></table></figure><p>创建表的 SQL 位于 EX2-8.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 34. 运行 EX2-8</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX2-8.sql</span><br></pre></td></tr></table></figure></li><li><p>在 LINEITEM 表中创建一个索引，并将它放置在表空间 DMS_I1 中。使用如下 SQL：</p><p>清单 35. 索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;create index I_LINEITEM on LINEITEM(L_SHIPDATE) in DMS_I1&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用下面的 SQL 检验和该表相关联的索引的位置：</p><p>清单 36. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select tabname, index_tbspace from syscat.tables where tabname = &#x27;LINEITEM&#x27;&quot;</span><br></pre></td></tr></table></figure><p>图 15. 检验索引的位置</p><p><img src="https://i.loli.net/2021/05/06/Ub4S5AMEY3RoN1s.jpg" alt="s21.jpg"></p><p>注意：索引空间是 DMS_I1。如果没有为分区表指定表空间，那么默认情况下索引位于连接着的第一个表空间。 在 CREATE TABLE 中定义表空间是很好的实践。然而，无论您是否在创建表语句 ID 中指定索引表空间，这并不限制您将来放置索引的位置。您可以在 CREATE INDEX 语句本身显式地指定索引表空间。 同一分区表的不同索引可以放置在不同的表空间。</p></li></ol><h2 id="管理分区表"><a href="#管理分区表" class="headerlink" title="管理分区表"></a>管理分区表</h2><p>这个实验将查看如何管理和操作分区表：</p><ol><li>您将添加和删除分区。</li><li>您将执行对分区的转入转出操作。</li><li>在执行查看操作时将使用 DB2 命令和 SQL。</li></ol><h3 id="使用现有的表添加一个新的分区"><a href="#使用现有的表添加一个新的分区" class="headerlink" title="使用现有的表添加一个新的分区"></a>使用现有的表添加一个新的分区</h3><ol><li><p>将数据导入 LINEITEM 表。创建表空间的 SQL 位于 EX3-1.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 37. 导入数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-1.sql</span><br></pre></td></tr></table></figure><p>图 16. 将数据导入到 LINEITEM 表</p><p><img src="https://i.loli.net/2021/05/06/BzP1yRUqGC8csfT.jpg" alt="s22a.jpg"></p><p>注意：分区表中的记录数，以及将进行连接和分离的记录数对于说明数据库中的数据何时可用非常重要。</p></li><li><p>创建一个名为 NP_LINEITEM 的新表。脚本 EX3-2.sql 创建一个具有 87 行的新表 NP_LINEITEM:</p><p>清单 38. 新分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-2.sql</span><br></pre></td></tr></table></figure><p>图 17. 将数据导入到 NP_LINEITEM 表</p><p><img src="https://i.loli.net/2021/05/06/VE6gJxyA8u2GKMn.jpg" alt="s22b.jpg"></p></li><li><p>使用下面的命令说明为 LINEITEM 表创建的分区范围：</p><p>清单 39. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 18. LINEITEM 表的分区</p><p><img src="https://i.loli.net/2021/05/06/NaoryDZum6z1AB9.jpg" alt="s23a.jpg"></p><p>注意：LINEITEM 表目前包含 4 个数据分区。</p></li><li><p>使用<code>Alter</code>语句将一个新的分区连接（转入）到现有的 LINEITEM 表。</p><p>清单 40. 新分区</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> LINEITEM ATTACH <span class="keyword">PARTITION</span> JAN1994</span><br><span class="line">STARTING <span class="string">&#x27;1/1/1994&#x27;</span> ENDING <span class="string">&#x27;30/6/1994&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> NP_LINEITEM</span><br></pre></td></tr></table></figure><p>可以使用以下命令运行脚本 EX3-4：</p><p>清单 41. 新分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-4.sql</span><br></pre></td></tr></table></figure><p>图 19. 脚本 EX3-4</p><p><img src="https://i.loli.net/2021/05/06/nFSMi1mzRVGO2eE.jpg" alt="s23b.jpg"></p><p>注意：LINEITEM 表被置于 SET INTEGRITY PENDING 状态。</p></li><li><p>连接后，使用<code>describe data partitions</code>命令来说明为 LINEITEM 表创建的分区范围：</p><p>清单 42. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 20. LINEITEM 表的分区</p><p><img src="https://i.loli.net/2021/05/06/TQL7BdGUhrsN1KC.jpg" alt="s24.jpg"></p><p>注意：新数据分区（JAN1994）PartitionId 4 现在连接到了 LINEITEM 表。然而连接的分区的 AccessMode 值为 ‘N’ 并且 Status 的值为 ‘A’。 AccessMode 可能的值有：</p><ul><li>D = 没有数据移动</li><li>F = 完全访问</li><li>N = 不访问</li><li>R = 只读访问</li></ul><p>Status 可能的值有：</p><ul><li>A = 数据分区是新连接的</li><li>D = 数据分区是分离的</li><li>I = 只有在执行异步索引清除时才对条目位于目录的分离的数据分区进行维护；当所有引用分离数据分区的索引记录删除后，将删除 STATUS 值为 ‘I’ 的行。</li><li>Empty string = 数据分区是可见的（普通状态）</li></ul></li><li><p>运行两个<code>select count</code>语句来检查连接语句涉及的两个表中数据的可用性。</p><p>清单 43. Count Lineitem</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select count(*) from lineitem&quot;</span><br></pre></td></tr></table></figure><p>图 21. select count 语句的结果</p><p><img src="https://i.loli.net/2021/05/06/JPhz4aMEcZHkfjx.jpg" alt="s25a.jpg"></p><p>注意：LINEITEM 表最初的分区是可用的，但是 PartitionId 4 中的新数据仍不可见。</p><p>清单 44. Count np-lineitem</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select count(*) from np_lineitem&quot;</span><br></pre></td></tr></table></figure><p>图 22. select count 语句的结果</p><p><img src="https://i.loli.net/2021/05/06/3SWJKPv2RNdgZkX.jpg" alt="s25b.jpg"></p><p>注意：NP_LINEITEM 表现在是一个未定义的对象，在 LINEITEM 表内只能将其作为一个分区使用。</p></li><li><p>创建一个异常表并与 SET INTEGRITY 语句结合使用。执行该操作的 DDL 位于 EX3-7.sql 文件，可使用下面的命令运行该文件：</p><p>清单 45. 异常表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-7.sql</span><br></pre></td></tr></table></figure></li><li><p>对 LINEITEM 分区表运行<code>set integrity</code>语句 。</p><p>清单 46. 设置完整性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> INTEGRITY <span class="keyword">FOR</span> LINEITEM</span><br><span class="line">ALLOW WRITE ACCESS</span><br><span class="line">IMMEDIATE CHECKED</span><br><span class="line"><span class="keyword">FOR</span> EXCEPTION <span class="keyword">IN</span> LINEITEM USE LINEITEM_EX</span><br></pre></td></tr></table></figure><p>执行该操作的 SQL 位于 EX3-8.sql 文件中，可以使用下面的命令运行该文件：</p><p>清单 47. 设置完整性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-8.sql</span><br></pre></td></tr></table></figure><p>图 23. EX3-8.sql 文件</p><p><img src="https://i.loli.net/2021/05/06/fDjr7ydniOA1Xev.jpg" alt="s26a.jpg"></p><p>注意：<code>SET INTEGRITY</code>对于检查新连接的数据是否在范围内是必需的，它还执行对索引和其他独立对象（例如物化查询表）所有必需的维护工作。只有得到<code>SET INTEGRITY</code>语句的允许，新的数据才能变为可见。然而，当运行<code>SET INTEGRITY</code>时，可以对 LINEITEM 表中的现有数据进行完全访问，包括读和写操作。 用户应该执行<code>SET INTEGRITY</code>事务从而能够使用整个表。当运行<code>SET INTEGRITY</code>时，不能够对表执行 DDL 或其他实用类型的操作。 在这个练习中，在 NP_LINEITEM 表中创建并被连接到 LINEITEM 表的所有的行，都在连接语句指定的范围内。如果这些行中存在超出此范围的行，则需要在<code>SET INTEGRITY</code>语句中创建一个异常表来防止语句发生错误。所以推荐您始终在<code>SET INTEGRITY</code>语句中包含一个异常表。如果没有提供异常表的话，<code>SET INTEGRITY</code>语句发现的错误将导致语句失败并且所有的工作都必须从头做起。如果使用大量数据时，这可能是一个长期操作。有一点值得注意，如果<code>SET INTEGRITY</code>操作失败，所有工作都需要重做，与之相比较，<code>LOAD</code>仅仅抛弃存在问题的行。</p></li><li><p>对 LINEITEM 表运行<code>select count</code>  SQL 以检查连接的分区中数据的可用性：</p><p>清单 48. Count Lineitem</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select count(*) from lineitem&quot;</span><br></pre></td></tr></table></figure><p>图 24. select count 语句的结果</p><p><img src="https://i.loli.net/2021/05/06/Fw6uJP9zGEvlHAy.jpg" alt="s26b.jpg"></p><p>注意：成功执行<code>SET INTEGRITY</code>操作后，LINEITEM 表应包含 PartitionId 4 的数据。</p></li></ol><h3 id="从分区表中分离一个分区"><a href="#从分区表中分离一个分区" class="headerlink" title="从分区表中分离一个分区"></a>从分区表中分离一个分区</h3><ol><li><p>使用<code>describe data partitions show detail</code>命令来标识一个分区的 PartitionName，您将把这个分区从 LINEITEM 分区表中分离（转出）出来。</p><p>清单 49. 说明表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 25. LINEITEM 表的分区</p><p><img src="https://i.loli.net/2021/05/06/eW7lfdPjq9o5yKa.jpg" alt="s27a.jpg"></p><p>注意：将分离最早的分区范围 PartitionId 0。该分区的 PartitionName 是 JAN1992。将在<code>DETACH</code>操作中使用它来标识被转出的分区。同样还需注意成功执行了<code>SET INTEGRITY</code>操作后，分区 JAN1994 的 AccessMode 的值为 ‘F’，Status 值为空。TableSpId、PartObjId 和 LongTblSpId 的结果可能和这里显示的不一样。</p></li><li><p>使用<code>Alter</code>语句将 JAN1992 从 LINEITEM 表中分离（转出）。</p><p>清单 50. Alter 表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE LINEITEM DETACH PARTITION JAN1992 INTO LINEITEM_JAN1992</span><br></pre></td></tr></table></figure><p>创建文件的 SQL 位于 EX3-11.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 51. Alter 表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 –vtf EX3-11.sql</span><br></pre></td></tr></table></figure><p>注意：将 JAN1992 成功分离后，将创建一个新的表 LINEITEM_JAN1992。在<code>DETACH</code>操作中没有涉及数据移动，并且位于相同表空间的新表的行为和它作为 LINEITEM 分区表的一部分时是一样的。此时不需要对 LINEITEM 表运行<code>SET INTEGRITY</code>语句，因为没有对 LINEITEM 表定义的 MQTs。 还有一点值得注意，如果从 Multi-Dimensional Clustering（MDC）分离一个分区从而创建了一个新表时，这个表也将是一个 MDC。这个规则同样适用于下面这个情况：从一个分布式表中分离分区从而在相同的分区组创建分布式表。执行<code>DETACH</code>操作后产生的表使用 MDC 索引定义而不是其他的索引。对于 MDC，在首次访问连接的表时将重新构建索引。在这种情况下，将自动对分离的分区进行索引清除操作。将从执行<code>DETACH</code>操作的用户 ID 继承索引的模式、权限和表空间。</p></li><li><p>运行两个<code>select count</code>语句检查<code>DETACH</code>语句涉及的两个表中的数据的可用性。</p><p>清单 52. Count Lineitem_jan1992</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select count(*) from lineitem_jan1992&quot;</span><br></pre></td></tr></table></figure><p>图 26. select count 语句的结果</p><p><img src="https://i.loli.net/2021/05/06/Y5crPMXh7GaTnIL.jpg" alt="s28a.jpg"></p><p>注意：创建的 LINEITEM_JAN1992 表包含 38 行，它被包含在 LINEITEM 分区表的 JAN1992 分区中。</p><p>清单 53. Count lineitem</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select count(*) from lineitem&quot;</span><br></pre></td></tr></table></figure><p>图 27. select count 语句的结果</p><p><img src="https://i.loli.net/2021/05/06/3tyEJNCerzlw8FD.jpg" alt="s28b.jpg"></p><p>注意：此时 LINEITEM 表完全可用，并且不包括 PART0 中的数据。</p></li><li><p>当数据被移动到分区表中，或当希望将数据加载到或直接插入分区表中时，一个更合适的方法是向现有的分区表添加一个空的分区。使用下面的命令向现有的 LINEITEM 表添加一个空的分区：</p><p>清单 54. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;ALTER TABLE LINEITEM ADD PARTITION JULY1994 </span><br><span class="line">STARTING &#x27;1/7/1994&#x27; ENDING &#x27;31/12/1994&#x27;&quot;&quot;</span><br></pre></td></tr></table></figure><p>图 28. 向现有的 LINEITEM 表添加一个空的分区</p><p><img src="https://i.loli.net/2021/05/06/uGhk8SYHCZAj2s6.jpg" alt="s28c.jpg"></p></li><li><p>使用<code>describe data partitions show detail</code>命令来检验 PartitionName 为 JULY1994 的分区是否被添加到 LINEITEM 中：</p><p>清单 55. 说明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 describe data partitions for table LINEITEM show detail</span><br></pre></td></tr></table></figure><p>图 29. LINEITEM 表的分区</p><p><img src="https://i.loli.net/2021/05/06/p4KoFitX1TbVgCN.jpg" alt="s29.jpg"></p></li></ol><h2 id="分区表的访问计划"><a href="#分区表的访问计划" class="headerlink" title="分区表的访问计划"></a>分区表的访问计划</h2><p>本实验将研究如何在访问计划中描述分区表：</p><ol><li><p>您将更新分区表中的统计信息。</p></li><li><p>您将使用 <code>db2expln</code> 命令并分析结果。</p></li><li><p>您将在执行查看的操作中使用 DB2 命令和 SQL 。</p></li><li><p>对 LINEITEM 表执行<code>RUNSTATS</code>操作：</p><p>清单 56. Runstats</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 runstats on table db2inst1.lineitem</span><br></pre></td></tr></table></figure></li><li><p>说明以下 SQL 语句并检查说明输出：</p><p>清单 57. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select l_shipdate,sum(l_quantity) from LINEITEM group by l_shipdate&quot;</span><br></pre></td></tr></table></figure><p>要进行说明的 SQL 位于 EX4-2.sql 文件，可以使用下面的命令运行该文件：</p><p>清单 58. 说明输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2expln –d SAMPLE –t –f EX4-2.sql</span><br></pre></td></tr></table></figure><p>图 30. 说明输出</p><p><img src="https://i.loli.net/2021/05/06/Qd9WRODcPMIKFlN.jpg" alt="s30.jpg"></p><p>注意：该 SQL 执行了 LINEITEM 表的索引扫描。说明输出中有一个关于表分区的要点需要注意，所访问的表是被分区的，并且在扫描过程中所有数据分区都将被访问。</p></li><li><p>说明下面的 SQL 语句并检查说明输出：</p><p>清单 59. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select l_shipdate, l_partkey, l_returnflag</span><br><span class="line">from LINEITEM</span><br><span class="line">where l_shipdate between &#x27;01/01/1993&#x27; and &#x27;31/08/1993&#x27;</span><br><span class="line">and l_partkey = 49981&quot;</span><br></pre></td></tr></table></figure><p>要进行说明的 SQL 语句位于 EX4-3.sql 文件中，可使用下面的命令运行该文件：</p><p>清单 60. 说明输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2expln –d SAMPLE –t –f EX4-3.sql</span><br></pre></td></tr></table></figure><p>图 31. 说明输出</p><p><img src="https://i.loli.net/2021/05/06/93AYryCl8EqxtWK.jpg" alt="s31.jpg"></p><p>注意：这个 SQL 语句执行了 LINEITEM 表的索引扫描。在本例中，可以看到优化器能够执行数据分区排除操作。在说明输出中要注意的是关于表分区，访问的表是被分区的，将执行分区排除功能以及删除活动数据分区的值。 在本例中，活动的数据分区为 1-2。这里引用的是 syscat.datapartitions 中的序列号（seqno）而不是<code>describe data partitions</code>命令中的 PartitionId。</p></li><li><p>使用下面的 SQL 确定在前面说明示例中活动的分区的名称：</p><p>清单 61. 说明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db2 &quot;select seqno,datapartitionname</span><br><span class="line">from syscat.datapartitions</span><br><span class="line">where tabname = ‘LINEITEM’ order by seqno&quot;</span><br></pre></td></tr></table></figure><p>图 32. 分区名称</p><p><img src="https://i.loli.net/2021/05/06/KHeQXbU34skIENB.jpg" alt="s32.jpg"></p><p>注意：序列号 1 和 2 分别映射的是 JAN1993 和 JULY1993 分区名称。</p></li></ol><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>本教程基于 IBM DB2 9 Data Partitioning 特性。您已在以下几个方面获得了第一手的经验：</p><ul><li>如何定义分区表</li><li>如何将分区表放置在底层磁盘子系统</li><li>如何维护分区表</li><li>如何使用 DB2 Explain 说明分区表</li></ul><p>范围分区将数据映射到基于关键值范围的分区，用户为每一个分区建立关键值范围。例如，企业通常希望以月份为单位，将销售数据划分到各月的分区中。与 MDC 功能集合使用时，范围分区将更加方便地定位数据，从而加快通过复杂查询检索信息的速度。</p><h3 id="下载资源"><a href="#下载资源" class="headerlink" title="下载资源"></a>下载资源</h3><ul><li><a href="http://www.ibm.com/developerworks/apps/download/index.jsp?contentid=265244&filename=exfiles.zip&method=http&locale=zh_CN">本文的示例脚本和数据</a> (exfiles.zip | 60KB)</li></ul><p>本文转载自IBM官方网站，原文地址：<a href="https://www.ibm.com/developerworks/cn/education/data/dm0612read/dm0612read.html">https://www.ibm.com/developerworks/cn/education/data/dm0612read/dm0612read.html</a></p>]]></content>
    
    
    <summary type="html">【DB2】DB2基础_表分区</summary>
    
    
    
    <category term="DB2" scheme="https://born2do.github.io/categories/DB2/"/>
    
    
    <category term="表分区" scheme="https://born2do.github.io/tags/%E8%A1%A8%E5%88%86%E5%8C%BA/"/>
    
  </entry>
  
  <entry>
    <title>DB2数据库学习_表空间、表分区</title>
    <link href="https://born2do.github.io/2021/05/05/DB2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E8%A1%A8%E5%88%86%E5%8C%BA/"/>
    <id>https://born2do.github.io/2021/05/05/DB2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E8%A1%A8%E5%88%86%E5%8C%BA/</id>
    <published>2021-05-05T08:28:24.000Z</published>
    <updated>2021-05-05T08:28:51.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>表空间是数据库系统中数据库逻辑结构与操作系统物理结构之间建立映射的重要存储结构，它作为数据库与实际存放数据的容器之间的中间层，用于指明数据库中数据的物理位置。任何数据库的创建都必须显式或隐式的为其指定表空间，且数据库中的所有数据都位于表空间中。</p><p>用户可以根据硬件环境以及成本等需求，通过指定建立在不同容器上的表空间来自由选择数据的物理存储位置。同时由于备份和恢复可以在表空间级别执行，用户能够进行更多粒度的备份恢复控制。</p><p>创建一个表之前要给表准备一个容器（Container）来存储表，这个容器就是表空间。</p><blockquote><p>理解表空间前先理解容器。</p><p>容器（Container）  容器是物理存储设备，可以通过目录名、设备名或文件名进行标识。事实上，这也正是三种容器类型。设备容器（如磁带等）和文件容器被同等看待，通常直接将其理解为数据文件（磁盘存储内部结构中有介绍，数据文件中包含若干Extent）。系统管理表空间只能使用目录容器，数据库管理表空间只能使用设备容器和文件容器。</p></blockquote><p>容器被分配给某个表空间，单个表空间可以使用多个容器，但容器只能属于一个表空间。也即表空间与容器的映射关系为1:n。但通常都是1:1的映射关系，便于查找和管理。</p><p>DB2的表空间按管理方式分为两种：</p><ul><li><p>  系统管理表空间（System Managed Space，SMS）</p></li><li><p>  数据库管理表空间（Database Managed Space，DMS）</p></li></ul><h3 id="系统管理表空间（SMS）"><a href="#系统管理表空间（SMS）" class="headerlink" title="系统管理表空间（SMS）"></a>系统管理表空间（SMS）</h3><p>SMS表空间由操作系统的文件系统管理器分配并管理。在这种表空间中，数据存储空间完全由操作系统管理，SMS表空间能够使用的唯一容器是目录容器，SMS表空间可以定义多个容器，目录容器可以根据需要增加大小，因此SMS表空间的大小是可以动态增加的。但是一旦SMS表空间创建，就不能再为表空间增加或删除容器了。SMS表空间中通常包含多个文件，这些文件代表了存储在文件系统空间中的表对象，比如表数据，表索引，表大对象都是单独占用一个或若干个文件的。一旦为表指定了SMS表空间，那么表中的数据就不允许分开存储，即表的常规数据，索引，大对象数据不能位于不同的表空间中。在DB2 V9之前的数据库版本中，创建数据库（创建数据库时如果不指定表空间则会默认创建3个表空间）或表空间的默认类型就是SMS表空间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS：只有DB2数据库允许有系统管理表空间，Oracle数据库的表空间都是数据库管理的，不存在系统管理表空间。</span><br></pre></td></tr></table></figure><p>SMS每个容器是操作系统的文件空间中的一个目录，该目录中，  <code>SQL*.DAT</code>数据文件存放表中的常规数据；  <code>SQL*.DTR</code>数据文件存放由于重组，表连接等产生的临时数据；  <code>SQL*.INX</code>数据文件存放表中的索引；  还有LF后缀的存放LONG VARCHAR或LONG VARGRAPHIC数据，LB后缀的存放BLOB,CLOB和DBLOB数据，LBA后缀的存放LB后缀文件的分配和可用空间信息等。</p><p><img src="https://i.loli.net/2021/05/05/t2F8puaZIoAsXj9.png" alt="SMS_eg.png"></p><p>使用SMS表空间的每一个表都会在表空间的容器（也就是目录）下对应产生一系列的<code>SQL*.DAT</code>,<code>SQL*.INX</code>等文件。表和其对应的文件的信息存放在SYSIBM.SYSTABLES这个系统编目表中，每个表对应一个FID（表所在的文件组编号）和TID（表所在的表空间编号），可以使用查询语句进行查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> FID,TID, NAME <span class="keyword">FROM</span> SYSIBM.SYSTABLES</span><br></pre></td></tr></table></figure><h3 id="数据库管理表空间（DMS）"><a href="#数据库管理表空间（DMS）" class="headerlink" title="数据库管理表空间（DMS）"></a>数据库管理表空间（DMS）</h3><p>DMS表空间由数据库管理系统（DBMS）自己管理控制，本质上讲，这种类型的表空间是为了最大程度满足数据库管理器的需要而设计并实现的一种特定目的的文件系统。DMS表空间是由有限数量的容器所组成的，DMS表空间可以使用的容器有设备容器和文件容器，这些容器的空间都是在创建时预先分配的。DMS表空间创建时需要手动指定一个或多个容器。以文件为容器的表空间创建完以后就是一个单独的文件。使用DMS表空间的表的数据可以分开存储，即为常规数据，索引和大对象数据指定不同的DMS表空间。</p><blockquote><p>SMS的管理比较简单，由操作系统自动管理，空间大小最数据量的变化由系统自动调整。</p><p>DMS是由数据库管理的，空间大小在创建时确定。空间不够时，通过使用 ALTER TABLESPACE 命令来扩展容器。空间多余时，可以释放未使用的那部分 DMS 容器空间（从 V8 开始）。</p></blockquote><h3 id="DMS自动存储表空间（Automatic-Storage-DMS）"><a href="#DMS自动存储表空间（Automatic-Storage-DMS）" class="headerlink" title="DMS自动存储表空间（Automatic Storage DMS）"></a>DMS自动存储表空间（Automatic Storage DMS）</h3><p>自动存储表空间不是真正意义上的独立类型的表空间。它是DMS存储的另外一种处理方法。DMS需要很多的维护操作，而自动存储器则是作为一种简化的空间管理手段，能够自动进行表空间的管理维护，它是DB2 V8.8.2中引入的概念，目前取代SMS成为默认的表空间类型。</p><h3 id="三种表空间对比"><a href="#三种表空间对比" class="headerlink" title="三种表空间对比"></a>三种表空间对比</h3><table><thead><tr><th>特性</th><th>SMS</th><th>DMS</th><th>自动存储</th></tr></thead><tbody><tr><td>是否条带化/分段（Strping）</td><td>是</td><td>是</td><td>是</td></tr><tr><td>默认类型</td><td>Version 8</td><td>无</td><td>Version 9</td></tr><tr><td>对象管理</td><td>操作系统</td><td>DB2</td><td>DB2</td></tr><tr><td>空间分配</td><td>按需增长/收缩</td><td>预先分配；大小可以收缩和增长，但是需要DBA干预</td><td>预先分配；可以自动增长</td></tr><tr><td>管理的简便性</td><td>最好；很少需要调优，甚至不需要调优</td><td>好，但是需要一些调优</td><td>最好；很少需要调优，甚至不需要调优</td></tr><tr><td>性能</td><td>不太好</td><td>最好，可通过原始容器多获得5%到10%的收益</td><td>最好，但是不可以使用原始容器</td></tr><tr><td>容器</td><td>目录</td><td>文件/物理设备</td><td>文件/物理设备</td></tr><tr><td>表空间最大大小</td><td>64GB（4K页面）</td><td>2TB（4K页面）</td><td>2TB（4K页面）</td></tr></tbody></table><h3 id="DMS与自动存储DMS"><a href="#DMS与自动存储DMS" class="headerlink" title="DMS与自动存储DMS"></a>DMS与自动存储DMS</h3><p>那么DMS和自动存储哪种方式更佳呢？自动存储允许 DBA 为数据库设置在创建所有表空间容器时可以使用的存储路径。DBA 不必显式地定义表空间的位置和大小，系统将自动地分配表空间。在 DB2 9 中，数据库在创建时将启用自动存储，除非 DBA 显式地覆盖这个设置。 启用自动存储的数据库有一个或多个相关联的存储路径。表空间可以定义为 “由自动存储进行管理”，它的容器由 DB2 根据这些存储路径进行分配。数据库只能在创建时启用自动存储。对于在最初没有启用自动存储的数据库，不能在以后启用这个特性。同样，对于在最初启用了自动存储的数据库，也不能在以后禁用这个特性。</p><p>非自动存储和自动存储之间的一些差异：</p><table><thead><tr><th>特性</th><th>非自动存储</th><th>自动存储</th></tr></thead><tbody><tr><td>容器的创建</td><td>必须在创建表空间时显示地提供容器。</td><td>允许 DBA 为数据库设置在创建所有表空间容器时可以使用的存储路径。不能在创建表空间时提供容器，他们将由DB2自动分配。</td></tr><tr><td>容器大小的调整</td><td>在默认情况下，表空间大小的自动调整是关闭的（AUTORESIZE NO）。</td><td>在默认情况下，表空间大小的自动调整是关闭的（AUTORESIZE YES）。</td></tr><tr><td>初始大小</td><td>不能使用INITIALSIZE子句指定表空间初始大小</td><td>使用INITIALSIZE子句指定表空间初始大小</td></tr><tr><td>容器的修改</td><td>可以使用 ALTER TABLESPACE语句（ADD、DROP等等）执行容器操作</td><td>不能执行容器操作，因为由DB2控制空间管理</td></tr><tr><td>管理的便捷性</td><td>可以使用重定向的恢复操作重新定义与表空间相关联的容器</td><td>不能使用重定向的恢复操作重新定义与表空间相关联的容器，因为由DB2控制空间管理</td></tr></tbody></table><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><ol><li> 表空间创建</li></ol><ul><li>  创建SMS表空间</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span></span><br><span class="line">MANEGED <span class="keyword">BY</span> <span class="keyword">SYSTEM</span> <span class="keyword">USING</span>(<span class="string">&#x27;&lt;PATH&gt;&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>  创建DMS表空间</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLESPACE &lt;NAME&gt;</span><br><span class="line">MANEGED BY DATABASE USING(FILE &#39;&lt;PATH&gt;&#39; &lt;SIZE&gt;)</span><br></pre></td></tr></table></figure><ul><li>  创建常规表空间（自动存储DMS）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> REGULAR TABLESPACE <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span>  <span class="operator">-</span>常规表空间名称</span><br><span class="line">PAGESIZE <span class="number">4</span>K                       <span class="operator">-</span>页大小</span><br><span class="line">MANEGED <span class="keyword">BY</span> AUTOMATIC STORAGE      <span class="operator">-</span>使用自动存储DMS</span><br></pre></td></tr></table></figure><ul><li>  自定义页大小、容器大小、缓冲池</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">LARGE</span> TABLESPACE <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span>                              <span class="operator">-</span>表空间名称</span><br><span class="line">PAGESIZE <span class="number">16</span>K                                                <span class="operator">-</span>页大小</span><br><span class="line">MANAGED <span class="keyword">BY</span> DATABASE <span class="keyword">USING</span> (FILE <span class="string">&#x27;&lt;PATH&gt;&#x27;</span> <span class="operator">&lt;</span>CONTAINER_SIZE<span class="operator">&gt;</span>)  <span class="operator">-</span>容器路径及大小</span><br><span class="line">BUFFERPOOL <span class="operator">&lt;</span>BFP_NAME<span class="operator">&gt;</span>                                  <span class="operator">-</span>指定缓冲池（已创建）</span><br></pre></td></tr></table></figure><ol start="2"><li> 表空间查看</li></ol><ul><li>  linux查看表空间使用情况：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 list tablespaces <span class="keyword">show</span> detail</span><br></pre></td></tr></table></figure><ul><li>  查看具体表空间：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 list tablespace containers <span class="keyword">for</span> TablespaceID(具体的id) <span class="keyword">show</span> detail</span><br></pre></td></tr></table></figure><ul><li>  SQL查看</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SYSCAT.TABLESPACES;</span><br><span class="line"><span class="keyword">SELECT</span> TBSPACE, BUFFERPOOLID <span class="keyword">FROM</span> SYSCAT.TABLESPACES;</span><br></pre></td></tr></table></figure><ol start="3"><li> 表空间修改</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> EXTEND (<span class="keyword">ALL</span> CONTAINERS <span class="operator">&lt;</span>SIZE<span class="operator">&gt;</span>);<span class="operator">-</span>增加表空间</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE <span class="operator">&lt;</span>NAME<span class="operator">&gt;</span> REDUCE (<span class="keyword">ALL</span> CONTAINERS <span class="operator">&lt;</span>SIZE<span class="operator">&gt;</span>);<span class="operator">-</span>减小表空间</span><br><span class="line">    </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE <span class="operator">&lt;</span>name<span class="operator">&gt;</span> bufferpool <span class="operator">&lt;</span>bfp_name<span class="operator">&gt;</span>; <span class="comment">--修改表空间缓冲池</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE <span class="operator">&lt;</span>name<span class="operator">&gt;</span>  <span class="keyword">no</span> file <span class="keyword">system</span> caching; <span class="comment">--修改缓存级别</span></span><br></pre></td></tr></table></figure><ol start="4"><li> 表空间删除</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> tablespace 表空间名;</span><br></pre></td></tr></table></figure><h2 id="表分区"><a href="#表分区" class="headerlink" title="表分区"></a>表分区</h2><p>表分区是一种数据组织模式，在这种模式中，数据将以一个或多个表列的值为依据，分割到多个称为数据分区（或范围）的存储对象中。每一个数据分区被分别存储。这些存储对象可以位于不同的表空间中，可以位于相同的表空间中，也可能是这两种情况的组合。</p><p>DB2 数据库分区是 DB2 企业版 DPF(Data Partitioning Feature)选件提供的，它主要用来个分区（逻辑的或物理的）上分布大型数据库提供了必要的可伸缩性，并利用了一个无共享（shared-nothing）结构。数据库在一个非共享的环境中被分解为独立的分区，每个分区都具有自己的资源，例如内存，CPU 和磁盘以及自己的数据、索引、配置文件和事务日志。数据库分区有时称为节点或数据库节点。通过 DPF“分治”的处理，可伸缩性可在单一服务器（纵向扩展）或跨服务器集群（横向扩展）中获得增强。</p><p>使用 DPF最显而易见的理由之一就是提高查询工作负载和 INSERT/UPDATE/DELETE 操作的性能。DPF 还可以克服部分 DB2 的架构限制。例如，在 DB2 中，对 4 KB 的页面大小而言，表的最大大小是 64 GB；对于 8 KB 的页面大小而言，表的最大大小是 128 GB；对于 16 KB 的页面大小而言，表的最大大小是 256 GB；对于 32 KB 的页面大小而言，表的最大大小是 512 GB。在 DB2 中，表和表空间的大小限制是根据每个分区进行规定的。跨多个分区划分数据库将允许您根据环境中分区数目的因数来增加表的最大大小。</p><p>DB2数据库分区实例图：</p><p><img src="https://i.loli.net/2021/05/05/Xtzly4jwG2n1gHL.png" alt="DB2数据库分区实例图.png"></p><h3 id="表分区说明"><a href="#表分区说明" class="headerlink" title="表分区说明"></a>表分区说明</h3><p>在db2数据库中，可对数据表按某个字段进行分区，分区好处是：可扩展表的存储能力、对于大量数据表使用分区字段可提高查询效率。表分区不同于数据库分区，需要在创建表的时候设置分区逻辑。  在定义表分区的字段时，有几个原则：</p><p>1.不支持创建只包含长数据类型的多分区表，</p><p>2.不能改变分区键定义，</p><p>3.分区键应该包含最频繁连接的列，</p><p>4.分区键应该由经常参与group by字句的组成，</p><p>5.任何主键或唯一键必须包含分区列。</p><h3 id="实操-1"><a href="#实操-1" class="headerlink" title="实操"></a>实操</h3><ol><li> 表分区创建</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> TABLE_TEST_HAOTD(</span><br><span class="line">     DATADATE <span class="type">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">     DATA1 <span class="type">VARCHAR</span>(<span class="number">10</span>),</span><br><span class="line">     DATA2 <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">    ) </span><br><span class="line">    <span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(DATADATE)</span><br><span class="line">    (PART &quot;P20180101&quot; STARTING(<span class="string">&#x27;20180101&#x27;</span>) ENDING(<span class="string">&#x27;2018010&#x27;</span>))</span><br></pre></td></tr></table></figure><ol start="2"><li> 表分区增加</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_TEST_HAOTD <span class="keyword">ADD</span> <span class="keyword">PARTITION</span> &quot;P20180102&quot; STARTING <span class="string">&#x27;20180102&#x27;</span> ENDING <span class="string">&#x27;20180102&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>表分区删除</p><p> db2的分区是无法直接删除，要先卸载分区，再进行drop操作。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> TABLE_TEST_HAOTD DETACH <span class="keyword">PARTITION</span> P20180101 <span class="keyword">INTO</span> <span class="keyword">TABLE</span> TMP_TESTHAOTD_P20180101</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> TMP_HAOTDTEST_P20180101</span><br></pre></td></tr></table></figure><ol start="4"><li> 表分区查看</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> SYSCAT.DATAPARTITIONS <span class="keyword">WHERE</span> TABNAME<span class="operator">=</span><span class="string">&#x27;表名称&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2 <span class="keyword">describe</span> data partitions <span class="keyword">for</span> <span class="keyword">table</span> <span class="operator">&lt;</span>tablename<span class="operator">&gt;</span> <span class="keyword">show</span> detail</span><br></pre></td></tr></table></figure><p>部分素材来源：</p><p><a href="https://blog.csdn.net/mydriverc2/article/details/81287476">https://blog.csdn.net/mydriverc2/article/details/81287476</a></p><p><a href="https://blog.51cto.com/5063935/2074288">https://blog.51cto.com/5063935/2074288</a></p><p><a href="https://www.cnblogs.com/haotengda/p/9719729.html">https://www.cnblogs.com/haotengda/p/9719729.html</a></p>]]></content>
    
    
    <summary type="html">DB2数据库学习_表空间、表分区</summary>
    
    
    
    <category term="数据库" scheme="https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="DB2" scheme="https://born2do.github.io/tags/DB2/"/>
    
  </entry>
  
  <entry>
    <title>VS2019安装包及秘钥</title>
    <link href="https://born2do.github.io/2021/05/04/VS2019%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E7%A7%98%E9%92%A5/"/>
    <id>https://born2do.github.io/2021/05/04/VS2019%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E7%A7%98%E9%92%A5/</id>
    <published>2021-05-04T02:07:21.000Z</published>
    <updated>2021-05-04T02:08:03.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="VS2019安装包及秘钥"><a href="#VS2019安装包及秘钥" class="headerlink" title="VS2019安装包及秘钥"></a>VS2019安装包及秘钥</h2><p>链接： <a href="https://pan.baidu.com/s/1ufRrlpgh-8ty6VsjOo7JSw">https://pan.baidu.com/s/1ufRrlpgh-8ty6VsjOo7JSw</a>  提取码：8v8x</p><p>Visual Studio 2019?Enterprise 企业版：  BF8Y8-GN2QH-T84XB-QVY3B-RC4DF</p><p>Visual Studio 2019?Professional 专业版：  NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y</p><p>VS2019中，菜单栏-&gt;帮助-&gt;注册产品，，然后输入上方对应版本的激活码。</p>]]></content>
    
    
    <summary type="html">VS2019安装包及秘钥</summary>
    
    
    
    <category term="LICENSE " scheme="https://born2do.github.io/categories/LICENSE/"/>
    
    
  </entry>
  
  <entry>
    <title>Sublime LICENSE</title>
    <link href="https://born2do.github.io/2021/05/04/Sublime-LICENSE/"/>
    <id>https://born2do.github.io/2021/05/04/Sublime-LICENSE/</id>
    <published>2021-05-04T02:05:11.000Z</published>
    <updated>2021-05-04T02:06:55.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Sublime-LICENSE"><a href="#Sublime-LICENSE" class="headerlink" title="Sublime LICENSE"></a>Sublime LICENSE</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">sgbteam</span><br><span class="line">Single User License</span><br><span class="line">EA7E-1153259</span><br><span class="line">8891CBB9 F1513E4F 1A3405C1 A865D53F</span><br><span class="line">115F202E 7B91AB2D 0D2A40ED 352B269B</span><br><span class="line">76E84F0B CD69BFC7 59F2DFEF E267328F</span><br><span class="line">215652A3 E88F9D8F 4C38E3BA 5B2DAAE4</span><br><span class="line">969624E7 DC9CD4D5 717FB40C 1B9738CF</span><br><span class="line">20B3C4F1 E917B5B3 87C38D9C ACCE7DD8</span><br><span class="line">5F7EF854 86B9743C FADC04AA FB0DA5C0</span><br><span class="line">F913BE58 42FEA319 F954EFDD AE881E0B</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure><p>声明一下，不确定是否还有用了。</p>]]></content>
    
    
    <summary type="html">Sublime LICENSE</summary>
    
    
    
    <category term="LICENSE" scheme="https://born2do.github.io/categories/LICENSE/"/>
    
    
  </entry>
  
  <entry>
    <title>牛客网数据库刷题笔记</title>
    <link href="https://born2do.github.io/2021/05/03/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
    <id>https://born2do.github.io/2021/05/03/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-02T23:24:42.000Z</published>
    <updated>2021-05-02T23:25:19.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一星题"><a href="#一星题" class="headerlink" title="一星题"></a>一星题</h2><ol><li><p><strong>日志文件</strong>用来记录对数据库中数据进行的每一次更新操作。</p></li><li><p>索引是在基本表的列上建立的一种数据库对象，它同基本表分开存储，使用它能够加快数据的（查询）速度。</p></li><li><p>where子句后不能放聚合函数。</p></li><li><p>用二维表来表示实体集及实体集之间联系的数据模型称为关系模型。</p></li><li><p>数据库系统与文件系统的主要区别是：文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决。</p></li><li><p>数据库管理系统DBMS是系统软件。</p></li><li><p>数据库系统一般由数据库、数据库管理系统（DBMS）、应用系统、数据库管理员和用户构成。DBMS是数据库系统的基础和核心。</p></li><li><p>MySQL忘记root密码，不管哪种解决方案，最终都要实现更新mysql数据库下的<strong>user</strong>表。</p></li><li><p>SQL 采用集合操作方式。</p></li><li><p>概念模型是用于信息世界的建模，与具体的 DBMS 无关。</p></li><li><p>数据库系统不仅包括数据库本身,还要包括相应的硬件、软件和各类相关人员。</p></li><li><p>在Access数据库的表设计器中可以修改字段类型、设置索引和增加字段。要想删除表中的记录，需要打开表进行删除。</p></li><li><p>SQL支持的备份类型有四种：</p><ul><li>完全数据库备份 </li><li>差异备份或称增量备份</li><li>事务日志备份</li><li>数据库文件和文件组备份</li></ul></li><li><ul><li>串行读(Serializable):完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞</li><li>未提交读(Read Uncommitted):允许脏读,也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed):只能读取到已经提交的数据</li><li>可重复读(Repeated Read):在同一个事务内的查询都是事务开始时刻一致的</li></ul></li><li><p>数据库分类：</p><ul><li>Mongodb数据库属于文档型非关系数据库</li><li>PostgreSQL属于关系型数据库</li><li>Redis属于KV键值数据库</li><li>Hbase属于列数据库</li></ul></li><li><p>在手机开发中常用的数据库是sqlLite。</p></li><li><p>关系模型中，一个关键字，可由一个或多个其值能惟一标识该关系模式中任何元组的属性组成。</p></li><li><p>在合并分E-R图时必须消除各分图中的不一致。各分E-R图之间的冲突主要有三类，即属性冲突、命名冲突和结构冲突，其中命名冲突是指同名异义或同义异名。</p></li><li><p>在数据系统中，对存取权限的定义称为授权。</p></li><li><p>索引的描述存放在数据字典中。</p></li><li><p>SQL语言具有两种使用方式，分别称为交互式SQL和嵌入式SQL。</p></li><li><p>数据库的物理结构设计的目的是：找到一个有效、可实现的数据库存储结构。</p></li><li><blockquote><p>（1）若视图的字段是来自字段表达式或常数，则不允许对此视图执行INSERT、UPDATE操作，允许执行DELETE操作；<br>（2）若视图的字段是来自库函数，则此视图不允许更新；<br>（3）若视图的定义中有GROUP BY子句或聚集函数时，则此视图不允许更新；<br>（4）若视图的定义中有DISTINCT任选项，则此视图不允许更新；<br>（5）若视图的定义中有嵌套查询，并且嵌套查询的FROM子句中涉及的表也是导出该视图的基表，则此视图不允许更新；<br>（6）若视图是由两个以上的基表导出的，此视图不允许更新；<br>（7）一个不允许更新的视图上定义的视图也不允许更新；<br>（8）由一个基表定义的视图，只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。</p></blockquote></li><li><p>相对于非关系模型，关系数据模型的缺点之一是：存取路径对用户透明，需查询优化。</p></li><li><p>一个关系数据库文件中的各条记录，前后顺序可以任意颠倒，不影响库中的数据关系。</p></li><li><p>不借助第三方工具，通过<code>explain plan</code>查看SQL的执行计划。</p></li><li><p>数据库的<strong>网状模型</strong>应满足的条件是：允许一个以上结点无双亲，也允许一个结点有多个双亲。</p></li><li><p>数据库并发操作带来的数据不一致性包括丢失修改、不可重复读、读“脏”数据。</p></li><li><blockquote><p>事务四大特性(简称ACID) </p><p>1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。<br>2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。<br>3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。<br>4、持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。</p></blockquote></li><li><p>左连接时，结果集的行数可能大于左表的行数。</p><p>解释：如果 left join on的条件在右表中有所重复，那么最终记录数目会大于原表数量。</p></li><li><p>创建表：CREATE TABLE</p><p>创建视图：CREATE VIEW</p><p>创建索引：CREATE INDEX </p><p>CREATE SCHEMA 是 CREATE DATABASE 的一个代名词。</p></li><li><p>子模式DDL用来描述，数据库的局部逻辑结构。</p></li><li><p>SQL语言是（非过程化）的语言。</p></li><li><blockquote><p>1.等值连接，在两个表中的广义笛卡尔积中选取属性值相等的元组</p><p>2.自然连接（特殊的等值连接），在等值连接的基础上去掉重复项</p><p>3.外连接分为左外连接右外连接</p><p>注：等值连接需要标出具体哪个元组相等</p></blockquote></li><li><p>对数据表进行修改时，删除列可以省略column，添加列必须说明数据类型。</p><p><code>alter table employee drop column age;</code></p><p><code>alter table employee drop age;</code></p></li><li><p>关系模型的三个组成部分，是指关系数据模型的<strong>数据结构、数据操作和完整性约束</strong>。</p></li><li><p>存储过程的好处：重复使用、SQL优化、更加安全。</p></li><li><p>并发控制指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。</p></li><li><blockquote><ol><li>DCL(数据控制语言)：grant revoke   </li><li>DML(数据操纵语言)：insert delete update select   </li><li>DDL(数据定义语言)：create drop alter   </li><li>TCL(事物控制语言)：commit rollback </li></ol></blockquote></li><li><p>物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。</p><p>逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。</p><p>在数据库系统中，外模式/模式映象保证数据的逻辑独立性，模式/内模式映象保证数据的物理独立性。</p></li><li><p>对于串行调度，各个事务的操作没有交叉，也就没有相互干扰，当然也不会产生并发所引起的。事务对数据库的作用是将数据库从一个一致的状态转变为另一个一致的状态。多个事务串行执行后，数据库仍旧保持一致的状态。 可串行性(Serializability)  是并发事务正确调度的准则。在RDBMS中，作为并发控制的正确性准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。</p></li><li><p>聚合函数MAX(＜列名＞)用于求某一列值的最大值，它对列名不限制数据类型。</p></li><li><p>数据库保护又叫做数据库控制，是通过四方面实现的，即安全性控制、完整性控制、并发性和数据恢复。</p></li><li><blockquote><p>第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。</p><p>第二范式（2NF）：首先是1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。</p><p>第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。</p><p>第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。</p></blockquote></li><li><blockquote><p>（1）实体类型的转换<br>将每个实体类型转换成一个关系模式，实体的属性即为关系的属性，实体标识符即为关系的键。<br>（2）联系类型的转换<br>1）实体间的联系是1:1，<br>可以在两个实体类型转换成两个关系模式中的任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。<br>2）实体间的联系是1:N，<br>则在N端实体类型转换成的关系模式中加入1端实体类型转换成的关系模式的键和联系类型的属性。<br>3）实体间的联系是M:N，<br>则将联系类型也转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合。</p></blockquote><p>注意：一对一关系，一对多关系不需要新表。</p></li></ol><h2 id="两星题"><a href="#两星题" class="headerlink" title="两星题"></a>两星题</h2><ol><li><p>为了反映事物本身及事物之间的联系，数据库中的数据必须有一定的结构，这种结构用数据模型来表示，一个具体的数据模型应当正确地反映出数据之间存在的整体逻辑关系，所以数据模型质量的高低直接影响数据库性能的好坏。</p></li><li><p>共享锁：是非独占的，允许其他事物同时读取其锁定的资源（也可再加共享锁），但不允许修改。</p><p>独占锁（即排他锁）：只能自己使用，不允许其他事物读取和修改。</p></li><li><p>如果想使用NULL，则需要使用IS NULL或者IS NOT NULL。如果将NULL与比较运算符，则结果都是NULL。</p></li><li><p>在使用limit子句时，如果没有足够的行，MySQL将只返回它能返回的那么多行。</p></li><li><p>数据库的基本特点是：</p><p>（1）数据可以共享（或数据结构化） （2）数据独立性<br>（3）数据冗余小，易扩充 （4）统一管理和控制</p></li><li><p>数据库是按照一定的数据模型组织的，长期存储在计算机内，可为多个用户共享的数据的聚集。</p></li><li><p>选择是将表进行水平分割的运算，其目的是为了保留某些符合条件的元组。投影是对表进行垂直分割的运算，其目的是实现属性的筛选。</p></li><li><p>关系的描述称为关系模式。对关系的描述，一般表示为：关系名（属性1，属性2…..属性n）。例如：课程(课程号、课程名称、学分、任课老师)</p></li><li><p>限制输入到列的值的范围，应使用CHECK约束。</p></li><li><p>外键中的属性允许为null，只要没有被声明为not null。</p></li><li><p>在数据库的安全控制中，为了保证用户只能存取他有权存取的数据，在授权的定义中数据对象的（范围越小），授权子系统就越灵活 。</p></li><li><p>在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应（加前缀:）。</p></li><li><p>“元组”所表达的概念与二维表的”行”的概念最接近。</p></li><li><p>数据库系统包括数据库和数据库管理系统 [数据库系统&gt;数据库管理系统&gt;数据库]。</p></li><li><blockquote><p>实体完整性指表中行的完整性 </p><p>域完整性指列的值域的完整性，如数据类型、格式、值域范围、是否允许空值等等 </p><p>参照完整性基于外键与被引用主键之间的关系，确保键值在所有表中的一致性 </p></blockquote></li><li><p>数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</p></li><li><table><thead><tr><th>关系术语</th><th>一般表格的术语</th></tr></thead><tbody><tr><td>关系名</td><td>表名</td></tr><tr><td>关系模式</td><td>表头（表格的描述）</td></tr><tr><td>关系</td><td>一张二维表</td></tr><tr><td>元组</td><td>记录或行</td></tr><tr><td>属性</td><td>列</td></tr><tr><td>属性名</td><td>列名</td></tr><tr><td>属性值</td><td>列值</td></tr><tr><td>分量</td><td>一条记录中的一个列值</td></tr><tr><td>非规范关系</td><td>大表中嵌着小表</td></tr></tbody></table></li><li><blockquote><p>外模式又称子模式，对应于用户级。外模式反映了数据库的用户观。<br>内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述,它是数据库的存储观<br>模式又称概念模式或逻辑模式，对应于概念级.反映了数据库系统的整体观</p></blockquote></li><li><ul><li>SQL语句关键字顺序为：select, from, where, group by, having, order by, limit</li><li>where增加分组前的限定，having增加分组后的限定</li><li>group by 通常和集合函数SUM()，AVG()，MAX()，MIN()，COUNT()等结合在一起，后接限制条件语句 having,不可用where语句！</li></ul></li><li><blockquote><p>数据库常用的关系运算有三种 </p><p>1、选择  从二维表中选出符合条件的记录，它是从行的角度对关系进行运算 </p><p>2、投影，从二维表中选出所需要的列，它是从列的角度对关系进行运算：从关系中挑选出指定的属性组成新关系的运算 </p><p>3、连接，同时涉及到两个二维表的运算，它是将两个关系在给定的属性上满足一定条件的记录连接起来 从而得到一个新的关系</p></blockquote></li><li><ul><li>聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。</li><li>非聚集索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。</li><li>一个表只能有一个聚集索引和多个非聚集索引。</li></ul></li><li><p>按所使用的数据模型来分，数据库可分为三种模型：层次、关系和网状。</p></li><li><p>在数据库中存储的是数据以及数据之间的联系。</p></li><li><p>数据库系统的数据独立性体现在不会因为数据存储结构与数据逻辑结构的变化而影响应用程序。</p></li><li><ul><li>丢失更新：当两个或多个事物读入同一数据并修改，会发生丢失更新问题，即后一个事物更新的结果被前一事务所做更新覆盖 即当事务A和B同事进行时，事务A对数据已经改变但并未提交时B又对同一数据进行了修改（注意此时数据是A还未提交改变的数据），到时A做的数据改动丢失了</li><li>读‘脏数据’：指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</li><li>不可重复读：这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。</li><li>幻读：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。</li></ul></li><li><blockquote><p>按照规范的设计方法，一个完整的 数据库设计 一般分为以下六个阶段：<br>⑴需求分析：分析用户的需求，包括数据、功能和性能需求；<br>⑵概念结构设计：主要采用E-R模型进行设计，包括画E-R图；<br>⑶逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；进行关系规范化。<br>⑷数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；<br>⑸数据库的实施：包括编程、测试和试运行；<br>⑹数据库运行与维护：系统的运行与数据库的日常维护。</p></blockquote></li><li><p>数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件、数据库后备副本。</p></li><li><p>数据库中，<code>optimize table TabName;</code>命令可以整理表数据文件的碎片。</p></li><li><p>对数据库中表的字段进行相关操作时，添加时column可以省略，删除时column不能省略。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tableName DROP COLUMN columnName;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tableName ADD columnName;</span><br></pre></td></tr></table></figure></li></ol><h2 id="三星题"><a href="#三星题" class="headerlink" title="三星题"></a>三星题</h2><ol><li><blockquote><p>1）候选键： 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了。（即该属性组内不应该存在一个真子集也能标识一个元组）。这样的属性组称作候选码。</p><p>2）主键：当有多个候选码时，可以选定一个作为主码，选定的候选码称主键</p><p>3）外键：关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。</p></blockquote><p>候选码可以唯一标识一个实体，可以有一个或者多个。 </p><p>主码唯一且非空，也是唯一标识一个实体的码。</p><p>如果候选码有多个，可以从中选定一个主码。</p></li><li><ul><li>模式：只能有一个</li><li>内模式：只能有一个</li><li>外模式：任意多个</li></ul></li><li><p>索引类型分类：</p><p>普通索引：没有任何限制</p><p>唯一索引：不允许建立索引的列有重复的值，但可以有空值</p><p>主索引：特殊的唯一索引，不允许有空值</p><p>候选索引：也要求唯一性，一个表中可以有多个候选索引</p></li><li><p>视图设计的几种方法：   </p><ul><li>自顶向下。先全局框架，然后逐步细化</li><li>自底向上。先局部概念结构，再集成为全局结构</li><li>由里向外。先核心结构，再向外扩张</li><li>混合策略。1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构 </li></ul></li><li><p>对于各种范式之间的关系如下： 5NF⊂ 4NF⊂ BCNF ⊂3NF ⊂ 2NF⊂ 1NF </p></li><li><ul><li>等值连接是从关系R和S的广义笛卡尔积中选取A和B“属性值”相等的元组，所以只要两个关系里面的有元组属性值相等就可以进行</li><li>自然连接是要求R和S中有一个或者多个相同的属性组</li></ul></li><li><blockquote><p>3NF——只消除非主属性对主属性的传递依赖<br>BCNF——消除所有属性对主属性的传递依赖</p></blockquote></li><li><p>为了提高数据库的性能，需要针对系统设计基准测试进行压力测试，那么进行压力测试时需要考虑以下指标：</p><ul><li>响应时间</li><li>并发性</li><li>吞吐量</li></ul></li><li><p>关系运算中花费时间可能最长的运算是笛卡尔积。</p></li><li><p>数据库对象的四种视图模式：详细模式，小图标，大图标，列表。</p></li><li><p>WITH CHECK OPTION 用于限制视图，通过视图进行修改时，必须要能通过该视图看到修改后的结果，即对其的修改要再次满足查询中的条件。</p></li><li><p>若数据库中只包含成功事务提交的结果，则此数据库就称为处于(一致)状态。</p></li><li><p>ACCESS的字段属性，定义字段默认值的含义是该字段值不允许为空。</p></li><li><p>SQL结构化查询语言，是一种数据库查询和<strong>程序设计语言</strong>，用于存取数据以及查询、更新和管理关系数据库系统。</p></li><li><p>规范化过程主要为克服数据库逻辑结构中的插入异常、删除异常以及（冗余度大）的缺陷。</p></li><li><p>关于oracle系统进程和作用的描述：</p><ul><li>数据写进程(dbwr)：负责将更改的数据从数据库缓冲区高速缓存写入数据文件</li><li>监控进程(pmon) ：负责在一个 Oracle 进程失败时清理资源</li><li>归档进程(arcn) ：在每次日志切换时把已满的日志组进行备份或归档</li><li>系统监控(smon) ：检查数据库的一致性，如有必要还会在数据库打开时启动数据库的恢复</li></ul></li><li><p>概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体-联系模型。</p></li><li><p>数据库技术的根本目标是要解决数据共享的问题。</p></li><li><p>ORDB（对象关系数据库）中，同类元素的无序集合，并且允许一个成员可多次出现，称为多集类型。</p><blockquote><p>复合类型有下列五种: </p><p>1.结构类型:  不同类型元素的有序集合。 </p><p>2.集合类型:  相同类型元素的无序集合，并且所有的元素必须是不同的。 </p><p>3.数组类型:  同类元素的有序集合。 </p><p>4.多集类型:  同类元素的无序集合并且允许有重复的元素。 </p><p>(5.列表类型:  类型相同并且允许有重复的元素的有序集合。)</p></blockquote></li><li><p>数据库管理系统的主要功能是定义数据库。</p></li><li><p>在使用left jion时，on和where条件的区别如下： </p><ul><li>on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。</li><li>where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li></ul></li></ol><h2 id="四星题"><a href="#四星题" class="headerlink" title="四星题"></a>四星题</h2><ol><li><p>约束主要有一下几种:</p><ul><li>NOT NULL : 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE : 控制字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控制字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: FOREIGN KEY 约束用于预防破坏表之间连接的动作，FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li><li>DEFAULT: 用于设置新记录的默认值。</li></ul></li><li><p>共享锁（S锁）：读锁，可查看但无法修改和删除，已加该锁则其他事务只能加S锁；<br>排他锁（X锁）：写锁、独占锁，可写可读，已加该锁则其他事务不能再加任何类型的锁。</p></li><li><p>RDBMS 是SQL的基础，同样也是所有现代数据库系统的基础，比如MS   SQL Server, IBM DB2, Oracle, MySQL以及Microsoft Access。</p><p>hadoop是分布式数据库。</p></li><li><blockquote><p>Access的数据库对象：<br>1、表，主要用于存储数据。<br>2、查询，主要用于提取数据。<br>3、窗体，用户与程序的交互。<br>4、报表，主要用于展示数据。<br>5、页，主要用于数据共享。<br>6、宏，用于自动化完成。</p></blockquote></li><li><p>候选码中属性称为主属性。</p></li><li><p>数据流程图（DFD）是用于描述结构化方法中（需求分析）阶段的工具。</p></li><li><p>sql注入中使用延时注入时常用的语句：</p><table><thead><tr><th>数据库</th><th>延时注入语句</th></tr></thead><tbody><tr><td>MySQL</td><td>1. benchmark(100000000,md5(1))   2. sleep(5)</td></tr><tr><td>Postgresql</td><td>1. pg_sleep(5)   2. generate_series(1,10000)</td></tr><tr><td>Microsoft Sql Server</td><td>waitfor delay ‘0:0:5’</td></tr></tbody></table></li><li><p>事务是 DBMS 的基本单位，它是用户定义的一组逻辑一致的程序序列。 </p></li><li><ul><li>左联结，返回左表中所有记录及右表中联结字段相同的记录。</li><li>同理，右联结，返回右表中所有纪录及左表中联结字段相同的记录。</li><li>内部联结，只返回两个表联结字段相同的记录。</li></ul><blockquote><p>A INNER JOIN B：返回A和B中符合on条件式的记录</p><p>A LEFT JOIN B:返回A中的所有记录和B中符合on条件式的记录</p><p>A RIGHT JOIN B：返回B中的所有记录和A中符合on条件式的记录</p></blockquote></li><li><p>关系规范化中的4个问题：</p><ul><li>数据冗余，浪费很大的存储空间。</li><li>更新异常，由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。</li><li>插入异常，应该插入的数据未被插入</li><li>删除异常，不该删除数据的被删除</li></ul></li><li><p>HAVING子句中应后跟（组条件表达式）。</p></li><li><p>在进行数据库逻辑设计时，可将E-R图中的属性表示为关系模式的属性，实体表示为元组，实体集表示为关系，联系表示为关系。</p><table><thead><tr><th>E-R图</th><th>关系模式</th></tr></thead><tbody><tr><td>属性</td><td>属性</td></tr><tr><td>实体</td><td>元组</td></tr><tr><td>实体集</td><td>关系</td></tr><tr><td>联系</td><td>关系</td></tr></tbody></table></li><li><p>关系型数据库：<br>Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL<br>非关系型数据库：<br>NoSql、Cloudant、MongoDb、redis、HBase</p></li></ol><h1 id="Over"><a href="#Over" class="headerlink" title="Over"></a>Over</h1><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><pre><code>原文档丢失了，恢复回来的就只有这些了。当文档内容被自己亲手覆盖，真的是心痛到无法呼吸，差点就自闭了。想剁了自己的右手，是他点击了“确定”，蓝瘦、香菇。一周的心血毁于一旦，也让我也体会到了，在工作中，一定要细心，有些操作是无法挽回的，造成的后果是可怕的。在细心工作中逐步提高效率，细心、安全是前提。</code></pre>]]></content>
    
    
    <summary type="html">牛客网数据库刷题笔记</summary>
    
    
    
    <category term="刷题" scheme="https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Eclipse、spring插件及反编译插件安装</title>
    <link href="https://born2do.github.io/2021/05/03/Eclipse%E3%80%81spring%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <id>https://born2do.github.io/2021/05/03/Eclipse%E3%80%81spring%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</id>
    <published>2021-05-02T23:18:41.000Z</published>
    <updated>2021-05-02T23:19:13.680Z</updated>
    
    <content type="html"><![CDATA[<p>请提前下载好必要文件，该文主要介绍离线安装。</p><h2 id="Eclipse安装"><a href="#Eclipse安装" class="headerlink" title="Eclipse安装"></a>Eclipse安装</h2><p>根据自己的操作系统以及想要的eclipse版本，在eclipse官网下载<strong>软件压缩包</strong>。</p><p>下载地址：<a href="https://www.eclipse.org/downloads/packages/">https://www.eclipse.org/downloads/packages/</a></p><p>下载完成后，解压到本地磁盘即可直接使用。</p><p><img src="https://i.loli.net/2021/05/03/IvtrMd6i7m9aCUX.png" alt="image-20201104234110429.png"></p><h2 id="反编译插件安装"><a href="#反编译插件安装" class="headerlink" title="反编译插件安装"></a>反编译插件安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>地址：<a href="http://java-decompiler.github.io/">http://java-decompiler.github.io/</a></p><p><img src="https://i.loli.net/2021/05/03/r9BcFoMmjVaSlOY.png" alt="image-20201104234747246.png"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p> 将下载好的压缩包解压缩。</p></li><li><p> 打开eclipse，Help-&gt;Install New Software…-&gt;add。</p></li></ol><p><img src="https://i.loli.net/2021/05/03/3VDnKICAtONk8gF.png" alt="image-20201105000155228.png"></p><ol start="3"><li> 选中插件，点击“next”。</li></ol><p><img src="https://i.loli.net/2021/05/03/nEpACzIhPtTWc8D.png" alt="image-20201105000552816.png"></p><ol start="4"><li><p> 一直点击下一步即可。最终安装完成后会提醒重启eclipse，重启就好。</p></li><li><p> 重启后，再次确认jd插件安装成功。Window-&gt;Preference-&gt;Java-&gt;Decompiler，出现JD-eclipse说明安装成功。</p></li></ol><p><img src="https://i.loli.net/2021/05/03/D3beYJFyrBMRHiC.png" alt="image-20201105001352871.png"></p><ol start="6"><li> 最后，进行查看器默认设置修改。直接在左上角搜索“File Associations”，选中“.class without resource”，点击下方的add，找到“JD Class File Viewer”，确认即可。</li></ol><p><img src="https://i.loli.net/2021/05/03/xshNMVK1DqpAlnU.png" alt="image-20201105002039009.png"></p><p><img src="https://i.loli.net/2021/05/03/hbkgIVRQoWfsA7S.png" alt="image-20201105002115734.png"></p><p><img src="https://i.loli.net/2021/05/03/3pDare5SVy62Gqn.png" alt="image-20201105002234975.png"></p><ol start="7"><li> 至此，反编译插件安装完成。</li></ol><h2 id="Spring插件安装"><a href="#Spring插件安装" class="headerlink" title="Spring插件安装"></a>Spring插件安装</h2><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><ol><li> 查看eclipse版本。Help-&gt;About Eclipse IDE，我的版本是4.14.0。</li></ol><p><img src="https://i.loli.net/2021/05/03/xrbAliEIgGq48uF.png" alt="image-20201106185356251.png"></p><ol start="2"><li> <a href="https://github.com/spring-projects/toolsuite-distribution/wiki/Spring-Tool-Suite-3">https://github.com/spring-projects/toolsuite-distribution/wiki/Spring-Tool-Suite-3</a>，找到版本对应的Spring Tool Suite 3，并下载。</li></ol><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><p>步骤与反编译插件的安装步骤一致，但是要注意，需要联网，安装时会从网络上再次更新下载部分组件，没有联网的，即使安装完了，也是不完整的，无法使用。</p>]]></content>
    
    
    <summary type="html">Eclipse、spring插件及反编译插件安装</summary>
    
    
    
    <category term="软件安装" scheme="https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
  </entry>
  
  <entry>
    <title>Intellij配置</title>
    <link href="https://born2do.github.io/2021/05/03/Intellij%E9%85%8D%E7%BD%AE/"/>
    <id>https://born2do.github.io/2021/05/03/Intellij%E9%85%8D%E7%BD%AE/</id>
    <published>2021-05-02T23:17:46.000Z</published>
    <updated>2021-05-02T23:18:08.427Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Intellij配置"><a href="#Intellij配置" class="headerlink" title="Intellij配置"></a>Intellij配置</h2><h3 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h3><p>File | Settings | Appearance &amp; Behavior | Appearance</p><p><img src="https://i.loli.net/2021/05/03/LD7BZTWelOYjAhv.png" alt="Intellij配置-主题设置.png"></p><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><p>File | Settings | Editor | Font</p><p><img src="https://i.loli.net/2021/05/03/9ECUankNJyuLxq4.png" alt="Intellij配置-字体设置.png"></p><h3 id="快捷键设置"><a href="#快捷键设置" class="headerlink" title="快捷键设置"></a>快捷键设置</h3><p>File | Settings | Keymap</p><h3 id="大小写敏感设置"><a href="#大小写敏感设置" class="headerlink" title="大小写敏感设置"></a>大小写敏感设置</h3><p>File | Settings | Editor | General | Code Completion</p><p>关闭大小写敏感。</p><h3 id="MAVEN设置"><a href="#MAVEN设置" class="headerlink" title="MAVEN设置"></a>MAVEN设置</h3><h3 id="文件编码格式设置"><a href="#文件编码格式设置" class="headerlink" title="文件编码格式设置"></a>文件编码格式设置</h3><p>File | Settings | Editor | File Encodings</p>]]></content>
    
    
    <summary type="html">Intellij配置</summary>
    
    
    
    <category term="软件安装" scheme="https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
  </entry>
  
  <entry>
    <title>【MySQL】The MySQL server is running with the --skip-grant-tables option so it cannot execute this ...</title>
    <link href="https://born2do.github.io/2021/05/02/%E3%80%90MySQL%E3%80%91The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/"/>
    <id>https://born2do.github.io/2021/05/02/%E3%80%90MySQL%E3%80%91The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/</id>
    <published>2021-05-02T00:04:45.000Z</published>
    <updated>2021-05-02T00:05:20.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>新建数据库用户：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user test identified by &#39;password&#39;;</span><br></pre></td></tr></table></figure><p>然后便报错：</p><p>“ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement”</p><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p>刷新权限表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>再重新新建用户即可。</p>]]></content>
    
    
    <summary type="html">【MySQL】The MySQL server is running with the --skip-grant-tables option so it cannot execute this ...</summary>
    
    
    
    <category term="MySQL" scheme="https://born2do.github.io/categories/MySQL/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Java中子类可以继承父类所有的属性和方法</title>
    <link href="https://born2do.github.io/2021/05/02/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/"/>
    <id>https://born2do.github.io/2021/05/02/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/</id>
    <published>2021-05-02T00:03:51.000Z</published>
    <updated>2021-05-02T00:04:12.722Z</updated>
    
    <content type="html"><![CDATA[<p>某些书本表明“子类只能继承父类的非私有属性和方法”，然而事实并非如此，实际上“Java中子类可以继承父类所有的属性和方法”，只不过因为私有的原因，子类不能调用父类的私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;张三&quot;</span>;<span class="comment">//私有属性</span></span><br><span class="line">    <span class="keyword">private</span> String sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;姓名：&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;性别：&quot;</span>+sex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">&quot;is speaking!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestJava</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Child c = <span class="keyword">new</span> Child();</span><br><span class="line">c.tell();<span class="comment">// tell方法是可以用的</span></span><br><span class="line"><span class="comment">// c.speak();//报错，父类的私有方法不可见</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到测试类中即使没有给Child类对象的属性进行赋值，tell方法依旧是可用的。如果Child类中没有继承父类的私有属性，那么tell方法应该会报错。由此得出的结论是，子类会继承父类的所有东西，而修饰符只是影响属性或者方法对外是否可见。</p><p>Java官方文档的解释：子类不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的。</p>]]></content>
    
    
    <summary type="html">【Java】Java中子类可以继承父类所有的属性和方法</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://born2do.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java】String、StringBuffer、StringBuilder有什么区别</title>
    <link href="https://born2do.github.io/2021/05/01/%E3%80%90Java%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/05/01/%E3%80%90Java%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-30T23:09:06.000Z</published>
    <updated>2021-04-30T23:10:26.429Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>在Java中，String类用于用于创建和操作字符串。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，在这里不作赘述。但值得注意的是，<strong>String 类是不可改变的</strong>，所以你一旦创建了 String 对象，那它的值就无法改变了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;Google&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br><span class="line"></span><br><span class="line">s = <span class="string">&quot;Baidu&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s = &quot;</span> + s);</span><br></pre></td></tr></table></figure><p>上段代码的运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Google</span><br><span class="line">s = Baidu</span><br></pre></td></tr></table></figure><p>看似String类是可以改变的，那为什么又说String类是不可改变的呢？</p><p>答：在这里的变量s，并非String对象，而是指向对象地址的引用。变量s存储在栈空间，而真正的对象存储在堆空间。</p><p><img src="https://i.loli.net/2021/05/01/GWVxvjSqowcfyMg.png" alt="String、StringBuffer、StringBuilder有什么区别.png"></p><p>在执行上图中的两句代码时，堆空间实际上创建了两个对象，变量s改变的是内存中对象的地址，第一个对象的内容并未发生改变，最后也会被垃圾回收机制回收内存。所以说，String 类是不可改变的，你一旦创建了 String 对象，那它的值就无法改变了。对了，String 是被 final 修饰的，他的长度是不可变的。</p><h4 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h4><p>当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。</p><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p><p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p><p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p><h4 id="三者在执行速度方面的比较："><a href="#三者在执行速度方面的比较：" class="headerlink" title="三者在执行速度方面的比较："></a>三者在执行速度方面的比较：</h4><p>StringBuilder &gt; StringBuffer &gt; String</p><h4 id="如何正确地、适当地使用这三个类："><a href="#如何正确地、适当地使用这三个类：" class="headerlink" title="如何正确地、适当地使用这三个类："></a>如何正确地、适当地使用这三个类：</h4><ul><li><p>  如果要求字符串<strong>不可变</strong>，操作少量数据，那么应该选择String类</p></li><li><p>  如果需要字符串<strong>可变</strong>并且是<strong>线程安全</strong>的，操作大量数据，那么应选择StringBuffer类</p></li><li><p>  如果要求字符串<strong>可变</strong>并且<strong>不存在线程安全问题</strong>，操作大量数据，那么应选择StringBuilder类</p></li></ul>]]></content>
    
    
    <summary type="html">【Java】String、StringBuffer、StringBuilder有什么区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="String" scheme="https://born2do.github.io/tags/String/"/>
    
    <category term="StringBuffer" scheme="https://born2do.github.io/tags/StringBuffer/"/>
    
    <category term="StringBuilder" scheme="https://born2do.github.io/tags/StringBuilder/"/>
    
  </entry>
  
  <entry>
    <title>解决CHM文件打不开或者打开以后显示空白</title>
    <link href="https://born2do.github.io/2021/05/01/%E8%A7%A3%E5%86%B3CHM%E6%96%87%E4%BB%B6%E6%89%93%E4%B8%8D%E5%BC%80%E6%88%96%E8%80%85%E6%89%93%E5%BC%80%E4%BB%A5%E5%90%8E%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/"/>
    <id>https://born2do.github.io/2021/05/01/%E8%A7%A3%E5%86%B3CHM%E6%96%87%E4%BB%B6%E6%89%93%E4%B8%8D%E5%BC%80%E6%88%96%E8%80%85%E6%89%93%E5%BC%80%E4%BB%A5%E5%90%8E%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/</id>
    <published>2021-04-30T23:04:57.000Z</published>
    <updated>2021-04-30T23:05:13.755Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>CHM是英语“Compiled Help Manual”的简写，即“已编译的帮助文件”。CHM是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。</p></blockquote><p>从网络上下载了chm格式的帮助文档，但是无法打开。经过一番搜索，完美解决。解决方式如下：</p><p>文件之所以打不开或者打开后显示空白，是因为该文件被加锁了，解锁即可。</p><p>右键chm文件-&gt;属性-&gt;勾选“解除锁定”-&gt;应用即可。</p>]]></content>
    
    
    <summary type="html">解决CHM文件打不开或者打开以后显示空白</summary>
    
    
    
    <category term="error" scheme="https://born2do.github.io/categories/error/"/>
    
    
  </entry>
  
  <entry>
    <title>【Windows】Windows环境生成树形目录结构</title>
    <link href="https://born2do.github.io/2021/04/30/%E3%80%90Windows%E3%80%91Windows%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>https://born2do.github.io/2021/04/30/%E3%80%90Windows%E3%80%91Windows%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</id>
    <published>2021-04-30T10:03:37.000Z</published>
    <updated>2021-04-30T10:04:35.671Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">以图形显示驱动器或路径的文件夹结构。</span><br><span class="line"></span><br><span class="line"><span class="built_in">TREE</span> [drive:][<span class="built_in">path</span>] [/F] [/A]</span><br><span class="line"></span><br><span class="line">   /F   显示每个文件夹中文件的名称。</span><br><span class="line">   /A   使用 ASCII 字符，而不使用扩展字符。</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tree</span> D:\backup\软件 /F &gt; <span class="built_in">tree</span>.txt</span><br></pre></td></tr></table></figure><p>执行tree命令，并将结果重定向到 tree.txt 。</p><p><img src="https://i.loli.net/2021/04/30/sQPW8chavRdo6wG.png" alt="Windows环境生成树形目录结构-tree.png"></p>]]></content>
    
    
    <summary type="html">【Windows】Windows环境生成树形目录结构</summary>
    
    
    
    <category term="Windows" scheme="https://born2do.github.io/categories/Windows/"/>
    
    
    <category term="树形目录结构" scheme="https://born2do.github.io/tags/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>解决从github下载项目速度过慢或下载失败</title>
    <link href="https://born2do.github.io/2021/04/30/%E8%A7%A3%E5%86%B3%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/"/>
    <id>https://born2do.github.io/2021/04/30/%E8%A7%A3%E5%86%B3%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/</id>
    <published>2021-04-30T10:02:31.000Z</published>
    <updated>2021-04-30T10:03:10.628Z</updated>
    
    <content type="html"><![CDATA[<p>有时候从github上下载个项目或是文件，几兆大小却花费十几分钟，速度低到极致。遇上个稍微大点的项目，运气好的下载半天好歹给你下载下来了，运气差点的下载到一半甚至90%就给你中止了，提示你网络已断开，你说气人不。</p><p>说到底还是因为那堵墙，不做过多评论。</p><p>直接来干货：将存储于github上的项目克隆到gitee上即可。</p><p>Gitee （中文名：码云 ，原名 Git@OSC ）是开源中国推出的基于 Git 的代码托管服务。因为服务器在国内，速度可不是github能比拟的。</p><p>1.打开码云（<a href="https://gitee.com/">https://gitee.com/</a>），注册并登录。</p><p>2.创建仓库。</p><p><img src="https://i.loli.net/2021/04/30/mRePXTF1uhx5t7i.png" alt="create.png"></p><p>3.在新建仓库页选择 “导入已有仓库”。</p><p><img src="https://i.loli.net/2021/04/30/95ofMkTAxSKu1YJ.png" alt="import.png"></p><p>4.复制需要下载的github项目的链接，如<a href="https://github.com/lehaifeng/T-GCN.git">https://github.com/lehaifeng/T-GCN.git</a>放到导入已有仓库中。</p><p><img src="https://i.loli.net/2021/04/30/yGnUFbV4MpZmulh.png" alt="importFromGitHub.png"></p><p>5.点击创建，然后下载即可。</p><p><img src="https://i.loli.net/2021/04/30/8EctPuBlemkMfbG.png" alt="download.png"></p><p>说明：有些项目在gitee上已经有过的，克隆会比较快，但如果是新项目，会稍稍耗时，但总比我们自己下载要来得快，耐心等待即可。</p><p>图片来自：<a href="https://www.cnblogs.com/USTC-ZCC/p/11163292.html">https://www.cnblogs.com/USTC-ZCC/p/11163292.html</a></p>]]></content>
    
    
    <summary type="html">解决从github下载项目速度过慢或下载失败</summary>
    
    
    
    <category term="下载" scheme="https://born2do.github.io/categories/%E4%B8%8B%E8%BD%BD/"/>
    
    
    <category term="github" scheme="https://born2do.github.io/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>localhost、127.0.0.1和本机IP之间的区别</title>
    <link href="https://born2do.github.io/2021/04/29/localhost%E3%80%81127-0-0-1%E5%92%8C%E6%9C%AC%E6%9C%BAIP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/29/localhost%E3%80%81127-0-0-1%E5%92%8C%E6%9C%AC%E6%9C%BAIP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-29T12:44:10.000Z</published>
    <updated>2021-04-29T12:44:36.022Z</updated>
    
    <content type="html"><![CDATA[<p>1、localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 IPv6 后，它同时还指向 IPv6 的地址 [::1] 。</p><p>2、127.0.0.1 是一个IP地址，这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。</p><p>3、本机IP，确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPv4，IPX/Apple Tak消失了，IPv6还没普及，所以通常仅指IP地址甚至IPv4地址。</p><p>4、一般情况下，localhost指向127.0.0.1，无需联网，供本机访问；而本机IP需要联网，供本机或外部访问。</p>]]></content>
    
    
    <summary type="html">localhost、127.0.0.1和本机IP之间的区别</summary>
    
    
    
    <category term="IP" scheme="https://born2do.github.io/categories/IP/"/>
    
    
  </entry>
  
</feed>
