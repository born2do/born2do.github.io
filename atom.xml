<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenHY的个人博客</title>
  
  
  <link href="https://born2do.github.io/atom.xml" rel="self"/>
  
  <link href="https://born2do.github.io/"/>
  <updated>2021-04-16T09:41:25.827Z</updated>
  <id>https://born2do.github.io/</id>
  
  <author>
    <name>chenhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C语言零碎知识</title>
    <link href="https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    <id>https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/</id>
    <published>2021-04-16T09:41:01.000Z</published>
    <updated>2021-04-16T09:41:25.827Z</updated>
    
    <content type="html"><![CDATA[<h2 id="printf-格式字符"><a href="#printf-格式字符" class="headerlink" title="printf()格式字符"></a>printf()格式字符</h2><table><thead><tr><th>printf()格式字符</th><th>英文</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>character</td><td>以字符形式输出单个字符</td></tr><tr><td>%s</td><td>string</td><td>输出一个字符串</td></tr><tr><td>%d</td><td>decimal</td><td>以带符号十进制整数输出</td></tr><tr><td>%f</td><td>float</td><td>以小数形式输出浮点数（6位小数）</td></tr><tr><td>%e</td><td>exponent</td><td>以标准指数形式输出（6位小数）</td></tr><tr><td>%g</td><td></td><td>选用%f，%e中输出宽度较小的一种格式</td></tr><tr><td>%o</td><td>octal</td><td>以八进制无符号整数输出（无前导0）</td></tr><tr><td>%x</td><td>hex</td><td>以十六进制无符号整数输出（无前导0x）</td></tr><tr><td>%u</td><td>unsigned</td><td>以十进制无符号整数输出</td></tr></tbody></table><h2 id="printf-的格式修饰符"><a href="#printf-的格式修饰符" class="headerlink" title="printf()的格式修饰符"></a>printf()的格式修饰符</h2><table><thead><tr><th>printf()格式修饰符</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>表示数据占用的最小宽度。数据宽度大于m，按实际宽度输出；数据宽度小于m时，补空格。</td></tr><tr><td>n</td><td>对实数表示输出n位小数。对字符串表示最多输出的字符个数。</td></tr><tr><td>l</td><td>长整型整数，加在d、o、x、u前</td></tr><tr><td>L</td><td>long double型数，加在f、e、g前</td></tr><tr><td>-</td><td>改变输出内容的对齐方式为左对齐，默认为右对齐</td></tr></tbody></table><h2 id="scanf-的格式字符"><a href="#scanf-的格式字符" class="headerlink" title="scanf()的格式字符"></a>scanf()的格式字符</h2><table><thead><tr><th>scanf()格式字符</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>以字符形式输入单个字符</td></tr><tr><td>%s</td><td>输入字符串,以非空字符开始,遇第一个空白字符结束</td></tr><tr><td>%d</td><td>以带符号十进制形式输入整型数据</td></tr><tr><td>%f</td><td>以小数形式输入浮点数</td></tr><tr><td>%e</td><td>以标准指数形式输入</td></tr><tr><td>%o</td><td>以八进制无符号形式输入（无前导0）</td></tr><tr><td>%x</td><td>以十六进制无符号形式输入（无前导0x）</td></tr></tbody></table><h2 id="scanf-的格式修饰符"><a href="#scanf-的格式修饰符" class="headerlink" title="scanf()的格式修饰符"></a>scanf()的格式修饰符</h2><table><thead><tr><th>scanf()格式修饰符</th><th>含义</th></tr></thead><tbody><tr><td>m</td><td>表示数据占用的宽度</td></tr><tr><td>l</td><td>加在d、o、x、u前：输入长整型；加在f、e 前：输入双精度型</td></tr><tr><td>L</td><td>加在f、e 前：输入long double型</td></tr><tr><td>h</td><td>加在d、o、x 前:输入短整型</td></tr><tr><td>*</td><td>本输入项在读入后不赋给相应的变量</td></tr></tbody></table><h2 id="文件打开方式（mode）："><a href="#文件打开方式（mode）：" class="headerlink" title="文件打开方式（mode）："></a>文件打开方式（mode）：</h2><p>①对应文本文件<br>“r”    只读    必须是已存在的文件<br>“w”    只写    不论该文件是否存在，都新建一个文件<br>“a”    追加    向文本文件尾增加数据，该文件必须存在<br>“r+”   读写    打开一个已存在的文件，用于读写<br>“w+”  读写    建立一个新文件，可读可写<br>“a+”   读写    向文件尾追加数据，也可读<br>②对应二进制文件<br>“rb”<br>“wb”<br>“ab”<br>“rb+”<br>“wb+”<br>“ab+”</p>]]></content>
    
    
    <summary type="html">C语言零碎知识</summary>
    
    
    
    <category term="C语言" scheme="https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="零碎知识" scheme="https://born2do.github.io/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言关键字</title>
    <link href="https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-04-16T09:38:58.000Z</published>
    <updated>2021-04-16T09:39:22.807Z</updated>
    
    <content type="html"><![CDATA[<p>由ANSI标准定义的C语言关键字共32个 : </p><p>auto  double  int  struct  break  else  long  switch</p><p>case  enum  register  typedef  char  extern  return  union</p><p>const  float  short  unsigned  continue  for  signed  void</p><p>default  goto  sizeof  volatile  do  if  while  static </p><p>根据关键字的作用，可以将关键字分为数据类型关键字和流程控制关键字两大类。</p><p>1． 数据类型关键字</p><p>A基本数据类型（5个）</p><p>void ：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果</p><p>char ：字符型类型数据，属于整型数据的一种</p><p>int ：整型数据，通常为编译器指定的机器字长</p><p>float ：单精度浮点型数据，属于浮点数据的一种</p><p>double ：双精度浮点型数据，属于浮点数据的一种</p><p>B 类型修饰关键字（4个）</p><p>short ：修饰int，短整型数据，可省略被修饰的int。</p><p>long ：修饰int，长整形数据，可省略被修饰的int。</p><p>signed ：修饰整型数据，有符号数据类型</p><p>unsigned ：修饰整型数据，无符号数据类型</p><p>C 复杂类型关键字（5个）</p><p>struct ：结构体声明</p><p>union ：共用体声明</p><p>enum ：枚举声明</p><p>typedef ：声明类型别名</p><p>sizeof ：得到特定类型或特定类型变量的大小</p><p>D 存储级别关键字（6个）</p><p>auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配</p><p>static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部</p><p>register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数</p><p>extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的韵蟮囊桓觥耙?谩?</p><p>const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变）</p><p>volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值</p><p>2． 流程控制关键字</p><p>A 跳转结构（4个）</p><p>return ：用在函数体中，返回特定值（或者是void值，即不返回值）</p><p>continue ：结束当前循环，开始下一轮循环</p><p>break ：跳出当前循环或switch结构</p><p>goto ：无条件跳转语句</p><p>B 分支结构（5个）</p><p>if ：条件语句</p><p>else ：条件语句否定分支（与if连用）</p><p>switch ：开关语句（多重分支语句）</p><p>case ：开关语句中的分支标记</p><p>default ：开关语句中的“其他”分治，可选。</p><p>C 循环结构（3个）</p><p>for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件</p><p>do ：do循环结构，do 1 while(2); 的执行顺序是 1-&gt;2-&gt;1…循环，2为循环条件</p><p>while ：while循环结构，while(1) 2; 的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件</p><p>以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。</p>]]></content>
    
    
    <summary type="html">C语言关键字</summary>
    
    
    
    <category term="C语言" scheme="https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="关键字" scheme="https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>XML初识</title>
    <link href="https://born2do.github.io/2021/04/14/XML%E5%88%9D%E8%AF%86/"/>
    <id>https://born2do.github.io/2021/04/14/XML%E5%88%9D%E8%AF%86/</id>
    <published>2021-04-14T14:08:16.000Z</published>
    <updated>2021-04-14T14:09:19.590Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-XML"><a href="#1-什么是-XML" class="headerlink" title="1.什么是 XML?"></a>1.什么是 XML?</h3><ul><li><p>  XML 指可扩展标记语言（EXtensible Markup Language）</p></li><li><p>  XML 是一种标记语言，很类似 HTML</p></li><li><p>  XML 的设计宗旨是传输数据，而非显示数据</p></li><li><p>  XML 标签没有被预定义。需要自行定义标签。</p></li><li><p>  XML 被设计为具有自我描述性。</p></li><li><p>  XML 是 W3C 的推荐标准</p></li></ul><h3 id="2-XML-与-HTML-的主要差异"><a href="#2-XML-与-HTML-的主要差异" class="headerlink" title="2.XML 与 HTML 的主要差异"></a>2.XML 与 HTML 的主要差异</h3><ul><li><p>  XML 不是 HTML 的替代。</p></li><li><p>XML 和 HTML 为不同的目的而设计：</p><ul><li><p>  XML 被设计为传输和存储数据，其焦点是数据的内容。</p></li><li><p>  HTML 被设计用来显示数据，其焦点是数据的外观。</p></li><li><p>  HTML 旨在显示信息，而 XML 旨在传输信息。</p></li></ul></li></ul><h3 id="3-没有任何行为的-XML"><a href="#3-没有任何行为的-XML" class="headerlink" title="3.没有任何行为的 XML"></a>3.没有任何行为的 XML</h3><p>XML 是不作为的。  也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。  下面是 John 写给 George 的便签，存储为 XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>George<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>John<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget the meeting!<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的这条便签具有自我描述性。它拥有标题以及留言，同时包含了发送者和接受者的信息。  但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。</p><h3 id="4-XML-仅仅是纯文本"><a href="#4-XML-仅仅是纯文本" class="headerlink" title="4.XML 仅仅是纯文本"></a>4.XML 仅仅是纯文本</h3><p>XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。  不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。</p><h3 id="5-通过-XML-你可以发明自己的标签"><a href="#5-通过-XML-你可以发明自己的标签" class="headerlink" title="5.通过 XML 你可以发明自己的标签"></a>5.通过 XML 你可以发明自己的标签</h3><p>上例中的标签没有在任何 XML 标准中定义过（比如 <code>&lt;to&gt;</code> 和 <code>&lt;from&gt;</code>）。这些标签是由文档的创作者发明的。  这是因为 XML 没有预定义的标签。  在 HTML 中使用的标签（以及 HTML 的结构）是预定义的。HTML 文档只使用在 HTML 标准中定义过的标签（比如 <code>&lt;p&gt;</code> 、<code>&lt;h1&gt;</code> 等等）。  XML 允许创作者定义自己的标签和自己的文档结构。</p><h3 id="6-XML-不是对-HTML-的替代"><a href="#6-XML-不是对-HTML-的替代" class="headerlink" title="6.XML 不是对 HTML 的替代"></a>6.XML 不是对 HTML 的替代</h3><p>XML 是对 HTML 的补充。  XML 不会替代 HTML，理解这一点很重要。在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。  对 XML 最好的描述是：  XML 是独立于软件和硬件的信息传输工具。</p><p>参考文章：<a href="http://www.w3school.com.cn/xml/xml_intro.asp">http://www.w3school.com.cn/xml/xml_intro.asp</a></p>]]></content>
    
    
    <summary type="html">XML初识</summary>
    
    
    
    <category term="XML" scheme="https://born2do.github.io/categories/XML/"/>
    
    
    <category term="XML" scheme="https://born2do.github.io/tags/XML/"/>
    
  </entry>
  
  <entry>
    <title>【Java】JSF中Bean的作用域</title>
    <link href="https://born2do.github.io/2021/04/14/%E3%80%90Java%E3%80%91JSF%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>https://born2do.github.io/2021/04/14/%E3%80%90Java%E3%80%91JSF%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2021-04-14T14:02:55.000Z</published>
    <updated>2021-04-14T14:03:23.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSF-2-x"><a href="#JSF-2-x" class="headerlink" title="JSF 2.x"></a>JSF 2.x</h1><p>从JSF 2.x开始，有4个Bean范围：<br>@ViewScoped<br>@RequestScoped<br>@SessionScoped<br>@ApplicationScoped</p><p>ViewScope： View范围是在JSF 2.0中添加的。 重新显示相同的JSF页面时，视图范围内的bean仍然存在。 （JSF规范将术语“视图”用于JSF页面。）一旦用户导航到另一个页面，Bean就会超出范围。</p><p>RequestScope：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。</p><p>SessionScoped：会话范围从建立会话到会话终止一直存在。 如果Web应用程序在HttpSession对象上调用invalidate方法，或者会话超时，则会话终止。</p><p>ApplicationScope：应用程序作用域在Web应用程序的整个过程中一直存在。 该范围在所有请求和所有会话之间共享。 如果应在Web应用程序的所有实例之间共享单个bean，则将托管bean放入应用程序范围。 Bean是在应用程序的任何用户首次请求时构造的，并且一直保持活动状态，直到从应用程序服务器中删除Web应用程序为止。</p><p>根据需要选择范围。</p><h1 id="JSF-2-3"><a href="#JSF-2-3" class="headerlink" title="JSF 2.3"></a>JSF 2.3</h1><p>从JSF 2.3开始，已弃用javax.faces.bean包中定义的所有bean作用域，以使作用域与CDI对齐。 此外，它们仅在您的bean使用@ManagedBean注释时才适用。 如果您使用的JSF版本低于2.3，请参考最后的遗留答案。</p><p>从JSF 2.3开始，这里是可以在JSF Backing Bean上使用的范围：</p><ol><li><p>@javax.enterprise.context.ApplicationScoped ：应用程序作用域在Web应用程序的整个持续时间内一直存在。 该范围在所有请求和所有会话之间共享。 当您拥有整个应用程序的数据时，这很有用。</p></li><li><p>@javax.enterprise.context.SessionScoped ：会话范围从建立会话的时间一直持续到会话终止为止。 会话上下文在同一HTTP会话中发生的所有请求之间共享。 当您不想为特定会话保存特定客户端的数据时，此功能很有用。</p></li><li><p>@javax.enterprise.context.ConversationScoped ：对话范围随着bean的存在而保持为日志。 范围提供2种方法： Conversation.begin()和Conversation.end() 。 这些方法应显式调用，以开始或结束Bean的生命。</p></li><li><p>@javax.enterprise.context.RequestScoped ：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。</p></li><li><p>@javax.faces.flow.FlowScoped ：只要Flow存在，Flow范围就会持续存在。 流可以定义为一组包含页面（或视图）的页面，这些页面定义了一个工作单元。 只要用户在Flow中进行导航，作用域就可以激活。</p></li><li><p>@javax.faces.view.ViewScoped ：视图范围内的Bean在重新显示同一JSF页面时仍然存在。 一旦用户导航到另一个页面，Bean就会超出范围。</p></li></ol><p>转载自 <a href="https://my.oschina.net/u/3797416/blog/3166873">https://my.oschina.net/u/3797416/blog/3166873</a> 。</p>]]></content>
    
    
    <summary type="html">【Java】JSF中Bean的作用域</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="JSF" scheme="https://born2do.github.io/tags/JSF/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Spring中注解可以在哪些地方</title>
    <link href="https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/"/>
    <id>https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/</id>
    <published>2021-04-13T13:13:37.000Z</published>
    <updated>2021-04-13T13:55:13.291Z</updated>
    
    <content type="html"><![CDATA[<p>Spring中的注解根据所在位置主要分为两类：</p><p>类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。</p><p>类内部的注解：如@Autowired、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。</p><p>正常情况下，接口以及抽象类文件中是不能使用注解的。<br>因为spring的原理是启动服务器时读取配置文件，取得类名后利用反射机制在spring上下文中生成一个单例的对象，由spring注入属性并维护此对象的状态，抽象类/接口在反射生成对象时就已经失败了，spring无法注入，后续的其他操作也将不会进行。</p>]]></content>
    
    
    <summary type="html">【Java】Spring中注解可以在哪些地方</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="注解" scheme="https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Spring项目中相关注解</title>
    <link href="https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
    <id>https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-04-13T13:12:35.000Z</published>
    <updated>2021-04-13T13:13:10.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-声明bean的注解"><a href="#1-声明bean的注解" class="headerlink" title="1.声明bean的注解"></a>1.声明bean的注解</h1><p>@Controller 在表现层使用，控制器（注入服务）<br>用于标注控制层。</p><p>@Service 在业务逻辑层使用，服务（注入dao）<br>用于标注服务层，主要用来进行业务的逻辑处理。</p><p>@Repository 在数据访问层使用，（实现dao访问）<br>用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件。</p><p>@Component 组件，通用的注解方式<br>泛指各种组件，也即当我们的类不属于任何一种归类（@Controller、@Service等）的时候，但我们又要将该类实例化到spring容器中，我们就可以使用@Component来标注这个类。</p><h1 id="2-注入bean的注解"><a href="#2-注入bean的注解" class="headerlink" title="2.注入bean的注解"></a>2.注入bean的注解</h1><p>@Autowired：由Spring提供</p><p>@Inject：由JSR-330提供</p><p>@Resource：由JSR-250提供</p><p>都可以注解在set方法和属性上，推荐注解在属性上。</p><h1 id="3-java配置类相关注解"><a href="#3-java配置类相关注解" class="headerlink" title="3.java配置类相关注解"></a>3.java配置类相关注解</h1><p>@Configuration 声明当前类为配置类，相当于xml形式的Spring配置(类上)</p><p>@Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式(方法上)</p><p>@Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean(类上)</p><p>@ComponentScan 用于对Component进行扫描，相当于xml中的(类上)</p><p>@WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解</p><h1 id="4-切面-AOP-相关注解"><a href="#4-切面-AOP-相关注解" class="headerlink" title="4.切面(AOP)相关注解"></a>4.切面(AOP)相关注解</h1><p>Spring支持AspectJ的注解式切面编程。</p><p>@Aspect 声明一个切面(类上)</p><p>使用@After、@Before、@Around定义建言(advice)，可直接将拦截规则(切点)作为参数。</p><p>@After 在方法执行之后执行(方法上) @Before 在方法执行之前执行(方法上) @Around 在方法执行之前与之后执行(方法上)</p><p>@PointCut 声明切点</p><p>在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持(类上)</p><h1 id="5-Bean的属性支持"><a href="#5-Bean的属性支持" class="headerlink" title="5.@Bean的属性支持"></a>5.@Bean的属性支持</h1><p>@Scope 设置Spring容器如何新建Bean实例(方法上要有@Bean)</p><blockquote><p>其设置类型包括：<br>· Singleton (单例，一个Spring容器中只有一个bean实例，默认模式),<br>· Protetype (每次调用新建一个bean),<br>· Request (web项目中，给每个http request新建一个bean),<br>· Session (web项目中，给每个http session新建一个bean),<br>· GlobalSession(给每一个 global http session新建一个Bean实例)</p></blockquote><p>@StepScope 在Spring Batch中有涉及</p><p>@PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod</p><p>@PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod</p>]]></content>
    
    
    <summary type="html">【Java】Spring项目中相关注解</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="注解" scheme="https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>【Java】在SpringBoot项目中使用单元测试</title>
    <link href="https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2021-04-12T13:47:55.000Z</published>
    <updated>2021-04-12T13:48:33.615Z</updated>
    
    <content type="html"><![CDATA[<p>1.引入单元测试依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>2.使用<br>1）在测试类上添加如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br></pre></td></tr></table></figure><p>2）在测试方法中添加如下注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.test;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import com.example.demo.service.impl.UserServiceImpl01;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    @Autowired</span><br><span class="line">&#x2F;&#x2F;    @Qualifier(&quot;userServiceImpl02&quot;)</span><br><span class="line">    @Resource(type &#x3D; UserServiceImpl01.class)</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，包的引入千万别弄错了。</p>]]></content>
    
    
    <summary type="html">【Java】在SpringBoot项目中使用单元测试</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="单元测试" scheme="https://born2do.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【Java】@Autowired和@Resource</title>
    <link href="https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91-Autowired%E5%92%8C-Resource/"/>
    <id>https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91-Autowired%E5%92%8C-Resource/</id>
    <published>2021-04-12T13:46:48.000Z</published>
    <updated>2021-04-12T13:47:31.558Z</updated>
    
    <content type="html"><![CDATA[<p>@Autowired和@Resource这两个注解最大的区别：</p><ul><li>@Autowired    根据类型注入</li><li>@Resource    根据名称注入</li></ul><p>以上是这两个注解最主要的装配方式，具体使用方式见下方。<br>以下只针对于一个接口有一个或多个实现类的情况进行讨论。没有实现类的情况不讨论，个人觉得自动注入允许为空的情况是十分不安全的，实际开发中也没有太大意义。</p><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><h2 id="1-接口与实现类一一对应"><a href="#1-接口与实现类一一对应" class="headerlink" title="1.接口与实现类一一对应"></a>1.接口与实现类一一对应</h2><p>接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IUserService &#123;</span><br><span class="line">    void say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类01：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service.impl;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl01 implements IUserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;I am UserServiceImpl01.................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.test;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行测试方法，控制台输出“I am UserServiceImpl01……………..”。<br>此时，Spring容器中只有一个IUserService 的实现类UserServiceImpl01 ，byType进行注入时，会自动找到实现类UserServiceImpl01进行注入。从控制台的打印结果我们也可以看出，调用的是类UserServiceImpl01的方法。验证了@Autowired是根据类型注入的观点。</p></blockquote><h2 id="2-接口与实现类的关系为一对多"><a href="#2-接口与实现类的关系为一对多" class="headerlink" title="2.接口与实现类的关系为一对多"></a>2.接口与实现类的关系为一对多</h2><p>新建实现类02：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service.impl;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl02 implements IUserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;I am UserServiceImpl02.................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行测试方法，控制台报错如下：<br>Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.example.demo.service.IUserService’ available: expected single matching bean but found 2: userServiceImpl01,userServiceImpl02<br>意思就是有多个实现类，程序不知道到底该注入哪个实现类了。</p></blockquote><p>测试类处理如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.test;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    @Qualifier(&quot;userServiceImpl02&quot;)</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行测试方法，控制台输出“I am UserServiceImpl02……………..”。<br>我们新增了@Qualifier注解，该注解与@Autowired结合使用，可以在一个接口有多个实现类的情况下，指定注入的实现类的名称。此处，而我们注入了第二个实现类UserServiceImpl02。（注意，Qualifier注解中的名称首字母为小写）。</p></blockquote><p>@Autowired+@Qualifier的使用，实现了bean自动注入时，先按照类型再按照名称进行注入的功能。</p><h1 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h1><h2 id="1-根据名称注入（byName）"><a href="#1-根据名称注入（byName）" class="headerlink" title="1.根据名称注入（byName）"></a>1.根据名称注入（byName）</h2><p>新建实现类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.service.impl;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Service</span><br><span class="line">public class UserService implements IUserService &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say() &#123;</span><br><span class="line">        System.out.println(&quot;I am UserService.................&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改测试类如下：</p><figure class="highlight plain"><figcaption><span>.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.test;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import com.example.demo.service.impl.UserService;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    @Autowired</span><br><span class="line">&#x2F;&#x2F;    @Qualifier(&quot;userServiceImpl02&quot;)</span><br><span class="line">    @Resource</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他文件不做改动。<br>现在的整体情况是，IUserService 有3个实现类，如果按类型注入的话肯定是失败的。</p><blockquote><p>运行测试方法，控制台输出“I am UserService……………..”。<br>由此可见，@Resource在进行bean注入时，首先会按照名称（byName）进行装配。</p></blockquote><h2 id="2-根据类型注入"><a href="#2-根据类型注入" class="headerlink" title="2.根据类型注入"></a>2.根据类型注入</h2><p>将UserService.java全部注释掉，再次运行测试方法进行测试。</p><blockquote><p>运行测试程序，此时控制台报错如下：<br>org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘com.example.demo.test.UserTest’: Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.example.demo.service.IUserService’ available: expected single matching bean but found 2: userServiceImpl01,userServiceImpl02<br>与之前测试Autowired注解的情形相同，按照类型注入失败了。<br>测试类处理如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package com.example.demo.test;</span><br><span class="line"></span><br><span class="line">import com.example.demo.service.IUserService;</span><br><span class="line">import com.example.demo.service.impl.UserServiceImpl01;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @author chenhy</span><br><span class="line"> * @date 2021&#x2F;4&#x2F;11</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class UserTest &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;    @Autowired</span><br><span class="line">&#x2F;&#x2F;    @Qualifier(&quot;userServiceImpl02&quot;)</span><br><span class="line">    @Resource(type &#x3D; UserServiceImpl01.class)</span><br><span class="line">    IUserService userService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        userService.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行测试程序，控制台输出“I am UserServiceImpl01……………..”。<br>通过在@Resource注解中指定注入的实现类来实现bean的注入。<br>此外，还可以在@Resource注解中指定类名称。</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>对比项</th><th>@Autowired</th><th>@Resource</th></tr></thead><tbody><tr><td>注解来源</td><td>Spring注解</td><td>JDK注解（JSR-250标准注解，属于J2EE）</td></tr><tr><td>装配方式</td><td>默认byType，其次byName</td><td>默认byName，其次byType</td></tr><tr><td>属性</td><td>required</td><td>name、type</td></tr><tr><td>作用范围</td><td>字段、setter方法、构造器</td><td>字段、setter方法</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h2 id="1-处理这2个注解的BeanPostProcessor不一样"><a href="#1-处理这2个注解的BeanPostProcessor不一样" class="headerlink" title="1.处理这2个注解的BeanPostProcessor不一样"></a>1.处理这2个注解的BeanPostProcessor不一样</h2><p>CommonAnnotationBeanPostProcessor是处理@ReSource注解的；<br>AutoWiredAnnotationBeanPostProcessor是处理@AutoWired注解的。</p><h2 id="2-注入方式不同"><a href="#2-注入方式不同" class="headerlink" title="2.注入方式不同"></a>2.注入方式不同</h2><p>@Autowired只按照byType注入；<br>@Resource默认按byName自动注入，也提供按照byType注入。</p><h2 id="3-属性不同"><a href="#3-属性不同" class="headerlink" title="3.属性不同"></a>3.属性不同</h2><p>@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。<br>@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。</p><h2 id="4-装配顺序不同"><a href="#4-装配顺序不同" class="headerlink" title="4.装配顺序不同"></a>4.装配顺序不同</h2><p>@Autowired：首先通过类型来查找bean，如果只找到一个，则直接注入，如果没有找到，则抛出异常；如果找到多个bean也会抛出异常。<br>解决方法一：可以在配置bean的时候加上@Primary注解，来提高优先级，这样就不会报错；<br>解决方法二：会默认使用字段名来匹配，如果没有匹配上，抛出异常。<br>如果需要直接通过bean的id来查找，可以配合@Qualifier来使用，没有找到抛出异常。<br>这里重点需要指出，使用@Autowired 是有优先级的，@Qualifier &gt; 按类型找（如果找到多个继续使用之后的策略） &gt; @Primary &gt; 按名字找<br>@Autowired通过设置required=false，在没有找到bean的情况下，不会抛出异常。</p><p>@Resource装配顺序：<br>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。<br>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。<br>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。<br>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</p>]]></content>
    
    
    <summary type="html">【Java】@Autowired和@Resource</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="@Autowired" scheme="https://born2do.github.io/tags/Autowired/"/>
    
    <category term="@Resource" scheme="https://born2do.github.io/tags/Resource/"/>
    
  </entry>
  
  <entry>
    <title>【数据库】联合主键</title>
    <link href="https://born2do.github.io/2021/04/11/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/"/>
    <id>https://born2do.github.io/2021/04/11/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/</id>
    <published>2021-04-11T12:13:50.000Z</published>
    <updated>2021-04-11T12:14:10.791Z</updated>
    
    <content type="html"><![CDATA[<p>无意间看到数据库中有张表的主键有三个，没记错的话应该是“每张表都只有一个主键，唯一、不为空”，随后搜索查阅了一下。看到以下结论：</p><p>1、数据库的每张表只能有一个主键，不可能有多个主键。</p><p>2、所谓的一张表多个主键，我们称之为<strong>联合主键</strong>。</p><p>   注：联合主键：就是用多个字段一起作为一张表的主键。</p><p>3、主键的主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE STUDENT (</span><br><span class="line"></span><br><span class="line">STU_ID CHARACTER(4) NOT NULL,</span><br><span class="line"></span><br><span class="line">STU_NAME VARCHAR(32) NOT NULL,</span><br><span class="line"></span><br><span class="line">STU_MSG VARCHAR(128),</span><br><span class="line"></span><br><span class="line">STU_SEX VARCHAR(4),</span><br><span class="line"></span><br><span class="line">PRIMARY KEY (INST_ID, INST_RESP_CODE)</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【数据库】联合主键</summary>
    
    
    
    <category term="数据库" scheme="https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="联合主键" scheme="https://born2do.github.io/tags/%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据库易混述语总结</title>
    <link href="https://born2do.github.io/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD%E6%80%BB%E7%BB%93/"/>
    <id>https://born2do.github.io/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD%E6%80%BB%E7%BB%93/</id>
    <published>2021-04-11T12:09:14.000Z</published>
    <updated>2021-04-11T12:10:34.561Z</updated>
    
    <content type="html"><![CDATA[<ol><li><blockquote><ul><li>DB，数据库（DataBase）</li><li>DBMS，数据库管理系统（DataBase Management System）</li><li>DBA，数据库管理员（DataBase Administrator）</li><li>DBS，数据库系统（DataBase System）</li><li>DBS是由DB、DBMS（及其应用开发工具）、应用数据和DBA组成的存储、管理、处理和维护数据的系统。</li></ul></blockquote></li><li><blockquote><h3 id="外模式"><a href="#外模式" class="headerlink" title="外模式"></a>外模式</h3><p>外模式又称子模式或用户模式，对应于<strong>用户级</strong>。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。</p><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式又称概念模式或逻辑模式，对应于<strong>概念级</strong>。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的<strong>全局逻辑结构</strong>，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。</p><h3 id="内模式"><a href="#内模式" class="headerlink" title="内模式"></a>内模式</h3><p>内模式又称存储模式，对应于<strong>物理级</strong>。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的<strong>存储方式和物理结构</strong>，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。</p><h3 id="外模式-模式映象"><a href="#外模式-模式映象" class="headerlink" title="外模式/模式映象"></a>外模式/模式映象</h3><p>模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。</p><p>对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映像，它定义了该外模式与模式之间的对应关系。这些映像定义通常包含在各模式的描述中。 当模式改变时，由数据库管理员对各个外模式/模式映像作相应的改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序可以不必修改，保证了数据与程序的<strong>逻辑独立性</strong>。</p><h3 id="模式-内模式映像"><a href="#模式-内模式映像" class="headerlink" title="模式/内模式映像"></a>模式/内模式映像</h3><p>数据库中不仅只有一个模式，而且也只有一个内模式，所以模式/内模式映像是唯一的，由它定义数据库全局逻辑结构与存储结构之间的对应关系。<br>模式/内模式映像定义通常包含在模式描述中。当数据库的存储设备和存储方法发生变化时，数据库管理员对模式/内模式映像要做相应的改变，使模式保持不变，从而应用程序也不变，保证了数据与程序的物理独立性，简称为数据的<strong>物理独立性</strong>。</p></blockquote></li></ol>]]></content>
    
    
    <summary type="html">数据库易混述语总结</summary>
    
    
    
    <category term="数据库" scheme="https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="易混述语" scheme="https://born2do.github.io/tags/%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>数据表空间和索引表空间</title>
    <link href="https://born2do.github.io/2021/04/10/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <id>https://born2do.github.io/2021/04/10/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/</id>
    <published>2021-04-10T11:51:25.000Z</published>
    <updated>2021-04-10T11:51:59.518Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Oracle强烈建议，任何一个应用程序的库表至少需要创建两个表空间，其中之一用于存储表数据，而另一个用于存储表索引数据。因为如果将表数据和索引数据放在一起，表数据的I/O操作和索引的I/O操作将产生影响系统性能的I/O竞争，降低系统的响应效率。将表数据和索引数据存放在不同的表空间中（如一个为APP_DATA，另一个为APP_IDX），并在物理层面将这两个表空间的数据文件放在不同的物理磁盘上，就可以避免这种竞争了。</p></blockquote><p>oracle中，数据表空间和索引表空间的区别是表和索引分开在不同的表空间存放,放表的叫数据表空间, 放索引的叫索引表空间, 如果能分别存放在不同的硬盘上性能会更好,其与代码并无关系。</p>]]></content>
    
    
    <summary type="html">数据表空间和索引表空间</summary>
    
    
    
    <category term="数据库" scheme="https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="数据表空间和索引表空间" scheme="https://born2do.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>【Java】为什么Java中Date类的很多方法被废弃了</title>
    <link href="https://born2do.github.io/2021/04/10/%E3%80%90Java%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%ADDate%E7%B1%BB%E7%9A%84%E5%BE%88%E5%A4%9A%E6%96%B9%E6%B3%95%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%BA%86/"/>
    <id>https://born2do.github.io/2021/04/10/%E3%80%90Java%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%ADDate%E7%B1%BB%E7%9A%84%E5%BE%88%E5%A4%9A%E6%96%B9%E6%B3%95%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%BA%86/</id>
    <published>2021-04-10T11:33:41.000Z</published>
    <updated>2021-04-10T11:39:37.944Z</updated>
    
    <content type="html"><![CDATA[<p>Date类的很多方法被废弃，归根结底是有缺陷、有问题，已经被新的、更完善的类、方法替代了。</p><p>Date类中有很多方法都标有删除线，是因为Date类在设计中有很多问题，如getYear指的是1900年以来的年数，getMonth是从0开始的。事实上，不止Date类，Java的日期时间相关类都存在设计问题。Java的日期类库有些混乱，据说已经重新设计了两次。</p><p>Date类已经逐渐被Calendar类所取代。</p><ul><li>int getDate() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_MONTH) 取代。</li><li>int getDay() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_WEEK) 取代。</li><li>int getHours() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.HOUR_OF_DAY) 取代。</li><li>int getMinutes() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.MINUTE) 取代。</li><li>int getMonth() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.MONTH) 取代。</li><li>int getSeconds() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.SECOND) 取代。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date.getMonth());</span><br><span class="line"></span><br><span class="line">Calendar calendar = Calendar.getInstance();</span><br><span class="line">System.out.println(calendar.get(Calendar.MONTH));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Java】为什么Java中Date类的很多方法被废弃了</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="Date" scheme="https://born2do.github.io/tags/Date/"/>
    
  </entry>
  
  <entry>
    <title>元字符及其描述</title>
    <link href="https://born2do.github.io/2021/04/09/%E5%85%83%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0/"/>
    <id>https://born2do.github.io/2021/04/09/%E5%85%83%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0/</id>
    <published>2021-04-09T11:58:34.000Z</published>
    <updated>2021-04-09T11:59:43.537Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\</td><td>将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\n”匹配\n。“\n”匹配换行符。序列“\”匹配“\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置。</td></tr><tr><td>$</td><td>匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置。</td></tr><tr><td>*</td><td>匹配前面的子表达式任意次。例如，zo<em>能匹配“z”，也能匹配“zo”以及“zoo”。</em>等价于o{0,}</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。</td></tr><tr><td>{n}</td><td>n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。</td></tr><tr><td>{n,}</td><td>n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。</td></tr><tr><td>{n,m}</td><td>m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td>?</td><td>当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’]</td></tr><tr><td>.点</td><td>匹配除“\r\n”之外的任何单个字符。要匹配包括“\r\n”在内的任何字符，请使用像“[\s\S]”的模式。</td></tr><tr><td>(pattern)</td><td>匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。</td></tr><tr><td>(?:pattern)</td><td>非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。</td></tr><tr><td>(?=pattern)</td><td>非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td>(?!pattern)</td><td>非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。</td></tr><tr><td>(?&lt;=pattern)</td><td>非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。</td></tr><tr><td>(?&lt;!pattern)</td><td>非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题                此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配</td></tr><tr><td>x|y</td><td>匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。</td></tr><tr><td>[xyz]</td><td>字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。</td></tr><tr><td>[^xyz]</td><td>负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。</td></tr><tr><td>[a-z]</td><td>字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。                注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身.</td></tr><tr><td>[^a-z]</td><td>负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\b就是匹配位置的）。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。</td></tr><tr><td>\B</td><td>匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。</td></tr><tr><td>\cx</td><td>匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。</td></tr><tr><td>\d</td><td>匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持</td></tr><tr><td>\D</td><td>匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持</td></tr><tr><td>\f</td><td>匹配一个换页符。等价于\x0c和\cL。</td></tr><tr><td>\n</td><td>匹配一个换行符。等价于\x0a和\cJ。</td></tr><tr><td>\r</td><td>匹配一个回车符。等价于\x0d和\cM。</td></tr><tr><td>\s</td><td>匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</td></tr><tr><td>\S</td><td>匹配任何可见字符。等价于[^ \f\n\r\t\v]。</td></tr><tr><td>\t</td><td>匹配一个制表符。等价于\x09和\cI。</td></tr><tr><td>\v</td><td>匹配一个垂直制表符。等价于\x0b和\cK。</td></tr><tr><td>\w</td><td>匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。</td></tr><tr><td>\W</td><td>匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">元字符及其描述</summary>
    
    
    
    <category term="元字符" scheme="https://born2do.github.io/categories/%E5%85%83%E5%AD%97%E7%AC%A6/"/>
    
    
    <category term="元字符" scheme="https://born2do.github.io/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>【Java】栈内存与堆内存的区别</title>
    <link href="https://born2do.github.io/2021/04/09/%E3%80%90Java%E3%80%91%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/09/%E3%80%90Java%E3%80%91%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-09T11:57:28.000Z</published>
    <updated>2021-04-09T11:58:14.549Z</updated>
    
    <content type="html"><![CDATA[<ol><li>栈内存与堆内存都是Java用来存储数据的地方。与C++不同，Java自动管理栈和堆，程序员不需要也不能够直接对栈或堆进行设置。</li><li>堆，用于存储对象。当Java程序使用 new 关键字创建对象时，堆内存会开辟出相应的内存来存储该对象，这些对象不需要被显式地释放，会有垃圾回收机制来处理这些长期没有被使用的对象。<ul><li>优点：他是在运行时动态分配内存大小，不需要人工管理垃圾数据，会有垃圾回收机制进行相应管理。</li><li>缺点：同样，因为是在运行时动态分配内存大小，故而存取速度较慢。</li></ul></li><li>栈，主要用于存放一些基本数据类型的变量和对象引用。<ul><li>优点：1）存取速度快于堆，仅次于寄存器。2）栈数据可共享。</li><li>缺点：存放在栈中的数据大小与生存期必须是确定的，缺乏灵活性。</li></ul></li></ol>]]></content>
    
    
    <summary type="html">【Java】栈内存与堆内存的区别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="栈内存" scheme="https://born2do.github.io/tags/%E6%A0%88%E5%86%85%E5%AD%98/"/>
    
    <category term="堆内存" scheme="https://born2do.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>【IDEA社区版】webapp下静态资源无法访问</title>
    <link href="https://born2do.github.io/2021/04/08/%E3%80%90IDEA%E7%A4%BE%E5%8C%BA%E7%89%88%E3%80%91webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/"/>
    <id>https://born2do.github.io/2021/04/08/%E3%80%90IDEA%E7%A4%BE%E5%8C%BA%E7%89%88%E3%80%91webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/</id>
    <published>2021-04-08T13:50:32.000Z</published>
    <updated>2021-04-08T13:51:07.181Z</updated>
    
    <content type="html"><![CDATA[<p>一开始认为是webapp下的静态资源被拦截了，但是修改了springmvc.xml以及web.xml对静态资源的控制仍然没有反应。</p><p>打开浏览器的开发者模式，发现静态资源全部没有访问到，路径直接是 <a href="http://localhost:8080/css/*.css">http://localhost:8080/css/*.css</a> ，路径明显是错误的。</p><p>后改用绝对路径引入静态资源，页面正常显示。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>说明之前使用的相对路径引入资源是错误的，修改相对路径为<code>../js/jquery.min.js</code>，页面也可正常显示。</p><p>以此可以认为在引入静态资源时，默认当前路径为WEB-INF。但是以相对路径引入静态资源，IDEA会显示报错，即使该项目是可以正常启动并显示的。</p>]]></content>
    
    
    <summary type="html">【IDEA社区版】webapp下静态资源无法访问</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="webapp下静态资源无法访问" scheme="https://born2do.github.io/tags/webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/"/>
    
  </entry>
  
  <entry>
    <title>【Java】在写文件时进行输出换行</title>
    <link href="https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91%E5%9C%A8%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA%E6%8D%A2%E8%A1%8C/"/>
    <id>https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91%E5%9C%A8%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA%E6%8D%A2%E8%A1%8C/</id>
    <published>2021-04-07T13:56:25.000Z</published>
    <updated>2021-04-07T13:56:44.319Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在做爬虫，需要将网页落地到本地的Markdown文档中。由于是多次写入，导致上一篇文档的结尾与下一篇文档的开头紧密连接在一起，格式出问题了。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>之所以会连接在一起，是因为没有对文章末进行换行处理，处理一下就好。</p><blockquote><p>在Windows操作系统中，”\r\n”为回车换行；<br>而在Linux系统中，”\n”即可。</p></blockquote><p>为了兼容这两种情况，我们使用如下方法获取换行符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperty(<span class="string">&quot;line.separator&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Java】在写文件时进行输出换行</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="IO" scheme="https://born2do.github.io/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>【Java】Html转Markdown格式</title>
    <link href="https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91Html%E8%BD%ACMarkdown%E6%A0%BC%E5%BC%8F/"/>
    <id>https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91Html%E8%BD%ACMarkdown%E6%A0%BC%E5%BC%8F/</id>
    <published>2021-04-07T13:55:28.000Z</published>
    <updated>2021-04-07T13:56:00.418Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在做爬虫项目，其中一个需求是将网页上的帮助文档，下载至本地并形成Markdown文档，方便离线查阅。</p><h1 id="探索及解决"><a href="#探索及解决" class="headerlink" title="探索及解决"></a>探索及解决</h1><p>找到两个具有该功能的Java类库，如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.kotcrab.remark&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;remark&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;com.github.houbb&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;html2md&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>相比较之下，我选择了remark。<br>使用html2md进行格式转换之后，最终文档与预期的格式差异较大。<br>而remark转换后则较为中规中矩，比较符合实际使用中的Markdown语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将获取到的内容从HTML格式转换为Markdown格式</span></span><br><span class="line">Remark remark = <span class="keyword">new</span> Remark();</span><br><span class="line">content = remark.convert(content);</span><br></pre></td></tr></table></figure><p>转换前的Html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;12-总体架构&quot;</span>&gt;</span>1.2 总体架构<span class="tag">&lt;/<span class="name">h3</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>WebMagic的结构分为<span class="tag">&lt;<span class="name">code</span>&gt;</span>Downloader<span class="tag">&lt;/<span class="name">code</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span>PageProcessor<span class="tag">&lt;/<span class="name">code</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span>Scheduler<span class="tag">&lt;/<span class="name">code</span>&gt;</span>、<span class="tag">&lt;<span class="name">code</span>&gt;</span>Pipeline<span class="tag">&lt;/<span class="name">code</span>&gt;</span>四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>转换后的Markdown</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">### 1.2 总体架构 ###</span></span><br><span class="line"></span><br><span class="line">WebMagic的结构分为<span class="code">`Downloader`</span>、<span class="code">`PageProcessor`</span>、<span class="code">`Scheduler`</span>、<span class="code">`Pipeline`</span>四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。</span><br><span class="line"></span><br><span class="line">而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Java】Html转Markdown格式</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="Html转Markdown" scheme="https://born2do.github.io/tags/Html%E8%BD%ACMarkdown/"/>
    
  </entry>
  
  <entry>
    <title>【Java】运算符的优先级和结合顺序</title>
    <link href="https://born2do.github.io/2021/04/06/%E3%80%90Java%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E9%A1%BA%E5%BA%8F/"/>
    <id>https://born2do.github.io/2021/04/06/%E3%80%90Java%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E9%A1%BA%E5%BA%8F/</id>
    <published>2021-04-06T15:13:26.000Z</published>
    <updated>2021-04-06T15:15:34.718Z</updated>
    
    <content type="html"><![CDATA[<p>1级（左结合） 　　() 圆括号；[]下标运算符；-&gt;指向结构体成员运算符；. 结构体成员运算符。 </p><p>2级（右结合） 　　!逻辑非运算符；~按位取反运算符；++前缀增量运算符；–前缀减量运算符；+正号运算符；-负号运算符；(类型)类型转换运算符；*指针运算符；&amp;地址运算符；sizeof长度运算符。 　　</p><p>3级（左结合） 　　*乘法运算符；/除法运算符；%取余运算符。 　　</p><p>4级（左结合） 　　+加法运算符；-减法运算符。 　　 　　</p><p>5级（左结合） 　　&lt;&lt;左移运算符；&gt;&gt;右移运算符。 　　</p><p>6级（左结合） 　　&lt;、&lt;=、&gt;、&gt;=关系运算符。 　　</p><p>7级（左结合） 　　==等于运算符；!=不等于运算符。 　　</p><p>8级（左结合） 　　&amp;按位与运算符。 　　</p><p>9级（左结合） 　　^按位异或运算符。 　　</p><p>10级（左结合） 　　|按位或运算符。 　　</p><p>11级（左结合） 　　&amp;&amp;逻辑与运算符。 　　</p><p>12级（左结合） 　　||逻辑或运算符。 　　</p><p>13级（右结合） 　　? :条件运算符。 　　</p><p>14级（右结合） 　　=、 +=、 -=、 *=、 /=、 %=、 &amp;=、 ^=、 |=、 &lt;&lt;=、 &gt;&gt;=赋值运算符。 　</p><p>15级（左结合） 　　,逗号运算符。</p>]]></content>
    
    
    <summary type="html">运算符的优先级和结合顺序</summary>
    
    
    
    <category term="C语言" scheme="https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="运算符优先级" scheme="https://born2do.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>【log4j】logger.isTraceEnabled()</title>
    <link href="https://born2do.github.io/2021/04/05/%E3%80%90log4j%E3%80%91logger-isTraceEnabled/"/>
    <id>https://born2do.github.io/2021/04/05/%E3%80%90log4j%E3%80%91logger-isTraceEnabled/</id>
    <published>2021-04-05T08:41:04.000Z</published>
    <updated>2021-04-05T08:41:29.459Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常可以看到，在使用日志框架时，会有如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">    logger.trace(<span class="string">&quot;trace&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么要这样写呢？这样写有什么好处？<br>首先我们来看下这两个方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.repository.isDisabled(<span class="number">5000</span>) ? <span class="keyword">false</span> : Level.TRACE.isGreaterOrEqual(<span class="keyword">this</span>.getEffectiveLevel());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(Object message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">super</span>.repository.isDisabled(<span class="number">5000</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Level.TRACE.isGreaterOrEqual(<span class="keyword">this</span>.getEffectiveLevel())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.forcedLog(FQCN, Level.TRACE, message, (Throwable)<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，在使用trace方法打印日志时，会有与isTraceEnabled方法中一样的方法调用，也就是说等同于在trace中调用了isTraceEnabled方法。<br>那么为什么我们在使用时还要在外层进行一次判断呢？<br>官方的说法是：出于效率考虑，看具体情况而定。<br>我们就以下两种情况进行分析：</p><ol><li>直接传入参数，无其他处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.trace(<span class="string">&quot;trace&quot;</span>);</span><br></pre></td></tr></table></figure>对于这种情况，则完全没有必要在外层进行筛选判断。</li><li>传参数时引入了其他方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logger.debug(<span class="string">&quot;The money is &quot;</span> + getTotal());  </span><br></pre></td></tr></table></figure>对于这种情况，则需要考虑考虑了。如果getTotal()方法是一个较为复杂的、计算量庞大的方法，则在外层进行一下判断就是很有必要的了。无论当前系统的日志级别为哪一等级，程序程序都会调用debug方法，会执行getTotal方法，只不过最后的结果可能是不打印日志而已（日志级别为info或更高）。debug中调用这个方法会消耗较大资源，得不偿失。</li></ol>]]></content>
    
    
    <summary type="html">【log4j】logger.isTraceEnabled()</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="log4j" scheme="https://born2do.github.io/tags/log4j/"/>
    
  </entry>
  
  <entry>
    <title>SLF4J日志级别</title>
    <link href="https://born2do.github.io/2021/04/04/SLF4J%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/"/>
    <id>https://born2do.github.io/2021/04/04/SLF4J%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/</id>
    <published>2021-04-04T15:34:56.000Z</published>
    <updated>2021-04-04T15:35:57.663Z</updated>
    
    <content type="html"><![CDATA[<p>SLF4J将日志分为trace、debug、info、warn、error五个级别，每个级别对应记录不同的日志，对应不同的使用场景。<br>优先级从高到低依次为trace、debug、info、warn、error，相对而言，打印的日志会越来越少。</p><ul><li>trace: 一般用来追踪详细的程序运行流，比如程序的运行过程中，运行到了哪一个方法，进入了哪一条分支。通过trace程序的运行流程，可以判断程序是否按照期望的逻辑在运行。</li><li>debug: 这类日志往往用在判断是否有出现bug的场景，且往往记录了代码运行的详细信息，比如方法调用传入的参数信息。</li><li>info：用来记录程序运行的一些关键信息，它不像trace那样记录程序运行的整个流程，也不像debug那样为了解决问题而记录详细的信息。info记录的是整个系统的运行信息，比如系统运行到了哪一个阶段，到达了哪一个状态。</li><li>warn：用来记录一些警告信息。警告信息表示，程序进入了一个特殊的状态，在该状态下程序可以继续运行，但是不建议让程序进入该状态，因为该状态可能导致结果出现问题。</li><li>error：用来记录运行时的错误信息，表示程序运行过程中出现了需要被解决的问题，往往是一些异常。使用error日志的时候，一般会将详细的异常出现的原因记录。</li></ul>]]></content>
    
    
    <summary type="html">SLF4J日志级别</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="SLF4J" scheme="https://born2do.github.io/tags/SLF4J/"/>
    
  </entry>
  
</feed>
