<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ChenHY的个人博客</title>
  
  
  <link href="https://born2do.github.io/atom.xml" rel="self"/>
  
  <link href="https://born2do.github.io/"/>
  <updated>2021-08-22T01:56:27.453Z</updated>
  <id>https://born2do.github.io/</id>
  
  <author>
    <name>chenhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OceanBase开发规范和最佳实践</title>
    <link href="https://born2do.github.io/2021/08/22/OceanBase%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>https://born2do.github.io/2021/08/22/OceanBase%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-08-22T01:55:51.000Z</published>
    <updated>2021-08-22T01:56:27.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开发使用的注意点"><a href="#开发使用的注意点" class="headerlink" title="开发使用的注意点"></a>开发使用的注意点</h2><h3 id="1-分区表的使用建议"><a href="#1-分区表的使用建议" class="headerlink" title="1.分区表的使用建议"></a>1.分区表的使用建议</h3><ol><li>业务形态（热点数据打散、历史数据维护便利性、业务SQL的条件形态（分区裁剪））。</li><li>OB各种分区类型的设置要求。</li><li>大表变分区表。</li><li>分区键的选择，分区键必须是主键的子集。</li><li>考虑分区裁剪、partition wise join优化。</li><li>Range分区，最后一个不能是maxvalue。</li><li>分布式事务，Leader Binding、Table Group。</li><li>为了避免写入放大问题，选择表的自定义主键时，不要使用随机生成的值，要尽量有序，比如时序递增的。</li><li>分区个数：单机分区上限（5万）、单机租户允许创建的最大分区数量上限（租户内存）、单表分区数上限（8192）。</li></ol><h3 id="2-局部索引和全局索引的取舍"><a href="#2-局部索引和全局索引的取舍" class="headerlink" title="2.局部索引和全局索引的取舍"></a>2.局部索引和全局索引的取舍</h3><ol><li>如果查询条件里“包含完整的分区键”，使用本地索引是最高效的（分区裁剪）。</li><li>如果需要“不包含完整分区键”的唯一约束，1）使用全局索引；2）使用本地索引，且需要索引列上必须带上表的分区键。</li><li>其他情况，<ul><li>通常来说，全局索引能为高频且精准命中的查询（比如单记录查询）提速并减少IO；对范围查询则不一定哪种索引效果好。</li><li>不能忽视全局索引在DML语句中引入的额外开销：数据更新时带来的跨机分布式事务，事务的数据量越大则分布式事务越复杂。</li></ul></li><li>如果数据量较大，或者容易出现索引热点，可以考虑创建全局分区索引。</li></ol><h3 id="3-分布式事务流程及优化方法"><a href="#3-分布式事务流程及优化方法" class="headerlink" title="3.分布式事务流程及优化方法"></a>3.分布式事务流程及优化方法</h3><ol><li>2PC流程用户感知的commit延迟<ul><li>标准：4次日志延迟 + 2次RPC延迟</li><li>OB：1次日志延迟 + 2次RPC延迟</li></ul></li><li>优化办法：<ul><li>尽量避免跨机分布式事务。</li><li>慎重选择事务中的第一条语句，因为OBProxy的路由规则。</li><li>Primary_zone、Table Group设置。</li></ul></li></ol><h3 id="4-OB-Proxy的路由规则"><a href="#4-OB-Proxy的路由规则" class="headerlink" title="4.OB Proxy的路由规则"></a>4.OB Proxy的路由规则</h3><ol><li>proxy parser 在根据SQL选择server时，有以下几点特殊的逻辑：<ul><li>proxy parser只解析Begin/START TRANSACTION/SET 和其他DML语句，如果遇到其他单词开头的语句，proxy的parser会直接跳过，认为该语句不包含表名。</li><li>proxy parser会按照第一条包含实体表名的stmtement进行路由，如果整个stmtement都不包含表名，则将请求发送至上一条SQL所发送的server。</li></ul></li><li>OB Server会根据执行计划的类型，来告诉proxy是否将请求路由至正确的server，如果路由失败，proxy会更新location，当前的反馈机制如下：<ul><li>server返回第一条DML的命中情况</li></ul></li><li>推荐用法：</li></ol><p>3.1 以下几种情况（select可以等价替换成update/delete/replace/insert，下同），proxy能够将请求发送至正确的server，并且server能够按照proxy的命中情况进行反馈。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1; <span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">1</span>; <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>(); <span class="keyword">set</span> @<span class="variable">@autocommit</span> <span class="operator">=</span> <span class="number">0</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1; <span class="keyword">insert</span> <span class="keyword">into</span> t2 <span class="keyword">values</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> @<span class="variable">@ob</span>_trx_timeout <span class="operator">=</span> <span class="number">10000000</span>; <span class="keyword">begin</span>; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1; <span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>3.2 以下几种情况，proxy会将请求发送至上一个SQL所使用的server。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key);<span class="keyword">create</span> <span class="keyword">table</span> t2(id <span class="type">int</span> <span class="keyword">primary</span> key);</span><br></pre></td></tr></table></figure><ol start="4"><li>不推荐用法：</li></ol><p>4.1 以下几种情况（第一个DML是非实体表），proxy能够将请求发送至正确的server，但是server反馈的信息可能不准，不建议使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span> <span class="keyword">from</span> dual; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><p>4.2 以下几种情况，proxy可能能够将请求路由至正确的server，但是server反馈的信息可能不准确，不建议使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1(id <span class="type">int</span> <span class="keyword">primary</span> key); <span class="keyword">insert</span> <span class="keyword">into</span> t1 <span class="keyword">values</span>();</span><br></pre></td></tr></table></figure><p>4.3 以下几种情况，proxy会强制将请求路由至上一次使用的server，server反馈的信息可能不准确，不建议使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> warnings; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="built_in">count</span>(\<span class="operator">*</span>) errors; <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t1;</span><br></pre></td></tr></table></figure><h3 id="5-大事务尺寸限制、长事务"><a href="#5-大事务尺寸限制、长事务" class="headerlink" title="5.大事务尺寸限制、长事务"></a>5.大事务尺寸限制、长事务</h3><p>【报错】</p><ul><li>ERROR 6244(HY000): out of transaction threshold</li></ul><p>【原因】</p><ul><li>LSMT结构，批量写出脏数据。</li><li>冻结动作时不能“转储未提交事务”，需要事务搬迁到1-freeze_trigger%</li></ul><p>【场景】</p><ul><li>业务租户内存配置较低</li><li>单体大事务</li><li>事务并发量大</li></ul><p>【建议】</p><ul><li>调整具体的表结构和调整业务的并发量</li><li>数据生命周期管理，考虑partition add/drop，而不是delete</li><li>调整业务SQL逻辑，将大段的事务拆成小段</li></ul><h3 id="6-悬挂、长事务和超时保护机制"><a href="#6-悬挂、长事务和超时保护机制" class="headerlink" title="6.悬挂、长事务和超时保护机制"></a>6.悬挂、长事务和超时保护机制</h3><p>【概念】</p><ul><li>悬挂事务</li><li>长事务</li></ul><p>【危害】</p><ul><li>持有memtablede的ref，memstore内存爆炸</li></ul><p>【建议】</p><ol><li>谨慎的timeout设置<ul><li>查询超时系统变量：ob_query_timeout（默认10s）</li><li>事务超时参数：ob_trx_timeout（默认100s）</li><li>事务空闲超时：ob_trx_idle_timeout（默认120s）</li></ul></li><li>事务及时提交</li></ol><p>【监控】</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> _all_virtual_trans_stat <span class="keyword">where</span> (now() <span class="operator">-</span> ctx_create_time) <span class="operator">&gt;</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h3 id="7-Buffer表的使用建议"><a href="#7-Buffer表的使用建议" class="headerlink" title="7.Buffer表的使用建议"></a>7.Buffer表的使用建议</h3><p>【业务形态】</p><ul><li>会在短时间内 写入-修改-删除</li></ul><p>【问题】</p><ul><li>fuse流程时 data scan 时链路变长，SQL变慢</li></ul><p>【原因】</p><ul><li>LSTM的变更链路</li></ul><p>【常见的Mitigation】</p><ul><li>OB：memtable row purge</li><li>OB：针对buffer表使用特殊的转储策略：fast freeze</li><li>手工major freeze以消除多版本，减少层级</li><li>CBO统计信息不准确导致的sql plan change、outline绑定</li></ul><h3 id="8-适配大查询隔离参数"><a href="#8-适配大查询隔离参数" class="headerlink" title="8.适配大查询隔离参数"></a>8.适配大查询隔离参数</h3><p>【为什么要适配】</p><ul><li>每个租户分配一定比例的资源来处理大查询</li></ul><p>【对应参数】</p><ul><li>large_query_threshold(default 100ms)</li><li>large_query_worker_percentage(30)</li></ul><p>【适配点】</p><ul><li>这些参数需要精细化控制。</li><li>这是因为 租户级的活跃线程数是一个容量资源，线程数量是固定的。</li></ul><h3 id="9-业务幂等重试逻辑"><a href="#9-业务幂等重试逻辑" class="headerlink" title="9.业务幂等重试逻辑"></a>9.业务幂等重试逻辑</h3><p>【报错】</p><ul><li>-6225: ERROR 4012(25000):OB-4012:Transaction result is unknown</li><li>Communication link failure during commit().Transaction resolution unknown.</li></ul><p>【场景】</p><ul><li>切主时的事务搬迁</li><li>网络RPC队列堆积、网络传输慢</li><li>2PC过程中协调者宕机</li><li>事务超时参数 ob_trx_timeout （默认100s）/ob_trx_idle_timeout（默认120s）</li></ul><p>【建议】</p><ul><li>业务适配幂等重试逻辑</li><li>监控</li></ul><h3 id="10-定时合并任务、Noisy-Neighbor问题"><a href="#10-定时合并任务、Noisy-Neighbor问题" class="headerlink" title="10.定时合并任务、Noisy Neighbor问题"></a>10.定时合并任务、Noisy Neighbor问题</h3><ol><li>合并任务都做了什么？<ul><li>Compaction</li><li>数据压缩</li><li>数据校验</li><li>渐进schema变更</li><li>统计信息收集</li></ul></li><li>定时合并任务默认时间为 02:00</li><li>Noisy Neighbor问题</li></ol><h3 id="11-自增列、无主键表、Sequence"><a href="#11-自增列、无主键表、Sequence" class="headerlink" title="11.自增列、无主键表、Sequence"></a>11.自增列、无主键表、Sequence</h3><ol><li><p>自增列</p><ul><li><p>可以指定自增起始值、自增步长、自增列缓存大小</p></li><li><p>MySQL mode: </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `test`(</span><br><span class="line">`id` <span class="type">int</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment comment <span class="string">&#x27;自增id&#x27;</span>,</span><br><span class="line">……)</span><br></pre></td></tr></table></figure></li><li><p>连续性：跳变问题</p></li></ul></li><li><p>无主键表</p><ul><li>基于自增列方式生成的隐藏列</li><li>sync_value同步调优by autoinc_cache_refresh_interval</li><li>建议建表时为表设计主键或者唯一键</li><li>不支持后加主键</li></ul></li><li><p>Sequence</p><ul><li>默认使用 cache + noorder ，性能考虑</li><li>Cache Size：单机TPS=100时候，cache size 建议<code>100*60*60=360000</code></li></ul></li></ol>]]></content>
    
    
    <summary type="html">OceanBase开发规范和最佳实践</summary>
    
    
    
    <category term="OceanBase" scheme="https://born2do.github.io/categories/OceanBase/"/>
    
    
    <category term="OceanBase" scheme="https://born2do.github.io/tags/OceanBase/"/>
    
  </entry>
  
  <entry>
    <title>POI、swagger 导出excel时，文件名为SwaggerBootstrapUiDownload.txt</title>
    <link href="https://born2do.github.io/2021/07/25/POI%E3%80%81swagger-%E5%AF%BC%E5%87%BAexcel%E6%97%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BASwaggerBootstrapUiDownload-txt/"/>
    <id>https://born2do.github.io/2021/07/25/POI%E3%80%81swagger-%E5%AF%BC%E5%87%BAexcel%E6%97%B6%EF%BC%8C%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%BASwaggerBootstrapUiDownload-txt/</id>
    <published>2021-07-25T09:27:41.000Z</published>
    <updated>2021-07-25T09:35:04.006Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>POI、swagger 导出excel时，文件名为SwaggerBootstrapUiDownload.txt</p><p>修改文件后缀为xls后，文件可以正常打开，并且内容正确。</p><p>很明显时获取文件名称出错了，没有取到我们设置的名称，所以使用了默认名称“SwaggerBootstrapUiDownload.txt”。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>在网上查了好长时间，都没有解决掉，但是网络上是有这种情况发生的。</p><p>我猜想作者会不会已经修复了这个问题，查看了版本号，我的pom文件中的版本果然不是最新的，更新到最新版本后，文件名称获取成功，文件正常下载。</p><p>这里附一下成功的版本号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--swagger第三方ui依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.github.xiaoymin&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;swagger-bootstrap-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.9.6&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure><p>说明一下，原生POI是正常的，只是这个第三方UI的老版本有点问题。</p>]]></content>
    
    
    <summary type="html">POI、swagger 导出excel时，文件名为SwaggerBootstrapUiDownload.txt</summary>
    
    
    
    
    <category term="swagger" scheme="https://born2do.github.io/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>SpringSecurity登陆后访问其他资源提示未登录</title>
    <link href="https://born2do.github.io/2021/07/18/SpringSecurity%E7%99%BB%E9%99%86%E5%90%8E%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%8F%90%E7%A4%BA%E6%9C%AA%E7%99%BB%E5%BD%95/"/>
    <id>https://born2do.github.io/2021/07/18/SpringSecurity%E7%99%BB%E9%99%86%E5%90%8E%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90%E6%8F%90%E7%A4%BA%E6%9C%AA%E7%99%BB%E5%BD%95/</id>
    <published>2021-07-18T15:20:35.000Z</published>
    <updated>2021-07-18T15:32:48.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Spring Security + JWT实现登录，在前台使用Swagger登录后发现，访问其他资源报错，提示未登录。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">19.216</span> DEBUG <span class="number">12260</span> --- [io-<span class="number">50000</span>-exec-<span class="number">7</span>] c.b.server.mapper.AdminMapper.selectOne  : ==&gt;  Preparing: SELECT id,name,phone,telephone,address,enabled,username,password,userFace,<span class="function">remark FROM t_admin <span class="title">WHERE</span> <span class="params">(username = ? AND enabled = ?)</span></span></span><br><span class="line"><span class="function">2021-07-18 22:50:19.217 DEBUG 12260 --- [io-50000-exec-7] c.b.server.mapper.AdminMapper.selectOne  : </span>==&gt; Parameters: &#123;id=<span class="number">1</span>, name=系统管理员, phone=<span class="number">13812361398</span>, telephone=<span class="number">71937538</span>, address=香港特别行政区强县长寿柳州路p座<span class="number">123</span>, enabled=<span class="keyword">true</span>, username=admin, password=$2a$<span class="number">10</span>$ogvUqZZAxrBwrmVI/e7.SuFYyx8my8d.9zJ6bs9lPKWvbD9eefyCe, userFace=http:<span class="comment">//192.168.10.100:8888/group1/M00/00/00/wKgKZF6oHzuAXnw9AABaLsrkrQQ148.jpg, remark=null, authorities=null, credentialsNonExpired=true, accountNonLocked=true, accountNonExpired=true&#125;(String), true(Boolean)</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">19.218</span> DEBUG <span class="number">12260</span> --- [io-<span class="number">50000</span>-exec-<span class="number">7</span>] c.b.server.mapper.AdminMapper.selectOne  : &lt;==      Total: <span class="number">0</span></span><br><span class="line"><span class="number">2021</span>-<span class="number">07</span>-<span class="number">18</span> <span class="number">22</span>:<span class="number">50</span>:<span class="number">19.221</span> ERROR <span class="number">12260</span> --- [io-<span class="number">50000</span>-exec-<span class="number">7</span>] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() <span class="keyword">for</span> servlet [dispatcherServlet] in context with path [] threw exception</span><br><span class="line"></span><br><span class="line">java.lang.NullPointerException: <span class="keyword">null</span></span><br><span class="line">at com.born2do.server.config.security.JwtTokenUtil.validateToken(JwtTokenUtil.java:<span class="number">110</span>) ~[classes/:na]</span><br><span class="line">at com.born2do.server.config.security.JwtAuthorizationTokenFilter.doFilterInternal(JwtAuthorizationTokenFilter.java:<span class="number">47</span>) ~[classes/:na]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:<span class="number">336</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:<span class="number">103</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.authentication.logout.LogoutFilter.doFilter(LogoutFilter.java:<span class="number">89</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:<span class="number">336</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.header.HeaderWriterFilter.doHeadersAfter(HeaderWriterFilter.java:<span class="number">90</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.header.HeaderWriterFilter.doFilterInternal(HeaderWriterFilter.java:<span class="number">75</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:<span class="number">336</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:<span class="number">110</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.context.SecurityContextPersistenceFilter.doFilter(SecurityContextPersistenceFilter.java:<span class="number">80</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:<span class="number">336</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter.doFilterInternal(WebAsyncManagerIntegrationFilter.java:<span class="number">55</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy$VirtualFilterChain.doFilter(FilterChainProxy.java:<span class="number">336</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy.doFilterInternal(FilterChainProxy.java:<span class="number">211</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.security.web.FilterChainProxy.doFilter(FilterChainProxy.java:<span class="number">183</span>) ~[spring-security-web-<span class="number">5.4</span><span class="number">.6</span>.jar:<span class="number">5.4</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.DelegatingFilterProxy.invokeDelegate(DelegatingFilterProxy.java:<span class="number">358</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.DelegatingFilterProxy.doFilter(DelegatingFilterProxy.java:<span class="number">271</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">189</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">162</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:<span class="number">100</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">189</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">162</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:<span class="number">93</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">189</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">162</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:<span class="number">201</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:<span class="number">119</span>) ~[spring-web-<span class="number">5.3</span><span class="number">.6</span>.jar:<span class="number">5.3</span><span class="number">.6</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:<span class="number">189</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:<span class="number">162</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:<span class="number">202</span>) ~[tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:<span class="number">97</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:<span class="number">542</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:<span class="number">143</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:<span class="number">92</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:<span class="number">78</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:<span class="number">357</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:<span class="number">374</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:<span class="number">65</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:<span class="number">893</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:<span class="number">1707</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:<span class="number">49</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>) [na:<span class="number">1.8</span><span class="number">.0_191</span>]</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>) [na:<span class="number">1.8</span><span class="number">.0_191</span>]</span><br><span class="line">at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:<span class="number">61</span>) [tomcat-embed-core-<span class="number">9.0</span><span class="number">.45</span>.jar:<span class="number">9.0</span><span class="number">.45</span>]</span><br><span class="line">at java.lang.Thread.run(Thread.java:<span class="number">748</span>) [na:<span class="number">1.8</span><span class="number">.0_191</span>]</span><br></pre></td></tr></table></figure><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>查看日志、debug发现出现了空指针异常，具体位置是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UserDetails userDetails = userDetailsService.loadUserByUsername(username);</span><br></pre></td></tr></table></figure><p>这里的username是通过token获取的，通过debug发现这个从token而来的username竟然是个完整的admin对象，所以才导致了从数据库查询时结果为空。</p><p>实际上我们的token只需要保存username就可以了，所以定位到了生成token的那部分代码，发现在生成token时将整个admin放了进去，这是不对的。</p><p>后修改了这部分代码，在生成token时只传入了username属性，问题解决。</p>]]></content>
    
    
    <summary type="html">SpringSecurity登陆后访问其他资源提示未登录</summary>
    
    
    
    
    <category term="SpringSecurity" scheme="https://born2do.github.io/tags/SpringSecurity/"/>
    
  </entry>
  
  <entry>
    <title>Swagger2 UI 提示&#39;请确保swagger资源接口正确&#39;</title>
    <link href="https://born2do.github.io/2021/07/18/Swagger2-UI-%E6%8F%90%E7%A4%BA-%E8%AF%B7%E7%A1%AE%E4%BF%9Dswagger%E8%B5%84%E6%BA%90%E6%8E%A5%E5%8F%A3%E6%AD%A3%E7%A1%AE/"/>
    <id>https://born2do.github.io/2021/07/18/Swagger2-UI-%E6%8F%90%E7%A4%BA-%E8%AF%B7%E7%A1%AE%E4%BF%9Dswagger%E8%B5%84%E6%BA%90%E6%8E%A5%E5%8F%A3%E6%AD%A3%E7%A1%AE/</id>
    <published>2021-07-17T23:15:34.000Z</published>
    <updated>2021-07-18T15:18:21.980Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>Swagger2 UI 提示“请确保swagger资源接口正确”，前台页面没有内容。</p><p><img src="https://i.loli.net/2021/07/18/5iuzfrvlIqbSgoZ.png" alt="image-20210718071827858.png"></p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>网络上的大多博客都说是“由于注解使用错误，json格式不正确导致的swagger接口文档报错”。然而我的并非如此，网络调试显示401-未登录。</p></li><li><p>状态是未登录，然而这个页面应该是无需登录就可以查看的，很明显是被拦截了。查看了放行的url，发现放行的swagger资源目录写错了，应该是<code>/swagger-resources/**</code>，而非<code>/swagger-resource/**</code>。</p></li><li><p>修改后重启应用，重新访问swagger页面，一切正常。</p><p><img src="https://i.loli.net/2021/07/18/VOkgTdNf7cXyP68.png" alt="image-20210718072954008.png"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;Swagger2 UI 提示“请确保swagger资源接口正确”，前台页面没有内容。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.</summary>
      
    
    
    
    
    <category term="Swagger2 UI" scheme="https://born2do.github.io/tags/Swagger2-UI/"/>
    
  </entry>
  
  <entry>
    <title>GIT学习</title>
    <link href="https://born2do.github.io/2021/07/13/GIT%E5%AD%A6%E4%B9%A0/"/>
    <id>https://born2do.github.io/2021/07/13/GIT%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-07-12T23:37:30.000Z</published>
    <updated>2021-07-12T23:38:11.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h1><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p>下图展示了 Git 的工作流程：</p><p><img src="https://i.loli.net/2021/03/11/VkgJTNlHrK3BYtw.png" alt="git-process.png"></p><h1 id="Git-工作区、暂存区和版本库"><a href="#Git-工作区、暂存区和版本库" class="headerlink" title="Git 工作区、暂存区和版本库"></a>Git 工作区、暂存区和版本库</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>我们先来理解下 Git 工作区、暂存区和版本库概念：</p><ul><li><strong>工作区：</strong>就是你在电脑里能看到的目录。</li><li><strong>暂存区：</strong>英文叫 stage 或 index。一般存放在 <strong>.git</strong> 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库：</strong>工作区有一个隐藏目录 <strong>.git</strong>，这个不算工作区，而是 Git 的版本库。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：</p><p><img src="https://i.loli.net/2021/03/11/hd2GlVX4cwax9Hk.jpg" alt="Git 工作区、暂存区和版本库.jpg"></p><ul><li>图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。</li><li>图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。</li><li>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</li><li>当对工作区修改（或新增）的文件执行 <strong>git add</strong> 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</li><li>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</li><li>当执行 <strong>git reset HEAD</strong> 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 **git rm –cached ** 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <strong>git checkout .</strong> 或者 **git checkout – ** 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</li><li>当执行 <strong>git checkout HEAD .</strong> 或者 **git checkout HEAD ** 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</li></ul><h1 id="Git基本操作"><a href="#Git基本操作" class="headerlink" title="Git基本操作"></a>Git基本操作</h1><p>Git的安装以及配置不在此做过多赘述。以下实操均在Windows10环境下操作。</p><p>1）在D盘新建文件夹“workspace”，进入该文件夹，右键鼠标，选择“Git Bash Here”，进入git命令行，可执行Linux下的一些命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git init learnGit</span></span><br><span class="line">Initialized empty Git repository in D:/workspace/learnGit/.git/ </span><br></pre></td></tr></table></figure><p>我们可以看到workspace文件夹下新建了learnGit文件夹，并且在learnGit文件夹中有个**.git**文件夹，这个文件夹就是Git的本地版本库。</p><p>2）在learnGit文件夹下新建文件readme.txt：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> learnGit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lrt</span></span><br><span class="line">total 0</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> vi readme.txt</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls -lrt</span></span><br><span class="line">total 1</span><br><span class="line">-rw-r--r-- 1 *** 197121 4  3月 11 21:31 readme.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）查看文件状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line"></span><br><span class="line">        readme.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到readme.txt这个文件的状态是既没有添加到缓存区也没有提交到本地版本库。</p><p>4）添加文件到缓存区，并再次查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt                                                                     warning: LF will be replaced by CRLF <span class="keyword">in</span> readme.txt.</span></span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status                                                                             On branch master</span></span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，文件已经添加至缓存区，等待提交至版本库。</p><p>5）提交文件到版本库，并再次查看状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;first commit&quot;</span>                                                           [master (root-commit) 805a3d4] first commit</span></span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status                                                                             On branch master</span></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>此时，本地文件与本地版本库已经完全一致。</p><p>6）使用编辑器修改本地文件readme.txt，再比较本地文件（工作区）与缓存区的差异。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line">warning: LF will be replaced by CRLF in readme.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 5626abf..814f4a4 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> one</span><br><span class="line">+two</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到工作区比暂存区文件多出一行。</p><p>7）比较工作区与本地版本库文件的差异：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff master</span></span><br><span class="line">warning: LF will be replaced by CRLF in readme.txt.</span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 5626abf..814f4a4 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> one</span><br><span class="line">+two</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>8）将文件添加至缓存区，比较缓存区与本地版本库的差异：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add readme.txt                                                                     warning: LF will be replaced by CRLF <span class="keyword">in</span> readme.txt.</span></span><br><span class="line">The file will have its original line endings in your working directory</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached                                                                      diff --git a/readme.txt b/readme.txt</span></span><br><span class="line">index 5626abf..814f4a4 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> one</span><br><span class="line">+two</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>9）添加至版本库，并查看提交日志。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;secode&quot;</span></span></span><br><span class="line">[master 2238358] secode</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -v</span></span><br><span class="line">commit 22383582753d734a5e57c816be15d79e9ce26754 (HEAD -&gt; master)</span><br><span class="line">Author: *** &lt;***@163.com&gt;</span><br><span class="line">Date:   Thu Mar 11 22:17:59 2021 +0800</span><br><span class="line"></span><br><span class="line">    secode</span><br><span class="line"></span><br><span class="line">commit 805a3d475a05485393de8b85374b35accccae9fe</span><br><span class="line">Author: *** &lt;***@163.com&gt;</span><br><span class="line">Date:   Thu Mar 11 21:41:48 2021 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line">22383582753d734a5e57c816be15d79e9ce26754 (HEAD -&gt; master) secode</span><br><span class="line">805a3d475a05485393de8b85374b35accccae9fe first commit</span><br></pre></td></tr></table></figure><p>可以看到全部共两次提交的记录。</p><p>10）回退到上一个版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard head^                                                                 HEAD is now at 805a3d4 first commit</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">one</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>11）回退到任意版本（hard后面的版本号不必写全）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard 22383582753d734a5e57c816be15d79e9ce26754</span></span><br><span class="line">HEAD is now at 2238358 secode</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat readme.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>使用文本的方式演示实在是太麻烦了，更多实用操作请自行检索。</p><p>也可参照B站视频，走一遍流程也就差不多了。</p><p>视频地址：<a href="https://www.bilibili.com/video/BV1oJ411d71q?p=1">https://www.bilibili.com/video/BV1oJ411d71q?p=1</a></p></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.runoob.com/git/git-tutorial.html">https://www.runoob.com/git/git-tutorial.html</a></p>]]></content>
    
    
    <summary type="html">GIT学习</summary>
    
    
    
    <category term="GIT" scheme="https://born2do.github.io/categories/GIT/"/>
    
    
    <category term="GIT" scheme="https://born2do.github.io/tags/GIT/"/>
    
  </entry>
  
  <entry>
    <title>本地maven仓库清理</title>
    <link href="https://born2do.github.io/2021/07/13/%E6%9C%AC%E5%9C%B0maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86/"/>
    <id>https://born2do.github.io/2021/07/13/%E6%9C%AC%E5%9C%B0maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86/</id>
    <published>2021-07-12T23:08:33.000Z</published>
    <updated>2021-07-12T23:11:19.611Z</updated>
    
    <content type="html"><![CDATA[<p>Windows环境下，清理本地maven仓库。</p><p>清理脚本如下：</p><figure class="highlight bat"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> REPOSITORY_PATH=D:\MavenRepository</span><br><span class="line"><span class="comment">rem 正在搜索...</span></span><br><span class="line"><span class="keyword">for</span> /f &quot;delims=&quot; <span class="variable">%%i</span> <span class="keyword">in</span> (&#x27;<span class="built_in">dir</span> /b /s &quot;<span class="variable">%REPOSITORY_PATH%</span>\*lastUpdated*&quot;&#x27;) <span class="keyword">do</span> (</span><br><span class="line">    <span class="built_in">del</span> /s /q <span class="variable">%%i</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">rem 搜索完毕</span></span><br><span class="line"><span class="built_in">pause</span></span><br></pre></td></tr></table></figure><p>对路径稍作修改，运行一下即可。</p>]]></content>
    
    
    <summary type="html">本地maven仓库清理</summary>
    
    
    
    <category term="清理" scheme="https://born2do.github.io/categories/%E6%B8%85%E7%90%86/"/>
    
    
    <category term="maven" scheme="https://born2do.github.io/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>注解+AOP实现日志功能</title>
    <link href="https://born2do.github.io/2021/07/06/%E6%B3%A8%E8%A7%A3-AOP%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/"/>
    <id>https://born2do.github.io/2021/07/06/%E6%B3%A8%E8%A7%A3-AOP%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/</id>
    <published>2021-07-06T14:23:52.000Z</published>
    <updated>2021-07-06T15:04:27.599Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>现有项目有两类日志系统，一个是logback日志，一个是框架层面自己实现的对特定库表数据增删改查操作的日志。但是对于前台的用于生成文档、或是生成库表数据的按钮并没有加以控制，无法得知操作人员进行了哪些操作。项目经理要求加这么个通用模块，也的确很有必要。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol><li>对于这个通用日志模块，首先肯定是要设计一个库表，自行设计即可。用户、模块、方法功能、参数列表、参数值、时间戳等等。</li><li>采用何种方式去实现该功能？系统现有的两个日志框架，对于这个通用日志模块的开发，并无太大用处。需要另辟蹊径。</li><li>实现该功能应该注意哪些？由于是对原有系统功能加操作日志，首先不能影响原有功能的实现，其次不能对原有代码造成过大的侵入性（这也是我拒绝在原有代码中进行将操作日志插入库表的原因），还有不能影响效率等等。</li><li>考虑到这，我的选择是AOP，因为切面的方式可以完美解决上述考虑。</li><li>但是，我们对哪些操作需要进行记录操作日志是有选择的，考虑到项目比较大，总不能指定所有的包吧？所以我选择了使用自定义注解的方式。</li><li>最终，自定义注解+AOP的实现方式被我采纳。</li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>自定义注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.born2do.emsys.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义日志注解</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LogAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">module</span><span class="params">()</span></span>;   <span class="comment">//模块名</span></span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">function</span><span class="params">()</span></span>;   <span class="comment">//功能名</span></span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">remark</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;  <span class="comment">//自定义内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.born2do.emsys.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.born2do.emsys.annotation.LogAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/7/1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span>   <span class="comment">//表示为切面类</span></span><br><span class="line"><span class="meta">@Component</span>  <span class="comment">//交由spring去管理</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span> <span class="comment">//默认为false。true表示使用cglib代理，false表示jdk动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAnnotationAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置切入点（此处为使用LogAnnotation注解的方法）</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;@annotation(com.born2do.emsys.annotation.LogAnnotation)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before(&quot;pointcutConfig()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知--方法前执行&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After(&quot;pointcutConfig()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知--方法后执行&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning(&quot;pointcutConfig()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回通知--调用获得返回值后执行&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing(&quot;pointcutConfig()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知--抛出异常后执行&quot;</span> + joinPoint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around(&quot;pointcutConfig()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*result为连接点的放回结果*/</span></span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 目标类</span></span><br><span class="line">        Class targetClass = pjp.getTarget().getClass();</span><br><span class="line">        <span class="comment">// 目标类的所有方法</span></span><br><span class="line">        Method[] methods = targetClass.getMethods();</span><br><span class="line">        <span class="comment">// 切点方法</span></span><br><span class="line">        String methodName = pjp.getSignature().getName();</span><br><span class="line">        <span class="comment">// 切点方法传入的参数值</span></span><br><span class="line">        Object[] argsValue = pjp.getArgs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            <span class="comment">//找到切入点对应的方法</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(methodName)) &#123;</span><br><span class="line">                <span class="comment">//拿到方法上的注解对象，获取参数值</span></span><br><span class="line">                LogAnnotation logAnnotation = method.getAnnotation(LogAnnotation.class);</span><br><span class="line">                String <span class="keyword">module</span> = logAnnotation.<span class="keyword">module</span>();</span><br><span class="line">                String function = logAnnotation.function();</span><br><span class="line">                String remark = logAnnotation.remark();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取该切点方法的参数列表</span></span><br><span class="line">                Object[] param = method.getParameters();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*前置通知*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知：目标类名：&quot;</span> + targetClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*执行目标方法*/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = pjp.proceed();</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*返回通知*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;返回通知：目标方法名&quot;</span> + methodName + <span class="string">&quot;，返回结果为：&quot;</span> + result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">/*异常通知*/</span></span><br><span class="line">            System.out.println(<span class="string">&quot;异常通知：目标方法名&quot;</span> + methodName + <span class="string">&quot;，异常为：&quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*后置通知*/</span></span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知：目标方法名&quot;</span> + methodName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基本上所有参数都已经获取，在此处可以进行插入库表等操作</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.born2do.emsys.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.born2do.emsys.annotation.LogAnnotation;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/6/4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LogAnnotation(module = &quot;测试模块&quot;, function = &quot;用于测试SpringMVC项目框架是否搭建成功&quot;)</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">(<span class="meta">@RequestParam(&quot;id&quot;)</span> <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;进入 /test 路径&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通用日志功能的实现主要依靠于前两个类，当然，在目标方法上添加自定义注解也很重要。</p><p>如想运行上述代码，还请自行新建SpringBoot项目，将代码嵌入项目中。</p><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>浏览器访问 localhost:50000/test?id=1</p><p>控制台输出如下日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">前置通知：目标类名：com.born2do.emsys.controller.TestController</span><br><span class="line">前置通知--方法前执行execution(String com.born2do.emsys.controller.TestController.test(int))</span><br><span class="line">进入 &#x2F;test 路径</span><br><span class="line">返回通知--调用获得返回值后执行execution(String com.born2do.emsys.controller.TestController.test(int))</span><br><span class="line">后置通知--方法后执行execution(String com.born2do.emsys.controller.TestController.test(int))</span><br><span class="line">返回通知：目标方法名test，返回结果为：OK</span><br><span class="line">后置通知：目标方法名test</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">注解+AOP实现日志功能</summary>
    
    
    
    
    <category term="注解" scheme="https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
    <category term="AOP" scheme="https://born2do.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>【MySQL】MySQL自带数据库解析</title>
    <link href="https://born2do.github.io/2021/06/02/%E3%80%90MySQL%E3%80%91MySQL%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E6%9E%90/"/>
    <id>https://born2do.github.io/2021/06/02/%E3%80%90MySQL%E3%80%91MySQL%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E6%9E%90/</id>
    <published>2021-06-02T14:36:12.000Z</published>
    <updated>2021-06-02T14:38:59.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>MySQL数据库版本<br>Welcome to the MySQL monitor.  Commands end with ; or \g.<br>Your MySQL connection id is 265<br>Server version: 5.7.25 MySQL Community Server (GPL)<br>Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.<br>Oracle is a registered trademark of Oracle Corporation and/or its<br>affiliates. Other names may be trademarks of their respective<br>owners.<br>Type ‘help;’ or ‘\h’ for help. Type ‘\c’ to clear the current input statement.</p></blockquote><h2 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h2><p>information_schema保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。在information_schema中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。<br>information_schema数据库表说明:<br>SCHEMATA：提供了当前mysql实例中所有数据库的信息。<code>show databases;</code><br>TABLES：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。<code>show tables from schemaname;</code><br>COLUMNS：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。<code>show columns from schemaname.tablename;</code><br>STATISTICS：提供了关于表索引的信息。<code>show index from schemaname.tablename;</code><br>USER_PRIVILEGES（用户权限）：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。<br>SCHEMA_PRIVILEGES（方案权限）：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。<br>TABLE_PRIVILEGES（表权限）：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。<br>COLUMN_PRIVILEGES（列权限）：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。<br>CHARACTER_SETS（字符集）：提供了mysql实例可用字符集的信息。<code>show character set;</code><br>COLLATIONS：提供了关于各字符集的对照信息。<br>COLLATION_CHARACTER_SET_APPLICABILITY：指明了可用于校对的字符集。这些列等效于<code>show collation;</code>的前两个显示字段。<br>TABLE_CONSTRAINTS：描述了存在约束的表。以及表的约束类型。<br>KEY_COLUMN_USAGE：描述了具有约束的键列。<br>ROUTINES：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。<br>VIEWS：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。<br>TRIGGERS：提供了关于触发程序的信息。必须有super权限才能查看该表。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><p>mysql是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。</p><h2 id="performance-schema"><a href="#performance-schema" class="headerlink" title="performance_schema"></a>performance_schema</h2><p>performance_schema主要用于收集数据库服务器性能参数，如提供进程等待的详细信息，包括锁、互斥变量、文件信息；保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断；对于新增和删除监控事件点都非常容易，并可以改变MySQL服务器的监控周期等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; use performance_schema;</span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| Tables_in_performance_schema                 |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">| cond_instances                               |</span><br><span class="line">| events_waits_current                         |</span><br><span class="line">| events_waits_history                         |</span><br><span class="line">| events_waits_history_long                    |</span><br><span class="line">| events_waits_summary_by_instance             |</span><br><span class="line">| events_waits_summary_by_thread_by_event_name |</span><br><span class="line">| events_waits_summary_global_by_event_name    |</span><br><span class="line">| file_instances                               |</span><br><span class="line">| file_summary_by_event_name                   |</span><br><span class="line">| file_summary_by_instance                     |</span><br><span class="line">| mutex_instances                              |</span><br><span class="line">| performance_timers                           |</span><br><span class="line">| rwlock_instances                             |</span><br><span class="line">| setup_consumers                              |</span><br><span class="line">| setup_instruments                            |</span><br><span class="line">| setup_timers                                 |</span><br><span class="line">| threads                                      |</span><br><span class="line">+----------------------------------------------+</span><br><span class="line">17 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>这里的数据表分为几类：<br>1）setup table ：  设置表，配置监控选项。<br>2）current events table : 记录当前那些thread 正在发生什么事情。<br>3）history table  发生的各种事件的历史记录表<br>4）summary table  对各种事件的统计表<br>5）其他。<br>setup 表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES</span><br><span class="line">    -&gt; WHERE TABLE_SCHEMA &#x3D; &#39;performance_schema&#39;</span><br><span class="line">    -&gt; AND TABLE_NAME LIKE &#39;setup%&#39;;</span><br><span class="line">+-------------------+</span><br><span class="line">| TABLE_NAME        |</span><br><span class="line">+-------------------+</span><br><span class="line">| setup_consumers   |</span><br><span class="line">| setup_instruments |</span><br><span class="line">| setup_timers      |</span><br><span class="line">+-------------------+</span><br></pre></td></tr></table></figure><p>setup_consumers 描述各种事件<br>setup_instruments 描述这个数据库下的表名以及是否开启监控。<br>setup_timers   描述监控选项已经采样频率的时间间隔</p><h2 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h2><p>sys是MySQL5.7新增的系统数据库，其在MySQL5.7中是默认存在的，在MySQL5.6及以上版本可以手动导入。这个库通过视图的形式把information_schema和performance_schema结合起来，查询出更加令人容易理解的数据。</p>]]></content>
    
    
    <summary type="html">【MySQL】MySQL自带数据库解析</summary>
    
    
    
    <category term="MySQL" scheme="https://born2do.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://born2do.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>【FTP】Windows访问vsftp服务器报错</title>
    <link href="https://born2do.github.io/2021/05/26/%E3%80%90FTP%E3%80%91Windows%E8%AE%BF%E9%97%AEvsftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99/"/>
    <id>https://born2do.github.io/2021/05/26/%E3%80%90FTP%E3%80%91Windows%E8%AE%BF%E9%97%AEvsftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99/</id>
    <published>2021-05-26T13:24:24.000Z</published>
    <updated>2021-05-26T13:30:50.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h1><p>Windows连接vsftp服务器放置文件，报错如下：</p><blockquote><p>打开FTP服务器上的文件夹时发生错误。请检查是否有权限访问该文件夹。<br>详细信息：<br>200 Switching to ASCII model.<br>277 Entering Passive Model(192,184,90).</p></blockquote><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>port方式在传输数据时，是Server端连接client端，有一个条件：它必须有一个公网ip。<br>如果client处于防火墙或net网关后面，server就找不到client端，就会报错。<br>所有的ftp客户端软件都支持两种传输方式，IE默认是port(主动)。</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>IE浏览器-&gt;Internet选项-&gt;高级-&gt;将“使用被动FTP（用于防火墙和DSL调制解调器的兼容）”选项去掉勾选-&gt;确定。</p><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="FTP主动模式-active-mode-与被动模式-passive-mode-的工作原理"><a href="#FTP主动模式-active-mode-与被动模式-passive-mode-的工作原理" class="headerlink" title="FTP主动模式(active mode)与被动模式(passive mode)的工作原理"></a>FTP主动模式(active mode)与被动模式(passive mode)的工作原理</h2><p>主动模式（服务器向客户端敲门，然后客户端开门）FTP：<br>客户机与服务器之间建立连接时，客户机是大于1024的端口上，服务器是20端口。<br>客户机的端口是大于1024的，而服务器的端口是21端口接收请求，而是20端口给客户机回应。<br>允许FTP客户机从大于1024的端口连接服务器的21端口。<br>允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。<br>允许FTP服务器从20端口主动连接FTP客户机中大于1024的端口。<br>允许FTP客户机从大于1024的端口回应来自FTP服务器的20端口的网络连接。<br>命令连接：客户端大于1024的端口 -&gt; 服务器 21端口<br>数据连接：服务器 20端口 -&gt; 客户端大于1024的端口<br><img src="https://i.loli.net/2021/05/26/Zq3Ph4E6fV5CUST.jpg" alt="20171226094239038.jpg"></p><p>被动模式（客户端向服务器敲门，然后服务器开门）FTP：<br>客户机与服务器之间建立连接都是在大于1024的端口上的。<br>客户机的端口是大于1024的，而服务器的端口是21端口接收请求，而是从大于1024端口给客户机回应。<br>允许FTP客户机从大于1024的端口连接服务器的21端口。<br>允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。<br>允计FTP客户机从大于1024的端口连接FTP服务器的大于1024端口。<br>允许FTP服务器从大于1024的端口回应来自FTP客户机大于1024端口的网络连接。<br>命令连接：客户端大于1024的端口 -&gt; 服务器 21端口<br>数据连接：客户端大于1024的端口 -&gt; 服务器大于1024的端口<br><img src="https://i.loli.net/2021/05/26/6JYPSu9rCQBgkvn.jpg" alt="20171226094256663.jpg"></p>]]></content>
    
    
    <summary type="html">【FTP】Windows访问vsftp服务器报错</summary>
    
    
    
    <category term="FTP" scheme="https://born2do.github.io/categories/FTP/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】给其他用户开启crontab</title>
    <link href="https://born2do.github.io/2021/05/24/%E3%80%90Linux%E3%80%91%E7%BB%99%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%BC%80%E5%90%AFcrontab/"/>
    <id>https://born2do.github.io/2021/05/24/%E3%80%90Linux%E3%80%91%E7%BB%99%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%BC%80%E5%90%AFcrontab/</id>
    <published>2021-05-24T13:58:54.000Z</published>
    <updated>2021-05-24T13:59:21.728Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器上新建了vlog用户，想要开启定时任务，但是系统直接提示没有crontab权限。<br>解决：<br>使用vlog用户登录，执行如下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 找到crontab命令所在路径</span></span><br><span class="line">cd /usr/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 给其他用户赋权限</span></span><br><span class="line">chmod o+x crontab</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【Linux】给其他用户开启crontab</summary>
    
    
    
    <category term="Linux" scheme="https://born2do.github.io/categories/Linux/"/>
    
    
    <category term="crontab" scheme="https://born2do.github.io/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>【Java】IO流未正确关闭导致的读写问题</title>
    <link href="https://born2do.github.io/2021/05/22/%E3%80%90Java%E3%80%91IO%E6%B5%81%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98/"/>
    <id>https://born2do.github.io/2021/05/22/%E3%80%90Java%E3%80%91IO%E6%B5%81%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-22T08:58:55.000Z</published>
    <updated>2021-05-22T08:59:30.628Z</updated>
    
    <content type="html"><![CDATA[<h1 id="情景再现"><a href="#情景再现" class="headerlink" title="情景再现"></a>情景再现</h1><p>同事写的一段代码，主要功能是生成本地文件并调用脚本将其连同上级文件夹进行打包，应用环境为Linux。但是，在服务器上运行后，发现打包的文件为空文件。</p><h1 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h1><p>因为本地开发环境为Windows，并不能执行shell脚本，所以同事在本地开发测试时认为文件正常生成就基本没问题了，也就没顾及太多将代码提交了。<br>因为本地正常生成文件，而服务器的压缩包没有文件内容，所以我首先对本地与SVN上的代码进行了比对，排查是否是由于代码问题导致源文件根本就没有生成内容继而导致目标压缩包中的文件也没有内容。</p><ul><li>比对本地代码与SVN上的代码后，并无发现异常，排除代码提交问题。</li><li>修改了应用服务器上的shell脚本，使其在正常打包后不删除源文件。再次执行相关作业，源文件内容正常，目标压缩包中的文件为空白。排除了代码导致的源文件内容未正常生成。</li><li>代码和文件都没有发现问题，源文件也正常生成，那就可能是打包的问题了。在源文件正常存在的情形下，使用相关用户执行该脚本，发现正常打包，文件一切正常。</li><li>手工执行脚本，文件正常打包，而应用执行脚本却发生了，打包后文件内容为空白的情况。我又怀疑是权限问题，因为如果没有读写权限的话，cp或是tar也会发生目标文件为空的情况。我在脚本中给源文件夹添加了777的权限，这下总不能再失败了吧。</li><li>执行结果与前几次相同，目标压缩包中的文件仍为空白。排除权限问题。</li><li>排除到这时候，已经没有了方向。我尝试着对其他文件夹进行打包操作，发现全部都正常打包了，并未发生内容丢失的情况。说明脚本中打包命令的使用是没有问题的。</li><li>在目标文件夹放入了其他文件，和之前生成的源文件（名字改掉），再次执行作业，打包的结果显示，只有程序生成的那个文件打包后发生内容丢失的情况。排查方向又再次回来了，打包时文件的状态不对劲。</li><li>文件状态不对，又涉及到文件读写，我的第一反应是IO流的处理。但是我们是有代码扫描的，之前她就提过一版专门修复流的问题，是通过的呀？流肯定是关闭了的。</li><li>我在本地更新代码后，一眼就看到了问题。IO流的确是被关闭了，但是调用脚本进行打包的时机不对，那个时候流还未关闭。这就导致了，调用脚本在进行打包操作时，源文件的状态是正在被写入当中，服务器在执行tar命令时，读取到的文件是空白的，这也很好地解释了为什么源文件正常，而目标压缩包中文件为空白。也能解释为什么手工执行脚本，一切正常，因为那时候源文件的状态已经是写完成的状态了，不再被其他线程占用。</li><li>下面是问题代码的demo<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">OutputStreamWriter osw = <span class="keyword">null</span>;</span><br><span class="line">BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;d:\\a.txt&quot;</span>);</span><br><span class="line">osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">bw.write(<span class="string">&quot;java IO close test&quot;</span>);</span><br><span class="line"><span class="comment">// 调用shell脚本进行打包操作</span></span><br><span class="line">doTarFile();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;bw未关闭&quot;</span>);</span><br><span class="line">bw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (osw != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;osw未关闭&quot;</span>);</span><br><span class="line">osw.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;fos未关闭&quot;</span>);</span><br><span class="line">fos.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h1><p>脚本不做改动，代码中调用脚本的那段代码提出来，放到外层方法的写文件方法之后。</p>]]></content>
    
    
    <summary type="html">【Java】IO流未正确关闭导致的读写问题</summary>
    
    
    
    <category term="Java" scheme="https://born2do.github.io/categories/Java/"/>
    
    
    <category term="IO流" scheme="https://born2do.github.io/tags/IO%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>【DB2】常用SQL函数</title>
    <link href="https://born2do.github.io/2021/05/16/%E3%80%90DB2%E3%80%91%E5%B8%B8%E7%94%A8SQL%E5%87%BD%E6%95%B0/"/>
    <id>https://born2do.github.io/2021/05/16/%E3%80%90DB2%E3%80%91%E5%B8%B8%E7%94%A8SQL%E5%87%BD%E6%95%B0/</id>
    <published>2021-05-16T09:32:22.000Z</published>
    <updated>2021-05-16T09:32:48.085Z</updated>
    
    <content type="html"><![CDATA[<h2 id="coalesce函数"><a href="#coalesce函数" class="headerlink" title="coalesce函数"></a>coalesce函数</h2><p>COALESCE是一个函数，(expression_1, expression_2, …,expression_n)依次参考各参数表达式，遇到非null值即停止并返回该值。如果所有的表达式都是空值，最终将返回一个空值。使用COALESCE在于大部分包含空值的表达式最终将返回空值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select coalesce(null,33) as test;</span><br></pre></td></tr></table></figure><p>返回33。</p><h2 id="case函数"><a href="#case函数" class="headerlink" title="case函数"></a>case函数</h2><h3 id="简单case函数"><a href="#简单case函数" class="headerlink" title="简单case函数"></a>简单case函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case sex</span><br><span class="line">    when &#39;1&#39; then &#39;男&#39;</span><br><span class="line">    when &#39;2&#39; then &#39;女&#39;</span><br><span class="line">    else &#39;其他&#39; </span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="case搜索函数"><a href="#case搜索函数" class="headerlink" title="case搜索函数"></a>case搜索函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">case </span><br><span class="line">    when sex &#x3D; &#39;1&#39; then &#39;男&#39;</span><br><span class="line">    when sex &#x3D; &#39;2&#39; then &#39;女&#39;</span><br><span class="line">    else &#39;其他&#39; </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>这两种方式，可以实现相同的功能。简单case函数的写法相对比较简洁，但是和case搜索函数相比，功能方面会有些限制，比如写判定式。</li><li>还有一个需要注重的问题，case函数（两种）只返回第一个符合条件的值，剩下的case部分将会被自动忽略。</li></ul>]]></content>
    
    
    <summary type="html">【DB2】常用SQL函数</summary>
    
    
    
    <category term="DB2" scheme="https://born2do.github.io/categories/DB2/"/>
    
    
    <category term="函数" scheme="https://born2do.github.io/tags/%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>【eclipse】新建的maven工程没有显示.calsspath、.project等文件</title>
    <link href="https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BA%E7%9A%84maven%E5%B7%A5%E7%A8%8B%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA-calsspath%E3%80%81-project%E7%AD%89%E6%96%87%E4%BB%B6/"/>
    <id>https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BA%E7%9A%84maven%E5%B7%A5%E7%A8%8B%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA-calsspath%E3%80%81-project%E7%AD%89%E6%96%87%E4%BB%B6/</id>
    <published>2021-05-15T08:53:20.000Z</published>
    <updated>2021-05-15T08:53:38.533Z</updated>
    
    <content type="html"><![CDATA[<p>描述：</p><blockquote><p>使用eclipse新建的maven工程没有显示.calsspath、.project等文件</p></blockquote><p>解决：<br>1.选中工程，选择Filters。<br><img src="https://i.loli.net/2021/05/15/PtVn1H6rvoIwJab.png" alt="20141124115218046.png"></p><p>2.取消.resources勾选，点击OK即可。<br><img src="https://i.loli.net/2021/05/15/J47ECBkcaSnvsDV.png" alt="20141124115818232.png"></p><p>3.设置完成。</p>]]></content>
    
    
    <summary type="html">【eclipse】新建的maven工程没有显示.calsspath、.project等文件</summary>
    
    
    
    <category term="maven" scheme="https://born2do.github.io/categories/maven/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【eclipse】新建maven项目后pom.xml文件报错</title>
    <link href="https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%90%8Epom-xml%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/"/>
    <id>https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%90%8Epom-xml%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/</id>
    <published>2021-05-15T08:52:33.000Z</published>
    <updated>2021-05-15T08:52:58.139Z</updated>
    
    <content type="html"><![CDATA[<p>报错：  </p><ol><li>pom.xml命名空间报错。  </li><li><packaging>war</packaging>报错。  </li></ol><p>解决：  </p><ol><li>右键项目，选择maven，然后update project即可。命名空间报错消失。  </li><li>打包方式报错是由于工程中缺少了web.xml文件（/src/main/webapp/WEB-INF/web.xml）。项目名称–&gt;右键–&gt;Java EE Tools–&gt;generate deployment descriptor stub ，鼠标点击后，系统会自动加入 web.xml 省去手动 复制web.xml的步骤。</li></ol>]]></content>
    
    
    <summary type="html">【eclipse】新建maven项目后pom.xml文件报错</summary>
    
    
    
    <category term="maven" scheme="https://born2do.github.io/categories/maven/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【2019】牛客网Java笔记</title>
    <link href="https://born2do.github.io/2021/05/13/%E3%80%902019%E3%80%91%E7%89%9B%E5%AE%A2%E7%BD%91Java%E7%AC%94%E8%AE%B0/"/>
    <id>https://born2do.github.io/2021/05/13/%E3%80%902019%E3%80%91%E7%89%9B%E5%AE%A2%E7%BD%91Java%E7%AC%94%E8%AE%B0/</id>
    <published>2021-05-13T14:24:23.000Z</published>
    <updated>2021-05-13T14:25:40.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一星题"><a href="#一星题" class="headerlink" title="一星题"></a>一星题</h2><ol><li><p>方法重载：方法名称相同，参数列表不同（可以是参数的类型、个数、顺序不同）</p><p>方法重载满足的条件：</p><ul><li>同一个类中，方法名相同，参数列表不同的2个或多个方法构成方法的重载</li><li>参数列表不同指参数的类型，参数的个数，参数的顺序至少一项不同</li><li>方法的返回值类型，方法的修饰符可以不同。</li></ul><p>注意 ，如果两个方法只有返回值类型不同， 这两个方法在编译器看来还是同一个方法。</p></li><li><p>java源文件的后缀名是<code>.java</code>。</p><p>源文件通过jvm虚拟机编译后会生成二进制字节码文件，后缀是<code>.class</code>。</p></li><li><p>javac.exe是编译功能javaCompiler<br>java.exe是执行class</p><p>如果没有编译的话是不能执行的，同理，javac.exe编译完以后如果没有java.exe执行的话也是没有运行的。</p></li><li><blockquote><ol><li>一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： </li></ol><ul><li>Bootstrap ClassLoader：负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等。</li><li>Extension ClassLoader：负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar和class。</li><li>App ClassLoader：负责加载当前java应用的classpath中的所有类。</li></ul><ol start="2"><li><p>classloader 加载类用的是全盘负责委托机制。所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。<br>所以，当我们自定义的classloader加载成功了 com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。</p></li><li><p>比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。 </p></li><li><p>我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为<strong>类加载器的双亲委派模型</strong>，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用<strong>组合关系</strong>来复用父加载器的。</p></li></ol></blockquote></li><li><p>优先级：单目&gt;运算&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值</p><p>简记：淡云一笔安洛三幅。</p></li><li><blockquote><ul><li>动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=”included.jsp” flush=”true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。</li><li>静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=”included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。 </li><li>以下是对 include 两种用法的区别 ， 主要有两个方面的不同：<br>一、执行时间上 :<br> &lt;%@ include file=”relativeURI”%&gt; 是在翻译阶段执行 <pre><code>&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 在请求处理阶段执行。二、引入内容的不同 : &lt;%@ include file=&quot;relativeURI&quot;%&gt; 引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起。&lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 引入执行页面或 servlet 所生成的应答文本。</code></pre></li></ul></blockquote></li><li><p>方法的重写需要满足：三同一大一小（方法名、返回值类型、形参相同；访问权限&gt;=重写前；抛出异常&lt;=重写前）</p></li><li><p>优先级高的并不一定会马上执行。</p><p>sleep方法会阻塞一个线程并不会终止。</p><p>创建一个新的线程时也不会终止另一个线程。</p><p>当抛出一个异常后程序会结束，所以线程也会被终止。</p></li><li><p>java中将ISO8859-1字符串转成GB2312编码，语句为 ？</p><p>new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”)</p></li><li><blockquote><p>创建并启动线程的过程为：定义线程—》实例化线程—》启动线程。</p><p><strong>一 、定义线程：</strong>1、扩展java.lang.Thread类。   2、实现java.lang.Runnable接口。</p><p><strong>二、实例化线程：</strong></p><p>1、如果是扩展java.lang.Thread类的线程，则直接new即可。</p><p>2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;Thread(Runnable target) </span><br><span class="line">&gt;Thread(Runnable target, String name) </span><br><span class="line">&gt;Thread(ThreadGroup group, Runnable target) </span><br><span class="line">&gt;Thread(ThreadGroup group, Runnable target, String name) </span><br><span class="line">&gt;Thread(ThreadGroup group, Runnable target, String name, <span class="keyword">long</span> stackSize) </span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>Exception（异常）</strong><br>是程序本身可以处理的异常。主要包含RuntimeException等运行时异常和IOException，SQLException等非运行时异常。<br><strong>运行时异常</strong><br>包括：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。<br>运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。<br><strong>非运行时异常（编译异常）</strong><br>包括：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</p></li><li><p>io流方面的知识：要将文件中一个字符写入另一个文件，首先要读入（FileInputStream）到内存中去，然后再读出（FileOutputStream）。</p></li><li><blockquote><p>结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。</p><p>在GoF设计模式中，结构型模式有：</p><p><strong>1.适配器模式 Adapter</strong></p><p>适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。</p><p><strong>2.桥接模式 Bridge</strong></p><p>桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。</p><p><strong>3.组合模式 Composite</strong></p><p>组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。</p><p><strong>4.装饰模式 Decorator</strong></p><p>装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。</p><p><strong>装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。</strong> </p><p><strong>5.外观模式 Facade</strong></p><p>外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。</p><p><strong>6.享元模式 Flyweight</strong></p><p>享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。</p><p>享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。</p><p><strong>7.代理模式 Proxy</strong></p><p>为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。 </p></blockquote></li><li><blockquote><p>CGI(Common Gateway Interface)，通用网关接口<br>通用网关接口，简称CGI，是一种根据请求信息动态产生回应内容的技术。通过CGI，Web服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。因为每个进程都会占有很多服务器的资源和时间，这就导致服务器无法同时处理很多的并发请求。另外CGI程序都是与操作系统平台相关的，虽然在互联网爆发的初期，CGI为开发互联网应用做出了很大的贡献，但是随着技术的发展，开始逐渐衰落。<br>Servlet<br>Servlet最初是在1995年由James Gosling<br>提出的，因为使用该技术需要复杂的Web服务器支持，所以当时并没有得到重视，也就放弃了。后来随着Web应用复杂度的提升，并要求提供更高的并发处理能力，Servlet被重新捡起，并在Java平台上得到实现，现在提起Servlet，指的都是Java Servlet。Java<br>Servlet要求必须运行在Web服务器当中，与Web服务器之间属于分工和互补关系。确切的说，在实际运行的时候Java Servlet与Web服务器会融为一体，如同一个程序一样运行在同一个Java虚拟机（JVM）当中。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也就解决了跨平台问题。如果没有Servlet的出现，也就没有互联网的今天。<br>在Servlet出现之后，随着使用范围的扩大，人们发现了它的一个很大的一个弊端。那就是为了能够输出HTML格式内容，需要编写大量重复代码，造成不必要的重复劳动。为了解决这个问题，基于Servlet技术产生了JavaServet Pages技术，也就是JSP。Servlet和JSP两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。<br>——————–分割线————————- </p><ul><li>Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。</li><li>而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。</li><li>CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。</li></ul></blockquote></li><li><p>顶层容器是指可以不能被其他容器包含 ，是容纳其他容器的容器组件，<br>顶层容器包含JApplet、JDialog、JFrame和JWindow及其子类.<br>JFrame中就可以放Jtree（树形组件）。</p></li><li><p>Java继承中对构造函数是不继承的，只是显式或者隐式调用。</p></li><li><p>Java中有两种方式实现线程：</p><ul><li><p>class A继承Thread，并重写run方法，new A().start()，就执行了线程</p></li><li><p>class A实现Runnable，实现run方法，new Thread(new A()).start() </p><p>2.class A实现Runnable，实现run方法，new Thread(new A()).start() </p></li></ul><p>当然以上方式run方法都是无返回值的，如果需要返回值，需要Callable接口。</p></li><li><pre><code class="java">public static void main (String[] args) &#123;     String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;;    System.out.println(classFile);&#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    由于replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;&#x2F;&quot;。如果想替换的只是&quot;.&quot;，那么久要写成&quot;\\.&quot;。故结果为&#96;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;MyClass.class&#96;。</span><br><span class="line"></span><br><span class="line">19. 通过JDBC访问数据库包含下面哪几步？</span><br><span class="line"></span><br><span class="line">    - 载入JDBC驱动程序</span><br><span class="line">    - 建立连接</span><br><span class="line">    - 执行查询或更新</span><br><span class="line">    - 关闭连接</span><br><span class="line"></span><br><span class="line">20. 重载对返回值没有要求，可以相同，也可以不同；但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载。</span><br><span class="line"></span><br><span class="line">21. HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。</span><br><span class="line"></span><br><span class="line">22. &gt; Character 字符封装类</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;String 常量池中字符串</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;StringBuffer 存放字符数组</span><br><span class="line">  &gt;</span><br><span class="line">  &gt;Vector 数组</span><br><span class="line"></span><br><span class="line">23. 二维数组声明：</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;java</span><br><span class="line">    int [][] table &#x3D; new int[2][2];</span><br><span class="line">    int [][] table1 &#x3D; new int[2][];</span><br><span class="line">    int [] table2 [] &#x3D; new int[2][2]; </span><br><span class="line">    int [] table3 [] &#x3D; new int[2][];</span><br><span class="line">    int table4 [][] &#x3D; new int[2][2];</span><br><span class="line">    int table5 [][] &#x3D; new int[2][];</span><br></pre></td></tr></table></figure></code></pre></li><li><blockquote><ul><li>接口中声明的成员变量默认为static final成员（不管是基础数据类型还是引用类型），且必须初始化；</li><li>接口中声明的方法默认为public且不能有实现体，即｛｝，方法体可有参数；</li><li>实现接口的类，必须实现接口中所有方法，且不能降低方法的运用域，即必须显示声明为public；</li><li>抽象类不需要实现接口的方法。抽象类也可以实现接口，但是可以实现部分或者一个都不实现；</li><li>在jdk8之后添加了默认方法，在返回值加上default关键字，然后还有方法体;该接口被扩展时，可以直接继承或重新声明。还添加了静态方法。</li></ul></blockquote></li><li><p>非构造方法必须要有返回类型，其实构造方法的返回类型是void，只不过不能写出来而已。</p></li><li><p>局部变量的作用范围仅仅在定义它的方法内，或者是在定义它的控制流块中。</p></li><li><p>实例方法可直接调用本类的类方法。</p></li><li><p>在Applet中，方法执行的顺序是<code>init(), start(), paint(),stop(),destroy()</code>。</p></li><li><p>局部变量是定义在方法中的变量，必须要进行初始化，否则不能通过编译。</p></li><li><pre><code class="java">  class X&#123;   Y y=new Y();   public X()&#123;       System.out.print(&quot;X&quot;);   &#125;  &#125;  class Y&#123;   public Y()&#123;       System.out.print(&quot;Y&quot;);   &#125;  &#125;  public class Z extends X&#123;   Y y=new Y();   public Z()&#123;       System.out.print(&quot;Z&quot;);   &#125;   public static void main(String[] args) &#123;       new Z();   &#125;  &#125;</code></pre><blockquote><p>初始化过程：  </p><ol><li>初始化父类中的静态成员变量和静态代码块 ；  </li><li>初始化子类中的静态成员变量和静态代码块 ；</li><li>初始化父类的普通成员变量和代码块，再执行父类的构造方法； </li><li>初始化子类的普通成员变量和代码块，再执行子类的构造方法；  </li></ol><p>（1）初始化父类的普通成员变量和代码块，执行  Y y=new Y();  输出Y<br>（2）再执行父类的构造方法；输出X<br>（3）初始化子类的普通成员变量和代码块，执行  Y y=new   Y();  输出Y<br>（4）再执行子类的构造方法；输出Z<br> 所以输出YXYZ。</p></blockquote></li><li><p>客户端要获取一个socket对象通过实例化，而服务器获得一个socket对象则通过什么方法的返回值?</p><p>答：getRemoteSocketAddress()。</p></li><li><pre><code class="java">  public class Example&#123;   String str=new String(&quot;good&quot;);   char[]ch=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;   public static void main(String args[])&#123;       Example ex=new Example();       ex.change(ex.str,ex.ch);       System.out.print(ex.str+&quot; and &quot;);       System.out.print(ex.ch);   &#125;   public void change(String str,char ch[])&#123;  //引用类型变量，传递的是地址，属于引用传递。       str=&quot;test ok&quot;;       ch[0]=&#39;g&#39;;   &#125;  &#125;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">      1、java语言参数之间只有值传递，包括按值调用和按引用调用。 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 </span><br><span class="line">      按值调用：包括八大基本数据类型都是按值调用。传值的时候，也就是说方法得到的是所有参数值的一个拷贝。 </span><br><span class="line">      按引用调用：数组、对象。传值时候，传递的是引用地址的拷贝，但是都是指向同一个对象。 </span><br><span class="line">      2、String是不可变类（final and Immutable）,这里只是把副本的指向修改成指向“test ok”，原地址str的指向的值没有发生改变。</span><br><span class="line"></span><br><span class="line">            3、运行结果为：good and gbc。</span><br><span class="line"></span><br><span class="line">33. &gt; 运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**虚拟机栈区**：也就是我们常说的栈区，**线程私有**，存放基本类型，对象的引用和returnAddress，在编译期间完成分配。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**堆区**，JAVA堆，也称GC堆，所有**线程共享**，存放对象的实例和数组，JAVA堆是垃圾收集器管理的主要区域。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**方法区**：所有**线程共享**，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。</span><br><span class="line">   &gt;</span><br><span class="line">   &gt;**程序计数器**：**线程私有**，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。</span><br><span class="line"></span><br><span class="line">34. Panel 和 Applet 的默认布局管理器是FlowLayout。</span><br><span class="line"></span><br><span class="line">35. &gt; 关于synchronized和volatile的比较: </span><br><span class="line">   &gt;</span><br><span class="line">   &gt;- 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。  </span><br><span class="line">   &gt;- 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。  </span><br><span class="line">   &gt;- volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。  </span><br><span class="line">   &gt;- 关键字volatile解决的是变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题。</span><br><span class="line"></span><br><span class="line">36. finally语句块</span><br><span class="line"></span><br><span class="line">   - 不管catch是否捕获异常，finally语句块都是要被执行的</span><br><span class="line">   - 在try语句块或catch语句块中执行到System.exit(0)直接退出程序</span><br><span class="line">   - finally块中的return语句会覆盖try块中的return返回</span><br><span class="line">   - finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，但是不建议在finally中return。</span><br><span class="line"></span><br><span class="line">37. &gt; 类的复用有两种方式：组成(has-a)和继承(is-a) </span><br><span class="line">   &gt; 1）组成就是在新的类中直接创建旧类的对象，这里我们复用的只是代码的功能而不是它的形式。 </span><br><span class="line">   &gt; 2）继承是在原有的类的基础上建立一个新类，新类具有旧类的形式，但也加入了一些新的特性。 </span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 继承：指一个新的类继承原有类的基本特性，并增加了新的特性。（Java不允许多继承，而C++可以） </span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 多态性： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 </span><br><span class="line">   &gt; 1）多态存在的三个必要条件 </span><br><span class="line">   &gt; ①要有继承 ②要有重写 ③父类引用指向子类对象（向上转型） </span><br><span class="line">   &gt; 2）实现多态性的三种形式 </span><br><span class="line">   &gt; ①方法的重载 ②通过继承机制而产生方法覆盖 ③通过接口实现方法覆盖 </span><br><span class="line">   &gt; 3）多态的分类 </span><br><span class="line">   &gt; 多态分为编译时多态和运行时多态。其中编译 时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们平常所说的多态性。 </span><br><span class="line"></span><br><span class="line">38. - Java中，赋值是有返回值的 ，赋什么值，就返回什么值。比如这题，x&#x3D;y，返回y的值，所以括号里的值是1。 </span><br><span class="line">   - Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号。 </span><br><span class="line"></span><br><span class="line">39. &#96;&#96;&#96;java</span><br><span class="line">      public class Test</span><br><span class="line">      &#123;</span><br><span class="line">        public static void changeStr(String str)</span><br><span class="line">        &#123;</span><br><span class="line">            str &#x3D; &quot;welcome&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        public static void main(String[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            String str &#x3D; &quot;1234&quot;;</span><br><span class="line">            changeStr(str);</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>  Java方法调用中，只存在值传递调用。   此处，实参str是引用变量，由于java方法调用是值传递，所以形参str得到的是实参str的一个拷贝。此时形参str和实参str均指向字符串&quot;1234&quot;。   然后，在changeStr方法中，形参str指向了一个新的字符串&quot;welcom&quot;，而后方法结束，形参str被销毁。而实参str仍然指向字符串&quot;1234&quot;。 </code></pre></li><li><p>jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。<br>  常量池属于 PermGen（方法区） </p></li><li><blockquote><ul><li>所有类的实例和数组都是在堆上分配内存的</li><li>对象所占的堆内存是由自动内存管理系统回收</li><li>堆内存由存活和死亡的对象,空闲碎片区组成</li></ul></blockquote></li><li><blockquote><ul><li>CopyOnWriteArrayList适用于写少读多的并发场景</li><li>ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率</li><li>ConcurrentHashMap是同步的HashMap，读写都加锁</li><li>volatile只保证多线程操作的可见性，不保证原子性 </li></ul></blockquote></li><li><blockquote><ul><li>ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized;</li><li>HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Collection;</li><li>Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList；</li><li>SimpleDateFormat是线程不安全的</li></ul></blockquote></li><li><p>private修饰的东西，只是不能在别的类中访问，但是本类中还是可以的。同时利用反射也可以做到。</p></li><li><p>JUnit主要用来完成<strong>单元测试</strong>。</p></li><li><blockquote><ul><li>Log4j支持按分钟为间隔生成新的日志文件</li><li>Log4j是一个打印日志用的组件</li><li>Log4j支持按年为间隔生成新的日志文件</li><li>Log4j的日志打印级别不可以在运行时重新设置</li></ul><p>日志的级别之间的大小关系：ALL&lt; TRACE&lt; DEBUG&lt; INFO&lt; WARN&lt; ERROR&lt; FATAL&lt; OFF。</p><p>Log4j建议只使用四个级别，优先级从高到低分别是 ERROR &gt; WARN &gt; INFO &gt; DEBUG。</p></blockquote></li><li><p>在类方法中不能有this关键字，this指的是当前对象，类方法依附于类而不是对象，使用this会编译出错。</p></li><li><p>下面哪种情况会导致持久区jvm堆内存溢出？</p><p>答：使用CGLib技术直接操作字节码运行，生成大量的动态类</p></li><li><p>在Struts框架中如果要使用Validation作验证的话，需要使用以下哪个Form？</p><p>答：DynaValidatorActionForm 动态验证表单</p></li><li><ul><li>内部类前面可以修饰public,protected和private</li></ul></li></ol><ul><li>外部类只能用 public、abstract、final修饰</li></ul><ol start="51"><li>单例模式中，两个基本要点是</li></ol><ul><li>构造函数私有</li><li>唯一实例</li></ul><ol start="52"><li>常用的servlet包的名称：</li></ol><ul><li>javax.servlet</li><li>javax.servlet.http</li></ul><ol start="53"><li>数组：</li></ol><ul><li>数组是一个对象，不同类型的数组具有不同的类</li><li>数组是一个连续的存储结构</li></ul><h2 id="二星题"><a href="#二星题" class="headerlink" title="二星题"></a>二星题</h2><ol><li><blockquote><ul><li>java.io.Serializable接口是一个标志性接口，在接口内部没有定义任何属性与方法。只是用于标志此接口的实现类可以被序列化与反序列化。</li><li>java.lang.Cloneable接口是一个标志性接口，在接口内部没有定义任何属性与方法。以指示Object.clone()方法可以合法地对该类实例进行按字段复制。</li><li>java.lang.CharSequence接口对许多不同种类的char序列提供统一的只读访问接口。CharSequence是char值的一个可读序列。</li><li>java.lang.Comparable接口，此接口强制对实现它的每个类的对象进行整体排序，此序列被称为该类的自然排序。</li></ul></blockquote></li><li><p>需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。</p></li><li><p>基本数据类型都是以小写字母开头，引用数据类型则是以大写字母开头。</p></li><li><p>Java的Daemon线程，setDaemon(  )设置必须要在start之前。</p></li><li><p>释放掉占据的内存空间是由gc完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。</p></li><li><p>静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。</p></li><li><p>spring</p><blockquote><ul><li>spring是一个轻量级JAVA EE的框架集合</li><li>spring是“依赖注入”模式的实现</li><li>使用spring可以实现声明事务</li></ul></blockquote></li><li><p>转发重定向，转发的时候pageContent内的属性值不能被传递。</p></li><li><blockquote><ol><li>HashMap,TreeMap 未进行同步考虑，是线程不安全的。 </li><li>HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。 </li><li>Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如，<br>List  list = Collections.synchronizedList(new ArrayList());<br>Set  set = Collections.synchronizedSet(new HashSet()); </li></ol></blockquote></li><li><p>以下方法可以取到http请求中的cookie值：</p><ul><li>request.getHeader</li><li>request.getCookies</li></ul></li><li><p>同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间。</p></li><li><ul><li>使用super()或者this()方法是必须放在构造函数的第一行。</li><li>由于this函数指向的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。</li><li>因为staic方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super()。</li></ul></li><li><p>普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。</p></li><li><blockquote><p>1、List接口和Set接口都继承自Collection接口，Collection接口继承Iterable接口（Iterable有一个Iterator方法），即可迭代的；Collection只能存储引用类型，并且是单个存储；<br>2、List接口存储元素特点：有序（存进去什么顺序取出来还什么顺序），可重复；Set接口存储元素特点：无序，不可重复<br>3、实现List接口主要的类包括ArrayList，LinkedList，Vector；实现Set的主要类包括：hashSet，另外还有一个TreeSet接口继承它（自动排序）<br>4、Map接口以键值对方式存储元素，键无序不可重复，Map和Collection没有任何关系 </p></blockquote></li><li><p>一个完整的URL地址由协议，主机名，端口和文件四部分组成。</p></li><li><p>泛型只在编译的时候保证数据类型的正确性，和运行期间的性能无关。</p></li><li><ul><li>用new创建的对象在堆区</li><li>函数中的临时变量在栈去</li><li>java中的字符串在字符串常量区 </li></ul></li><li><ul><li>HashMap不能保证元素的顺序,HashMap能够将键设为null，也可以将值设为null</li><li>Hashtable不能将键和值设为null，否则运行时会报空指针异常错误</li><li>HashMap线程不安全，Hashtable线程安全 </li></ul></li><li><blockquote><p>对于集合的三种遍历方式删除：<br>1.普通for循环：可以删除 </p><pre><code> 注意每次删除之后索引要--</code></pre><p>2.Iterator遍历：可以删除 </p><pre><code> 不过要使用Iterator类中的remove方法，如果用List中的remove方法会报错</code></pre><p>3.增强for循环foreach：不能删除 </p><pre><code> 强制用List中的remove方法会报错</code></pre></blockquote></li><li><p>Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。</p><p>序列化的是对象，不是类，类变量不会被序列化。</p></li><li><p>Math.floor(x) 返回小于等于x的最接近整数，类型为double。</p></li><li><ul><li>final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。 </li><li>finalize方法，一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。 </li></ul></li><li><p>下列操作会使线程释放锁资源：</p><ul><li>wait()</li><li>join()—–&gt;join()底层就是调用wait()方法的，wait()释放锁资源，故join也释放锁资源。</li></ul></li><li><blockquote><ul><li>synchronized：用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。</li><li>volatile：用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。</li><li>serialize：Java 对象序列化为二进制文件。 </li></ul></blockquote></li><li><p>在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。但是，反射最大程度破坏了面向对象的封装特性。</p></li><li><p>面向对象设计方法主要特征的是<strong>继承</strong>。</p></li><li><p>java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。</p></li><li><p>jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。</p></li><li><blockquote><p>单目运算符：+（正号），-（负号），++，–<br>算数运算符：+，-，*，/，%<br>移位运算符：&lt;&lt;,&gt;&gt;<br>关系运算符：&gt;,&lt;,&gt;=,&lt;=,==,!=<br>位运算符：&amp;，|，~，^,<br>逻辑运算符：&amp;&amp;，||<br>三目运算符：表达式1？表达式2：表达式3;<br>赋值运算符：=</p></blockquote></li><li><p>命令javac-d参数的用途是：指定编译后类层次的根目录</p></li><li><p>常用ASCII码值：空格为32；数字0为48；“A”为65；“a”值为97。</p></li><li><p>Java文件与Bean所定义的类名可以不同，但一定要注意区分字母的大小写。</p></li><li><blockquote><ul><li>虚拟机中没有泛型，只有普通类和普通方法</li><li>所有泛型类的类型参数在编译时都会被擦除</li><li>创建泛型对象时请指明类型，让编译器尽早的做参数检查</li></ul></blockquote></li><li><p>ArrayList的构造函数总共有三个：<br>（1）ArrayList()构造一个初始容量为 10 的空列表。这种是默认创建大小为10的数组，每次扩容大小为1.5倍。</p><p>（2）ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。<br>（3）ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。这种是指定数组大小的创建，没有扩充。</p></li><li><p>计算余弦值使用Math类的cos()方法 </p><ul><li>toRadians()是将角度转换为弧度</li><li>toDegrees()是将弧度转换为角度</li></ul></li><li><p>包装类是针对基本数据类型的。</p></li><li><ul><li>Collection是java.util下的接口，它是各种集合结构的父接口</li><li>Collections是java.util下的类，它包含有各种有关集合操作的静态方法</li></ul></li><li><p>线程局部存储TLS(thread local storage)</p><blockquote><ul><li>解决多线程中的对同一变量的访问冲突的一种技术</li><li>TLS会为每一个线程维护一个和该线程绑定的变量的副本</li><li>Java平台的java.lang.ThreadLocal是TLS技术的一种实现</li></ul></blockquote></li><li><ul><li>一个线程调用yield方法，可以使具有相同优先级线程获得处理器</li><li>在Java中，高优先级的可运行的线程会抢占低优先级线程的资源</li><li>sleep与yield的其中一个区别：sleep给其他Thread运行不考虑优先级，而yield只给同等优先级或更高优先级运行。</li></ul></li></ol><h2 id="三星题"><a href="#三星题" class="headerlink" title="三星题"></a>三星题</h2><ol><li><p>ArrayList是基于数组实现的，所以查询快，增删慢；LinkedList是基于链表实现的，所以查找慢，增删快。</p></li><li><blockquote><p>AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。<br>AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象<br>，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。<br>核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉，<br>AOP只是OOP的补充，无替代关系。</p></blockquote></li><li><p>同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。<br>因为一步到位的操作，其他线程不可能在中间干涉。另外三项都有读取、操作两个步骤，而X=1则是原子性操作。 </p></li><li><pre><code class="java">public class Test &#123;       public static void main(String[] args) &#123;       System.out.println(args[0]);       &#125;  &#125;  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   若采用命令行“java Test one two three”调用，则程序输出的结果为： one</span><br><span class="line"></span><br><span class="line">   解析：采用命令行“ java Test one two three ”调用，其中Test为调用的方法，而one two three则为Test方法里面main函数的参数。System.out.println(args[0]);表示输出第一个元素，故为one。</span><br><span class="line"></span><br><span class="line">5. 管道( pipe )：管道是一种**半双工**的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 </span><br><span class="line"></span><br><span class="line">6. CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。 </span><br><span class="line"></span><br><span class="line">7. volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性。</span><br><span class="line"></span><br><span class="line">8. 进入DEAD的线程，它还可以恢复，GC不会回收。</span><br><span class="line"></span><br><span class="line">9. DBMS 中实现事务持久性的子系统是**恢复管理子系统**。</span><br><span class="line"></span><br><span class="line">10. Java.Thread的方法resume()负责重新开始被suspend方法中断的线程的执行。</span><br><span class="line"></span><br><span class="line">11. - HashMap实现了Map接口的，它的Key和Value都可以是null，但是Hashtable种，Key和Value都不能是null。</span><br><span class="line">    - ArrayList与LinkedList都实现了List接口，继承了AbstractList类。</span><br><span class="line"></span><br><span class="line">12. 在**函数代码小，频繁调用**情况下适宜采用内联函数。</span><br><span class="line"></span><br><span class="line">13. &gt; - Java 中单实现通过 implements 关键字，多实现通过 extends 关键字</span><br><span class="line">    &gt; - Java 中单继承通过 extends 关键字，没有多继承</span><br><span class="line">    &gt; - 如果同时出现继承和实现，则必须先继承（extends）再实现（implements）</span><br><span class="line"></span><br><span class="line">14. try的形式有三种： </span><br><span class="line"></span><br><span class="line">    - try-catch</span><br><span class="line">    - try-finally</span><br><span class="line">    - try-catch-finally</span><br><span class="line"></span><br><span class="line">    但catch和finally语句不能同时省略！ </span><br><span class="line"></span><br><span class="line">15. &gt; 一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 </span><br><span class="line">    &gt; 但某些情况下，这个类的有些属性需要序列化，而其他属性不需要被序列化，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</span><br><span class="line"></span><br><span class="line">16. 饿汉式单例模式，在类创建时，就已经实例化完成，在调用getInstance()时，直接获取静态对象。obj1和obj2其实是一个对象,应该返回true。</span><br><span class="line"></span><br><span class="line">17. - java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象</span><br><span class="line">    - StringBuffer是线程安全的StringBuilder</span><br><span class="line">    - StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全</span><br><span class="line">    - StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容 </span><br><span class="line"></span><br><span class="line">18. J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的**service**方法。</span><br><span class="line"></span><br><span class="line">19. HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据；</span><br><span class="line"></span><br><span class="line">    读取路径信息是HttpServletRequest做的。</span><br><span class="line"></span><br><span class="line">20. - forward，服务器获取跳转页面内容传给用户，用户地址栏不变</span><br><span class="line">    - redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址</span><br><span class="line"></span><br><span class="line">21. ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。</span><br><span class="line"></span><br><span class="line">22. 父类没有**无参**的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数。</span><br><span class="line"></span><br><span class="line">23. - ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</span><br><span class="line">    - 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</span><br><span class="line">    - 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。</span><br><span class="line">    - ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。</span><br><span class="line"></span><br><span class="line">24. - java不允许单独的方法，过程或函数存在,需要隶属于某一类中。</span><br><span class="line">    - Java的静态方法属于类的成员，实例方法属于对象的成员。</span><br><span class="line"></span><br><span class="line">25. - 静态方法不能访问非静态变量</span><br><span class="line">    - 抽象类中的抽象方法不能有方法体</span><br><span class="line">    - 一个类中有多个类声明时，只能有一个public类</span><br><span class="line"></span><br><span class="line">26. 一般用(System.in)创建InputStream对象,表示从标准输入中获取数据,用(System.out)创建OutputStream对象，表示输出到标准输出设备中。</span><br><span class="line"></span><br><span class="line">27. &gt; length 返回当前长度 </span><br><span class="line">    &gt; 如果字符串长度没有初始化长度大，capacity返回初始化的长度 </span><br><span class="line">    &gt; 如果append后的字符串长度超过初始化长度，capacity返回增长后的长度 </span><br><span class="line">    &gt; PS: </span><br><span class="line">    &gt; StringBuffer和StringBuilder的默认大小为16 </span><br><span class="line">    &gt; ArrayList和LinkedList的默认大小10 </span><br><span class="line"></span><br><span class="line">28. 关于 Socket 通信编程，</span><br><span class="line"></span><br><span class="line">    - 服务器端通过new ServerSocket()创建TCP连接对象</span><br><span class="line">    - 服务器端通过TCP连接对象调用accept()方法创建通信的Socket对象</span><br><span class="line">    - 客户端通过new Socket()方法创建通信的Socket对象</span><br><span class="line"></span><br><span class="line">29. JSP分页代码中，先取总记录数，得到总页数，最后显示本页的数据。</span><br><span class="line"></span><br><span class="line">30. java在运行时才进行翻译指令。</span><br><span class="line"></span><br><span class="line">31. 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输。</span><br><span class="line"></span><br><span class="line">## 四星题</span><br><span class="line"></span><br><span class="line">1. 对于&quot;&#x3D;&#x3D;&quot;：</span><br><span class="line"></span><br><span class="line">   - 用于基本数据类型相互比较，比较二者的值是否相等。</span><br><span class="line">   - 用于引用数据类型相互比较，比较二者地址是否相等。</span><br><span class="line">   - 不能用于基本数据类型与引用型比较。</span><br><span class="line"></span><br><span class="line">   对于&quot;equals&quot;：</span><br><span class="line"></span><br><span class="line">   - 不能用于基本数据类型比较(因为这是一个方法, 继承自object)。</span><br><span class="line">   - 用于进行对象的比较, 比较二者的引用地址是否相同。</span><br><span class="line"></span><br><span class="line">2. 适配器模式 ，屏蔽远程对象，通过适配器模拟本地对象，本地对象称之为存根。与动态链接技术有关。</span><br><span class="line"></span><br><span class="line">3. ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突。</span><br><span class="line"></span><br><span class="line">4. 没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。 </span><br><span class="line"></span><br><span class="line">5. 关于OutOfMemoryError，</span><br><span class="line"></span><br><span class="line">   &gt; - java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。</span><br><span class="line">   &gt; - java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现。</span><br><span class="line">   &gt; - java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小。</span><br><span class="line"></span><br><span class="line">6. JDK提供的用于并发编程的同步器：</span><br><span class="line"></span><br><span class="line">   - Semaphore</span><br><span class="line">   - CyclicBarrier</span><br><span class="line">   - CountDownLatch</span><br><span class="line"></span><br><span class="line">7. &gt; Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。 </span><br><span class="line">   &gt;</span><br><span class="line">   &gt; - throw用于抛出异常。</span><br><span class="line">   &gt; - throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。</span><br><span class="line">   &gt; - try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。</span><br><span class="line">   &gt; - cacth用于捕获从try中抛出的异常并作出处理。</span><br><span class="line">   &gt; - finally语句块是不管有没有出现异常都要执行的内容。 </span><br><span class="line"></span><br><span class="line">8. - run()方法用来执行线程体中具体的内容</span><br><span class="line">   - start()方法用来启动线程对象，使其进入就绪状态</span><br><span class="line">   - sleep()方法用来使线程进入睡眠状态</span><br><span class="line">   - suspend()方法用来使线程挂起，要通过resume()方法使其重新启动 </span><br><span class="line"></span><br><span class="line">9. - Semaphore：类，控制某个资源可被同时访问的个数; </span><br><span class="line">   - ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大；</span><br><span class="line">   - Future：接口，表示异步计算的结果；</span><br><span class="line">   - CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。</span><br><span class="line"></span><br><span class="line">10. Hibernate 中 get()和load() 的区别： </span><br><span class="line"></span><br><span class="line">    - get()采用立即加载方式,而load()采用延迟加载; get()方法执行的时候,会立即向数据库发出查询语句, 而load()方法返回的是一个代理(此代理中只有一个id属性),只有等真正使用该对象属性的时候,才会发出 sql语句</span><br><span class="line">    - 如果数据库中没有对应的记录,get()方法返回的是null。而load()方法出现异常ObjectNotFoundException </span><br><span class="line"></span><br><span class="line">11. hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</span><br><span class="line">    那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</span><br><span class="line">    那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠， </span><br><span class="line">    所以我们可以得出： </span><br><span class="line"></span><br><span class="line">    - equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</span><br><span class="line">    - hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的</span><br><span class="line"></span><br><span class="line">12. SimpleDateFormat是线程不安全的。</span><br><span class="line"></span><br><span class="line">13. 在java中，我们可以用异常（Exception）来抛出一些并非错误的消息，但这样比直接从函数返回一个结果要更大的系统开销。</span><br><span class="line"></span><br><span class="line">14. java用（监视器）机制实现了进程之间的同步执行。</span><br><span class="line"></span><br><span class="line">15. jre 判断程序是否执行结束的标准是**所有的前台线程执行完毕**。</span><br><span class="line"></span><br><span class="line">16. 我们在执行&#96;URL u &#x3D;new URL(&quot;http:&#x2F;&#x2F;www.123.com&quot;);&#96;这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个链接，打印出来就是该网址。</span><br><span class="line"></span><br><span class="line">17. 关于JSP生命周期的叙述，</span><br><span class="line"></span><br><span class="line">    - JSP会先解释成Servlet源文件，然后编译成Servlet类文件</span><br><span class="line">    - 每当用户端运行JSP时，jsp service()方法都会运行一次</span><br><span class="line"></span><br><span class="line">18. 有关java的引用类型，</span><br><span class="line"></span><br><span class="line">    - 对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中</span><br><span class="line">    - 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收</span><br><span class="line">    - 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存</span><br><span class="line">    - 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间</span><br><span class="line"></span><br><span class="line">## 五星题</span><br><span class="line"></span><br><span class="line">1. 一般关系数据模型和对象数据模型之间有以下对应关系：表对应类，记录对应对象，表的字段对应类的属性。</span><br><span class="line"></span><br><span class="line">2. 实现GBK编码字节流到UTF-8编码字节流的转换：</span><br><span class="line"></span><br><span class="line">   dst&#x3D;new String(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;);</span><br><span class="line"></span><br><span class="line">3. 对于线程而言，start是让线程从new变成runnable。run方法才是执行体的入口。 </span><br><span class="line">   但是在Thread中，run方法是个空方法，没有具体实现。 </span><br><span class="line">   Bground(新类)继承了Thread，但是没有重写run方法，那么调用run方法肯定是无输出。</span><br><span class="line"></span><br><span class="line">4. Java数据库连接库JDBC用到**桥接模式** 。</span><br><span class="line"></span><br><span class="line">5. &gt; SpringMVC的原理： </span><br><span class="line">   &gt;  SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。 </span><br><span class="line">   &gt; DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。 </span><br><span class="line">   &gt; 实现业务操作时在service层。</span><br><span class="line"></span><br><span class="line">6. 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块 。</span><br><span class="line"></span><br><span class="line">7. 鲁棒性(Robust,即健壮性)</span><br><span class="line">   Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。 </span><br><span class="line"></span><br><span class="line">8. &#96;&#96;&#96;java</span><br><span class="line">   public class Base</span><br><span class="line">   &#123;</span><br><span class="line">       private String baseName &#x3D; &quot;base&quot;;</span><br><span class="line">       public Base()</span><br><span class="line">       &#123;</span><br><span class="line">           callName();</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       public void callName()</span><br><span class="line">       &#123;</span><br><span class="line">           System. out. println(baseName);</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">       static class Sub extends Base</span><br><span class="line">       &#123;</span><br><span class="line">           private String baseName &#x3D; &quot;sub&quot;;</span><br><span class="line">           public void callName()</span><br><span class="line">           &#123;</span><br><span class="line">               System. out. println (baseName) ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       public static void main(String[] args)</span><br><span class="line">       &#123;</span><br><span class="line">           Base b &#x3D; new Sub();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。 创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null。最终结果为：null</code></pre></li><li><p>JVM内存区：程序计数器、虚拟机栈、本地方法栈、堆、方法区（包括常量池）。</p></li><li><ul><li>我们可以直接调用Thread对象中的run方法，但就起不到多线程的目的了。</li><li>ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的</li></ul></li><li><p>Java中字节流的流对象：</p><ul><li>FileInputStream</li><li>BufferedInputStream</li><li>PushbackInputStream</li><li>ByteArrayInputStream</li></ul></li><li><blockquote><ul><li>LinkedBlockingQueue是一个基于节点链接的可选是否有界的阻塞队列，不允许null值。</li><li>LinkedBlockingQueue是一个线程安全的阻塞队列，实现了先进先出等特性。</li><li>PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）。</li><li>PriorityQueue是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，该队列的元素遵循FIFO原则。</li></ul></blockquote></li><li><p>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 </p></li><li><p>程序运行时异常由Java虚拟机自动进行处理。</p></li><li><p>依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁。</p></li><li><ul><li>依赖注入能够独立开发各组件，然后根据组件间关系进行组装</li><li>依赖注入提供使用接口编程</li><li>依赖注入指对象在使用时动态注入</li></ul></li><li><p>有一个源代码，只包含import java.util.* ; 这一个import语句，能访问java/util目录下的所有类，不能访问java/util子目录下的所有类。</p></li><li><p>在有除法存在的代码处，抛不抛出异常均可。</p></li><li><ul><li>一般而言，PreparedStatement比Statement执行效率更高</li><li>PreparedStatement会预编译SQL语句</li><li>Statement每次都会解析/编译SQL，确立并优化数据获取路径</li></ul></li><li><p>weblogic中开发消息Bean时的persistent与non-persisten的差别： </p><ul><li>persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来。</li><li>non－persistent方式的消息将被丢弃。 </li></ul></li><li><p>Iterator支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。</p></li><li><p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。</p></li><li><ul><li>使用匿名内部类时，必须继承一个类或实现一个接口</li><li>匿名内部类由于没有名字，因此不能定义构造函数</li><li>匿名内部类中不能含有静态成员变量和静态方法</li></ul></li><li><p>Object类的部分方法：</p><ul><li>notify()</li><li>notifyAll()</li><li>wait()</li></ul></li></ol><h2 id="PS："><a href="#PS：" class="headerlink" title="PS："></a>PS：</h2><blockquote><pre><code>不是恶意诽谤牛客网，实在是题目质量得不到保证。有的题目错，有的答案错，甚至你在刷Java题目时动不动就来个C语言的题目，很是让人无语。牛客网的题目似乎是用户传上去的，只丢个答案在那里，没有官方解答，题目下方评论区的确有大神做解答，但鱼龙混杂，也有辣鸡在装X的（随意粘贴别处的知识点，最可恶的是解答是错的，这种人是真的恶心）。一星题与五星题的区别并不是你想的那样，仅仅是多选题数量的增多而已，估计这也是安卓端无法进行题目筛选的原因，因为根本没用。还有，强烈建议牛客网将Java题库中的Swing、AWT有关的题目去除，现在还有鬼在用这个东西啊？至于题目涉及的范围倒还好，都是基础知识，建议多加一些框架相关的题目，毕竟现在的开发都是会用到框架的。    刷了3天的题库，400多道题，刷完立刻看解析，边刷题边写笔记。然而并没有什么卵用，考试题全是Spring，一脸懵逼，蓝瘦、香菇。</code></pre></blockquote>]]></content>
    
    
    <summary type="html">【2019】牛客网Java笔记</summary>
    
    
    
    <category term="刷题" scheme="https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>【DB2】DB2基础_表空间和缓冲池</title>
    <link href="https://born2do.github.io/2021/05/13/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <id>https://born2do.github.io/2021/05/13/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%93%E5%86%B2%E6%B1%A0/</id>
    <published>2021-05-13T12:43:06.000Z</published>
    <updated>2021-05-13T12:43:56.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>对于刚涉足 DB2 领域的 DBA 或未来的 DBA 而言，新数据库的设计和性能选择可能会很令人困惑。在本文中，我们将讨论 DBA 要做出重要选择的两个方面：表空间和缓冲池。表空间和缓冲池的设计和调优会对 DB2 服务器的性能产生深远的影响，因此我们将着重讨论这些活动。</p><p>在我们的示例中，我们将使用 DB2 V8.1 企业服务器版。大多数示例也适用于低级版本。我们会让您知道某个示例是否只适用于 V8.1。</p><p>在 第 1 节中，我们将从定义表空间的类型开始，并将说明 DB2 如何将数据存储在表空间中。我们将介绍配置选项并向您介绍创建和管理表空间的整个过程。接下来，我们将着重讨论 缓冲池，介绍缓冲池是什么以及如何创建和使用它。在 第 2 节中，我们将结合这两个方面并讨论该如何组织缓冲池和表空间才能获得最佳性能。</p><h2 id="第-1-节：定义"><a href="#第-1-节：定义" class="headerlink" title="第 1 节：定义"></a>第 1 节：定义</h2><h3 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h3><p>数据库中的所有数据都存储在许多表空间中。可以认为表空间是孩子而数据库是其父母，其中表空间（孩子）不能有多个数据库（父母）。由于表空间有不同用途，因此根据它们的用途和管理方式将它们分类。根据用途有五种不同的表空间：</p><ul><li><p><strong>目录表空间</strong></p><p>每个数据库只有一个目录表空间，它是在发出 CREATE DATABASE 命令时创建的。目录表空间被 DB2 命名为 SYSCATSPACE，它保存了系统目录表。总是在创建数据库时创建该表空间。</p></li><li><p><strong>常规表空间</strong></p><p>常规表空间保存表数据和索引。它还可以保存诸如大对象（Large Object，LOB）之类的长数据，除非这些数据显式地存储在长表空间中。如果某些表空间是数据库管理的空间（Database Managed Space，DMS），则可以将表及其索引分别放到单独的常规表空间中。我们将在本文后面定义 DMS 和系统管理的空间（System Managed Space，SMS）之间的区别。每个数据库中必须至少有一个常规表空间。创建数据库时指定该表空间的缺省名为 USERSPACE1。</p></li><li><p><strong>长表空间</strong></p><p>长表空间用于存储长型或 LOB 表列，它们必须驻留在 DMS 表空间中。它们还可以存储结构化类型的列或索引数据。如果没有定义长表空间，那么将把 LOB 存储在常规表空间中。长表空间是可选的，缺省情况下一个都不创建。</p></li><li><p><strong>系统临时表空间</strong></p><p>系统临时表空间用于存储 SQL 操作（比如排序、重组表、创建索引和连接表）期间所需的内部临时数据。每个数据库必须至少有一个系统临时表空间。随数据库创建的系统临时表空间的缺省名为 TEMPSPACE1。</p></li><li><p><strong>用户临时表空间</strong></p><p>用户临时表空间存储已声明的全局临时表。创建数据库时不存在用户临时表空间。至少应当创建一个用户临时表空间以允许定义已声明的临时表。用户临时表空间是可选的，缺省情况下一个都不创建。</p></li></ul><h3 id="表空间管理"><a href="#表空间管理" class="headerlink" title="表空间管理"></a>表空间管理</h3><p>可以用两种不同的方式管理表空间：</p><ul><li><p><strong>系统管理的空间（SMS）</strong></p><p>SMS 表空间由操作系统进行管理。容器被定义成常规操作系统文件，并且是通过操作系统调用访问的。这意味着所有的常规操作系统功能将处理以下内容：操作系统将缓冲 I/O；根据操作系统约定分配空间；如有必要就自动扩展表空间。但是，不能从 SMS 表空间删除容器，并且仅限于将新的容器添加到分区的数据库。前一节中所说明的那三个缺省表空间都是 SMS。</p></li><li><p><strong>数据库管理的空间（DMS）</strong></p><p>DMS 表空间是由 DB2 管理的。可以将容器定义成文件（在创建表空间时将把给定的大小全部分配给它们）或设备。分配方法和操作系统允许多少 I/O，DB2 就可以管理多少 I/O。可以通过使用 altER TABLESPACE 命令来扩展容器。还可以释放未使用的那部分 DMS 容器（从 V8 开始）。</p></li></ul><p>下面是一个示例，向您说明该如何增大容器大小（V7 和 V8 都支持此功能）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE TS1 RESIZE (FILE <span class="string">&#x27;/conts/cont0&#x27;</span> <span class="number">2000</span>, DEVICE <span class="string">&#x27;/dev/rcont1&#x27;</span> <span class="number">2000</span>, FILE <span class="string">&#x27;cont2&#x27;</span> <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>请注意，只有 V8 才支持将原始容器的大小调整得更小。</p><h3 id="如何创建和查看表空间"><a href="#如何创建和查看表空间" class="headerlink" title="如何创建和查看表空间"></a>如何创建和查看表空间</h3><p>当您创建数据库时，将创建三个表空间（SYSCATSPACE、TEMPSPACE1 和 USERSPACE1）。通过使用 DB2 命令窗口（Command Window）或 UNIX 命令行，创建一个名为 testdb 的数据库，连接至该数据库，然后列出表空间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE testdb <span class="keyword">CONNECT</span> <span class="keyword">TO</span> testdb LIST TABLESPACES</span><br></pre></td></tr></table></figure><p>下面的 清单 1显示了 LIST TABLESPACES 命令的输出。</p><p><em>清单 1. LIST TABLESPACES 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespaces for Current Database Tablespace ID &#x3D; 0 Name &#x3D; SYSCATSPACE Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 1 Name &#x3D; TEMPSPACE1 Type &#x3D; System managed space Contents &#x3D; System Temporary data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal</span><br></pre></td></tr></table></figure><p>上面所示的这三个表空间是通过 CREATE DATABASE 命令自动创建的。用户可以通过在该命令中包含表空间说明来覆盖缺省的表空间创建，但是在创建数据库时必须创建一个目录表空间和至少一个常规表空间，以及至少一个系统临时表空间。通过使用 CREATE DATABASE 命令或以后使用 CREATE TABLESPACE 命令，可以创建更多的所有类型的表空间（目录表空间除外）。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>每个表空间都有一个或多个容器。重申一次，您可以认为容器是孩子，而表空间是其父母。每个容器只能属于一个表空间，但是一个表空间可以拥有许多容器。可以将容器添加到 DMS 表空间，或者从 DMS 表空间中删除容器，而且可以更改容器的大小。只能将容器添加到某个分区中分区数据库上的 SMS 表空间，在添加之前该分区还未给表空间分配容器。添加新的容器时，将启动一个自动的重新均衡操作以便将数据分布到所有容器上。重新均衡操作不会妨碍对数据库的并发访问。</p><h3 id="表空间设置"><a href="#表空间设置" class="headerlink" title="表空间设置"></a>表空间设置</h3><p>可以在创建表空间时给它们指定许多设置，或者也可以稍后使用 altER TABLESPACE 语句时指定其设置。</p><ul><li><p><strong>页大小（Page size）</strong></p><p>定义表空间所使用的页大小。所支持的大小为 4K、8K、16K 和 32K。页大小根据下表限定了可放到表空间中的表的行长度和列数：</p><p><em>表 1. 页大小的含义</em></p><table><thead><tr><th>页大小</th><th>行大小</th><th>限制列数</th><th>限制最大容量</th></tr></thead><tbody><tr><td>4 KB</td><td>4 005</td><td>500</td><td>64 GB</td></tr><tr><td>8 KB</td><td>8 101</td><td>1 012</td><td>128 GB</td></tr><tr><td>16 KB</td><td>16 293</td><td>1 012</td><td>256 GB</td></tr><tr><td>32 KB</td><td>32 677</td><td>1 012</td><td>512 GB</td></tr></tbody></table><p>表空间最多可包含 16384 个页，因此选择较大的页大小可以增加表空间的容量。</p></li><li><p><strong>扩展块大小（Extent size）</strong></p><p>指定在跳到下一个容器之前将写到当前容器中的页数。存储数据时数据库管理器反复循环使用所有容器。该参数只有在表空间中有多个容器时才起作用。</p></li><li><p><strong>预取大小（Prefetch size）</strong></p><p>指定当执行数据预取时将从表空间读取的页数。预取操作在查询引用所需的数据之前读入这些数据，这样一来查询就不必等待执行 I/O 了。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，它就选择预取操作。</p></li><li><p><strong>开销（Overhead）和传送速率（Transfer rate）</strong></p><p>这些值用于确定查询优化期间的 I/O 成本。这两个值的测量单位都是毫秒，而且它们应当分别是所有容器开销和传送速率的平均值。开销是与 I/O 控制器活动、磁盘寻道时间和旋转延迟时间相关联的时间。传送速率是将一个页读入内存所必需的时间量。它们的缺省值分别是 24.1 和 0.9。可以根据硬件规格计算这些值。</p></li></ul><h3 id="CREATE-TABLESPACE-语句的示例"><a href="#CREATE-TABLESPACE-语句的示例" class="headerlink" title="CREATE TABLESPACE 语句的示例"></a>CREATE TABLESPACE 语句的示例</h3><p>下列语句将创建一个常规表空间。所讨论的所有设置都是为了进行说明。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>SPACE USERSPACE3 PAGESIZE <span class="number">8</span>K MANAGED <span class="keyword">BY</span> <span class="keyword">SYSTEM</span> <span class="keyword">USING</span> (<span class="string">&#x27;d:\\usp3_cont1&#x27;</span>, <span class="string">&#x27;e:\\usp3_cont2&#x27;</span>, <span class="string">&#x27;f:\\usp3_cont3&#x27;</span>) EXTENTSIZE <span class="number">64</span> PREFETCHSIZE <span class="number">32</span> BUFFERPOOL BP3 OVERHEAD <span class="number">24.1</span> TRANSFERRATE <span class="number">0.9</span></span><br></pre></td></tr></table></figure><h3 id="如何查看表空间的属性和容器"><a href="#如何查看表空间的属性和容器" class="headerlink" title="如何查看表空间的属性和容器"></a>如何查看表空间的属性和容器</h3><p>指定 LIST TABLESPACES 命令的 SHOW DETAIL 选项将显示其它信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST TABLESPACES SHOW DETAIL</span><br></pre></td></tr></table></figure><p>清单 2显示了 USERSPACE1 表空间的输出。缺省情况下，将列出创建数据库时所创建的那三个表空间。</p><p><em>清单 2. LlST TABLESPACES SHOW DETAIL 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespaces for Current Database Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Total pages &#x3D; 336 Useable pages &#x3D; 336 Used pages &#x3D; 336 Free pages &#x3D; Not applicable High water mark (pages) &#x3D; Not applicable Page size (bytes) &#x3D; 4096 Extent size (pages) &#x3D; 32 Prefetch size (pages) &#x3D; 16 Number of containers &#x3D; 1</span><br></pre></td></tr></table></figure><p>要列出容器，我们需要使用以上输出中的 Tablespace ID：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIST TABLESPACE CONTAINERS FOR 2</span><br></pre></td></tr></table></figure><p><em>清单 3. LIST TABLESPACE CONTAINERS 命令的输出</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tablespace Containers for Tablespace 2 Container ID &#x3D; 0 Name &#x3D; C:\\DB2\\NODE0000\\SQL00004\\SQLT0002.0 Type &#x3D; Path</span><br></pre></td></tr></table></figure><p>该命令将列出指定表空间中的所有容器。如上所示的路径指向容器物理上所在的位置。</p><h3 id="缓冲池"><a href="#缓冲池" class="headerlink" title="缓冲池"></a>缓冲池</h3><p>一个缓冲池是与单个数据库相关联的，可以被多个表空间使用。当考虑将缓冲池用于一个或多个表空间时，必须保证表空间页大小和缓冲池页大小对于缓冲池所“服务”的所有表空间而言都是一样的。一个表空间只能使用一个缓冲池。</p><p>创建数据库时，会创建一个名为 IBMDEFAULTBP 的缺省缓冲池，所有的表空间都共享该缓冲池。可以使用 CREATE BUFFERPOOL 语句添加更多的缓冲池。缓冲池的缺省大小是 BUFFPAGE 数据库配置参数所指定的大小，但是可以通过在 CREATE BUFFERPOOL 命令中指定 SIZE 关键字来覆盖该缺省值。足够的缓冲池大小是数据库拥有良好性能的关键所在，因为它可以减少磁盘 I/O 这一最耗时的操作。大型缓冲池还会对查询优化产生影响，因为更多的工作可在内存中完成。</p><p><strong>基于块的缓冲池</strong><br>V8 允许您留出缓冲池的一部分（最高可达 98%）用于基于块的预取操作。基于块的 I/O 可以通过将块读入相邻的内存区而不是将它分散装入单独的页，来提高预取操作的效率。每个缓冲池的块大小必须相同，并且由 BLOCKSIZE 参数进行控制。该值等于块的大小（单位为页），从 2 到 256，缺省值为 32。</p><p><strong>扩展存储器</strong><br>DB2 不将扩展存储器用于缓冲区。但是，可以用扩展存储器来高速缓存内存页，使得从内存移出页变得更快。</p><h3 id="CREATE-BUFFERPOOL-语句的示例"><a href="#CREATE-BUFFERPOOL-语句的示例" class="headerlink" title="CREATE BUFFERPOOL 语句的示例"></a>CREATE BUFFERPOOL 语句的示例</h3><p>下面是 CREATE BUFFERPOOL 语句的一个示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> BUFFERPOOL BP3 SIZE <span class="number">2000</span> PAGESIZE <span class="number">8</span>K</span><br></pre></td></tr></table></figure><p>该缓冲池被分配给上面的 CREATE TABLESPACE 示例上的 USERSPACE3，并且在创建表空间之前创建该缓冲池。请注意，缓冲池和表空间的页大小都是 8K，两者是相同的。如果您在创建缓冲池之后创建表空间，则可以省去 CREATE TABLESPACE 语句中的 BUFFER POOL BP3 语法。相反，可以使用 altER TABLESPACE 命令将缓冲池添加到现有的表空间：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span>SPACE USERSPACE3 BUFFERPOOL BP3</span><br></pre></td></tr></table></figure><h3 id="如何查看缓冲池属性"><a href="#如何查看缓冲池属性" class="headerlink" title="如何查看缓冲池属性"></a>如何查看缓冲池属性</h3><p>通过查询 SYSCAT.BUFFERPOOLS 系统视图可以列出缓冲池信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM SYSCAT.BUFFERPOOLS BPNAME BUFFERPOOLID NGNAME NPAGES PAGESIZE ES ------------------ ------------ ------------------ ----------- ----------- -- IBMDEFAULTBP 1 - 250 4096 N 1 record(s) selected.</span><br></pre></td></tr></table></figure><p>要找出哪个缓冲池被分配给了表空间，请运行下面这个查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TBSPACE, BUFFERPOOLID FROM SYSCAT.TABLESPACES TBSPACE BUFFERPOOLID ------------------ ------------ SYSCATSPACE 1 TEMPSPACE1 1 USERSPACE1 1 3 record(s) selected.</span><br></pre></td></tr></table></figure><p>可以在上一个查询中找到 BUFFERPOOLID，该查询使您能够看到每个表空间与哪个缓冲池相关联。</p><h3 id="数据库如何保存表空间的可视化图表"><a href="#数据库如何保存表空间的可视化图表" class="headerlink" title="数据库如何保存表空间的可视化图表"></a>数据库如何保存表空间的可视化图表</h3><p>既然我们已经描述了表空间和缓冲池是什么以及如何创建它们，那么就让我们研究一下有关如何在数据库中将它们直观地组织起来的示例。</p><p>图 1. 表空间和缓冲池</p><p><img src="https://i.loli.net/2021/05/13/IQUgrfiT45c6Wlu.gif" alt="wieser1.gif"></p><p>该数据库有 5 个表空间：一个目录表空间、两个常规表空间、一个长表空间和一个系统临时表空间。没有创建用户临时表空间。另外有 8 个容器。</p><p>在这个方案中，缓冲池可能如下分配：<br>将 BP1（4K）分配给 SYSCATSPACE 和 USERSPACE2<br>将 BP2（8K）分配给 USERSPACE1<br>将 BP3（32K）分配给 LARGESPACE 和 SYSTEMP1</p><h2 id="第-2-节：性能含义"><a href="#第-2-节：性能含义" class="headerlink" title="第 2 节：性能含义"></a>第 2 节：性能含义</h2><p>一般而言，在物理设备上设计如何放置表空间和容器时，目标是使 I/O 并行性和缓冲区利用率达到最优。要实现这个目标，应当全面了解数据库设计和应用程序。只有这样您才能确定类似于下面这样的问题：将两张表分隔到不同的设备会不会产生并行 I/O，或者，是否应当在单独的表空间中创建表以便可以对它进行完全缓冲。</p><p>设计新数据库的物理布局应当从设计表空间的组织开始：</p><ol><li>第一步是确定表设计所给出的约束。这些可能会导致必须使用多个常规表空间。</li><li>第二步是考虑如果让表空间中的表具有不同的设置，是否有可能显著提高性能。</li><li>一旦作出了一个试验性的表空间设计，那么就必须考虑缓冲池的利用率。这可能会使前面的表空间设计产生一些变化。</li><li>最后，必须给表空间分配容器。</li></ol><p>这个是一个有反复的过程，应该通过压力测试和基准测试验证该设计。很显然，实现最佳的设计可能需要花费大量精力，并且仅当数据库性能必须可能是最佳时才能证明设计是最佳的。通常：</p><ul><li>从最简单的可行设计入手。</li><li>只有根据测试证明有充分的性能理由时才增加复杂性。</li></ul><p>通常，为了降低管理和保持一个较为简单的数据库设计的复杂性，稍微降低一点性能是值得的。DB2 具有一种非常成熟的资源管理逻辑，往往不用进行精心的设计就能产生非常好的性能。</p><h3 id="表空间组织"><a href="#表空间组织" class="headerlink" title="表空间组织"></a>表空间组织</h3><p>通常应该将目录表空间和系统临时表空间作为 SMS 分配。没有必要拥有多个具有相同页大小的临时表空间，通常只需一个具有最大页大小的临时表空间就够了。</p><p>突出的问题在于是否要将用户数据分割到多个表空间中。一个考虑因素是页的利用率。不能将行分割到不同的页，因此具有长行的表需要有合适的页大小。但是，一个页上的行不能超过 255 个，因此具有较短行的表不能利用整个页。例如，在页大小为 32K 的表空间中放置行长度为 12 字节的表，它大约只能利用每个页的 10%（即，（255 行 * 12 字节 + 91 字节的开销） / 32k 页大小 = ~10%）。</p><p>如果表很大，这只是一个考虑因素，因此浪费的空间就非常大。它还会使 I/O 和缓存的效率降低，因为每个页的实际有用内容很少。如果可以将表放到具有较小页的表空间中，以及可以充分利用较大的页大小，那么最常用的访问方法将确定哪一个更好。如果通常是顺序访问大量行（该表可能进行了群集），那么比较大的页大小会比较有效。如果随机访问行，那么较小的页大小可以允许 DB2 更好地利用缓冲区，因为同样的存储区域可以容纳更多页。</p><p>一旦根据页大小对表进行了分组，那么访问频率和类型将确定把数据进一步分组到独立的表空间中是否有意义。每张表根据自己被最频繁访问的方式，可以具有一组最有效的表空间设置：PAGESIZE、EXTENTSIZE 和 PREFETCHSIZE。上面已介绍了 PAGESIZE。EXTENTSIZE 是在将数据写入到下一个容器之前写入到当前容器中的数据的页数（如果表空间中存在多个容器的话）。</p><p>PREFETCHSIZE 指定在执行数据预取时将从表空间读取的页数。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，会使用预取操作（通常是大型表扫描）。比较好的做法是将 PREFETCHSIZE 值显式地设置成表空间的 EXTENTSIZE 值与表空间容器数的乘积的倍数。例如，如果 EXTENTSIZE 是 32，并且表空间中有 4 个容器，那么理想的 PREFETCHSIZE 应当是 128、256 等等。如果一个或多个频繁使用的表需要的这组参数的值不同于那些最适用于表空间其它表的性能的参数值，那么将这些表放入单独的表空间可能会提高整体性能。</p><p>如果预取操作是表空间中的重要因素，那么请考虑留出一部分缓冲区用于基于块的 I/O。块大小应当等于 PREFETCHSIZE。</p><h3 id="缓冲池的利用率"><a href="#缓冲池的利用率" class="headerlink" title="缓冲池的利用率"></a>缓冲池的利用率</h3><p>使用多个用户表空间的最重要原因是管理缓冲区的利用率。一个表空间只能与一个缓冲池相关联，而一个缓冲池可用于多个表空间。</p><p>缓冲池调优的目标是帮助 DB2 尽可能好地利用可用于缓冲区的内存。整个缓冲区大小对 DB2 性能有巨大影响，这是因为大量的页可以显著地减少 I/O 这一最耗时的操作。但是，如果总的缓冲区大小太大，并且没有足够的存储器可用来分配给它们，那么将为每种页大小分配最少的缓冲池，性能就会急剧下降。要计算最大的缓冲区大小，DB2、操作系统以及其它任何应用程序都必须考虑其它所有存储器的利用率。一旦确定了总的可用大小，就可以将这个区域划分成不同的缓冲池以提高利用率。如果有一些具有不同页大小的表空间，那么每种页大小必须至少有一个缓冲池。</p><p>拥有多个缓冲池可以将数据保存在缓冲区中。例如，让我们假设一个数据库有许多频繁使用的小型表，这些表通常全部都位于缓冲区中，因此访问起来就非常快。现在让我们假设有一个针对非常大的表运行的查询，它使用同一个缓冲池并且需要读取比总的缓存区大小还多的页。当查询运行时，来自这些频繁使用的小型表的页将会丢失，这使得再次需要这些数据时就必须重新读取它们。</p><p>如果小型表拥有自己的缓冲池，那么它们就必须拥有自己的表空间，因此大型查询就不能覆盖它们的页。这有可能产生更好的整体系统性能，虽然这会对大型查询造成一些小的负面影响。经常性地进行调优是为了实现整体的性能提高而在不同的系统功能之间做出的权衡。区分功能的优先级并记住总吞吐量和使用情况，同时对系统性能进行调整，这是非常重要的。</p><p>V8 所引入的新功能能够在不关闭数据库的情况下更改缓冲池大小。带有 IMMEDIATE 选项的 altER BUFFERPOOL 语句会立刻生效，只要数据库共享的内存中有足够的保留空间可以分配给新空间。可以使用这个功能，根据使用过程中的周期变化（例如从白天的交互式使用转换到夜间的批处理工作）来调优数据库性能。</p><h3 id="物理存储器组织"><a href="#物理存储器组织" class="headerlink" title="物理存储器组织"></a>物理存储器组织</h3><p>一旦将表分布到多个表空间中，就必须决定它们的物理存储器。表空间可以存储在多个容器中，并且它可以是 SMS 或 DMS。SMS 更容易管理，对于包含许多不同的小型表的表空间（例如目录表空间），尤其是那些包含 LOB 的表的表空间而言，SMS 可能是个不错的选择。为了降低每次一页地扩展 SMS 容器的开销，应当运行 <strong>db2empfa</strong>命令。这会将数据库配置参数 MULTIPAGE_ALLOC 的值设置成 YES。</p><p>DMS 通常有更好的性能，并且它提供了分别地存储索引和 LOB 数据的灵活性。通常应当将一个表空间的多个容器分开存放在单独的物理卷上。这可以提高某些 I/O 的并行性。当有多个用户表空间和多个设备时，应当考虑应用程序逻辑，这样就可以尽可能平均地在这些设备上分配工作负载。</p><p>RAID 设备有它们自己的特殊考虑。EXTENTSIZE 应该等于 RAID 条带大小或者是它的倍数。PREFETCHSIZE 应该等于 RAID 条带大小乘以 RAID 并行设备数（或者等于该乘积的倍数），这个值应该是 EXTENTSIZE 的倍数。DB2 提供了自己的注册表变量，允许您增强您的特定环境。通过执行下面这个命令，可以在一个容器中启用 I/O 并行性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db2set DB2_PARALLEL_IO&#x3D;*</span><br></pre></td></tr></table></figure><p>另一个注册表变量 DB2_STRIPED_CONTAINERS=ON 可以将容器标记大小从一个页更改成整个扩展块，因此就能使表空间扩展块和 RAID 条带一致。</p><p>至于性能评估的其它方面，要知道某个更改是否有益，唯一稳妥的方法就是进行基准测试。如果物理组织发生了更改，那么执行该任务稍微有些复杂，这是因为这时要更改表空间必须要付出相当大的精力。最实用的方法就是减少设计阶段中的案例数，这样的话稍后需要进行基准测试的案例就比较少了。只有在性能极其重要并且不同的设计之间有可能存在显著的性能差别时，才值得花时间和精力进行严格的基准测试来比较设计。应当把重点放在缓冲池上，确保没有将它们分配到虚拟内存中，并确保以最有效的方式利用它们。</p><h3 id="有关移动数据库的考虑事项"><a href="#有关移动数据库的考虑事项" class="headerlink" title="有关移动数据库的考虑事项"></a>有关移动数据库的考虑事项</h3><p>在将数据库移到另一个系统之前，始终应该重新评估它的调优参数和物理组织，即便这些系统是同一种平台也应如此。在实际情况中，DBA 将经过良好调优的数据库从具有 1 GB 内存的 Windows 服务器复制到具有 256 MB 内存的膝上型计算机中。在服务器上进行连接所花的时间小于一秒，而在膝上型计算机中却要用掉 45 分钟。通过减少缓冲池大小和其它内存参数就能解决这个问题。</p><p>如果平台不一样，那么这个问题就变得更难了。即使是在 UNIX 和 Windows 之间进行移动，在一个系统上已是最佳性能，在另一个系统上却未必如此。如果复制数据库是为了进行生产，那么应当重复调优过程。如果必须将数据库移到 zSeries™，那么这里讨论的某些内容则不适用，而应该参考有关的手册和红皮书。在 iSeries 系统上，物理设置和调优是在数据库环境之外一起完成的，应当参考 iSeries™ 系统管理手册。</p><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>我们在本文中介绍了许多内容，但是您应当了解的有关数据库设计和性能的知识决不仅限于此。我们着重讨论了数据库设计的两个比较大的问题，而没有深入研究查询优化和应用程序考虑事项的细节。设计数据库是第一位的，因为这是其它所有事情的前提，因此您的初始规划应该非常全面。为了方便您的学习，我们在下面提供了其它联机参考资料，这样您就可以继续学习有关本主题的内容。</p><p>本文转载自IBM官方网站，原文地址：<a href="https://www.ibm.com/developerworks/cn/data/library/techarticles/0212wieser/0212wieser.html">https://www.ibm.com/developerworks/cn/data/library/techarticles/0212wieser/0212wieser.html</a></p>]]></content>
    
    
    <summary type="html">【DB2】DB2基础_表空间和缓冲池</summary>
    
    
    
    <category term="DB2" scheme="https://born2do.github.io/categories/DB2/"/>
    
    
    <category term="表空间" scheme="https://born2do.github.io/tags/%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    
    <category term="缓冲池" scheme="https://born2do.github.io/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【VUE+SpringBoot】前台更改数据后，报错，但是数据库明明更改了</title>
    <link href="https://born2do.github.io/2021/05/11/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%98%8E%E6%9B%B4%E6%94%B9%E4%BA%86/"/>
    <id>https://born2do.github.io/2021/05/11/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%98%8E%E6%9B%B4%E6%94%B9%E4%BA%86/</id>
    <published>2021-05-11T13:30:30.000Z</published>
    <updated>2021-05-11T13:30:56.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前台操作，更改了数据，显示失败。但是数据库中数据的的确确更改掉了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">editUserInfo() &#123;</span><br><span class="line">    this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if(!valid) &#123; return; &#125;</span><br><span class="line">        const &#123;data: res&#125; &#x3D; this.$http.put(&quot;editUser&quot;, this.editForm);</span><br><span class="line">        if(res&#x3D;&#x3D;&quot;success&quot;) &#123;</span><br><span class="line">            this.$message.success(&quot;操作成功&quot;);</span><br><span class="line">            this.editDialogVisible &#x3D; false;</span><br><span class="line">            this.getUserList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message.error(&quot;操作失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>数据库中数据被更改掉了，说明前端的put请求是成功的，后台也正常处理掉了。</li><li>在前端控制台打印日志，查看访问后台后返回的数据是否正常。然而，控制台报错undefined 。<br>仔细查看前端的数据处理，发现缺少await关键字。这也是为什么报错“undefined ”的原因了，根本就没有对后台返回的数据进行接收处理。<h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2>添加上await关键字即可。最终代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">editUserInfo() &#123;</span><br><span class="line">    this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">        if(!valid) &#123; return; &#125;</span><br><span class="line">        const &#123;data: res&#125; &#x3D; await this.$http.put(&quot;editUser&quot;, this.editForm);</span><br><span class="line">        if(res&#x3D;&#x3D;&quot;success&quot;) &#123;</span><br><span class="line">            this.$message.success(&quot;操作成功&quot;);</span><br><span class="line">            this.editDialogVisible &#x3D; false;</span><br><span class="line">            this.getUserList();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.$message.error(&quot;操作失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h2>async + await 组合，用于异步处理后台返回的数据。</li></ul>]]></content>
    
    
    <summary type="html">【VUE+SpringBoot】前台更改数据后，报错，但是数据库明明更改了</summary>
    
    
    
    <category term="VUE+SpringBoot" scheme="https://born2do.github.io/categories/VUE-SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【VUE+SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致</title>
    <link href="https://born2do.github.io/2021/05/10/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/"/>
    <id>https://born2do.github.io/2021/05/10/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/</id>
    <published>2021-05-10T13:04:07.000Z</published>
    <updated>2021-05-10T13:04:36.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>后台从数据库中查询到的数据，转换成JSON字符串传到前端后，缺少部分字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/getUpdateUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUpdateUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    User user = userDao.getUpdateUser(id);</span><br><span class="line">    String string = JSON.toJSONString(user);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">async showEditDialog(id) &#123;</span><br><span class="line">    const &#123;data: res&#125; = await this.$http.get(&quot;/getUpdateUser?id=&quot;+id);</span><br><span class="line">    this.editForm = res;// 查询用户信息，回填用户编辑表单</span><br><span class="line">    this.editDialogVisible = true;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ul><li>打印出后台从数据库中查询出的数据，发现字段是完整的，并无缺失。</li><li>打印JSON字符串，发现缺少字段，定位到问题入口。</li><li>查看JSON.toJSONString()方法后，并未发现异常。</li><li>将该模块的所有文件重新审阅一遍后发现，实体类User.java中有个布尔类型的成员变量的get方法不对头，如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> state; <span class="comment">// 状态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>并不是我们平常的get方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这就导致JSON将User对象转换成json字符串时，无法通过反射获取到其state字段，最终给前端的json数据也就没有该字段。<h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1>重写实体类User的get、set方法并检验，确保不再出错。重启后，测试显示正常。<h1 id="归纳"><a href="#归纳" class="headerlink" title="归纳"></a>归纳</h1><blockquote><p>对于布尔类型的成员变量，在使用IDEA生成get方法后，需要进行修改。否则，将无法通过一般的反射获取其全部成员变量，项目容易出问题。</p></blockquote></li></ul>]]></content>
    
    
    <summary type="html">【VUE+SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致</summary>
    
    
    
    <category term="VUE+SpringBoot" scheme="https://born2do.github.io/categories/VUE-SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【SpringBoot】Project &#39;org.springframework.boot:spring-boot-starter-parent:2.4.5&#39; not found</title>
    <link href="https://born2do.github.io/2021/05/09/%E3%80%90SpringBoot%E3%80%91Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/"/>
    <id>https://born2do.github.io/2021/05/09/%E3%80%90SpringBoot%E3%80%91Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/</id>
    <published>2021-05-09T15:21:43.000Z</published>
    <updated>2021-05-09T15:22:10.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>新建SpringBoot项目后，项目正常运行，但是pom.xml文件提示“Project ‘org.springframework.boot:spring-boot-starter-parent:2.4.5’ not found” 。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>出现这种问题，是由于在当前的仓库中找不到指定的版本Jar包。<br>通常我们在本地会将远程仓库配置成阿里云镜像，如果pom.xml文件中指定的版本过高，可能阿里云镜像仓库中会没有，也就导致了该错误。降低版本即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;&#x2F;parent&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">【SpringBoot】Project &#39;org.springframework.boot:spring-boot-starter-parent:2.4.5&#39; not found</summary>
    
    
    
    <category term="SpringBoot" scheme="https://born2do.github.io/categories/SpringBoot/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
  </entry>
  
  <entry>
    <title>【前后端分离】跨域问题</title>
    <link href="https://born2do.github.io/2021/05/08/%E3%80%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>https://born2do.github.io/2021/05/08/%E3%80%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2021-05-08T13:07:55.000Z</published>
    <updated>2021-05-08T13:08:28.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>VUE前端项目和SpringBoot后端项目起起来后，发现前端无法访问后台地址。报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:9000&#x2F;test&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8080&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource.</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import App from &#39;.&#x2F;App.vue&#39;</span><br><span class="line">import router from &#39;.&#x2F;router&#39;</span><br><span class="line">import &#39;.&#x2F;plugins&#x2F;element.js&#39;</span><br><span class="line">&#x2F;&#x2F; 添加全局样式</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;css&#x2F;global.css&#39;</span><br><span class="line">&#x2F;&#x2F; 引入iconfont</span><br><span class="line">import &#39;.&#x2F;assets&#x2F;font&#x2F;iconfont.css&#39;</span><br><span class="line">&#x2F;&#x2F; 导入axios</span><br><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">&#x2F;&#x2F; 挂载axios</span><br><span class="line">Vue.prototype.$http &#x3D; axios</span><br><span class="line">&#x2F;&#x2F; 设置访问路径(后端地址)</span><br><span class="line">axios.defaults.baseURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip &#x3D; false</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  render: h &#x3D;&gt; h(App)</span><br><span class="line">&#125;).$mount(&#39;#app&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;login_container&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;login_box&quot;&gt;</span><br><span class="line">            &lt;!-- 头像 --&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;avatar_box&quot;&gt;</span><br><span class="line">                &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt;</span><br><span class="line">            &lt;&#x2F;div&gt;</span><br><span class="line">            &lt;!-- 登陆表单 --&gt;</span><br><span class="line">            &lt;el-form ref&#x3D;&quot;loginFormRef&quot; :rules&#x3D;&quot;loginRules&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;login_form&quot; label-width&#x3D;&quot;0&quot;&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;username&quot;&gt;</span><br><span class="line">                    &lt;el-input  v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-usercenter&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item prop&#x3D;&quot;password&quot;&gt;</span><br><span class="line">                    &lt;el-input v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-unlock&quot; type&#x3D;&quot;password&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">                &lt;el-form-item class&#x3D;&quot;btns&quot;&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;login()&quot;&gt;提交&lt;&#x2F;el-button&gt;</span><br><span class="line">                    &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;resetLoginForm()&quot;&gt;重置&lt;&#x2F;el-button&gt;</span><br><span class="line">                &lt;&#x2F;el-form-item&gt;</span><br><span class="line">            &lt;&#x2F;el-form&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            &#x2F;&#x2F; 表单数据</span><br><span class="line">            loginForm: &#123;</span><br><span class="line">                username: &quot;admin&quot;,</span><br><span class="line">                password: &quot;123456&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#x2F;&#x2F; 表单校验</span><br><span class="line">            loginRules: &#123;</span><br><span class="line">                username: [</span><br><span class="line">                    &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">                    &#123; min: 5, max: 12, message: &#39;长度在 5 到 12 个字符&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">                ],</span><br><span class="line">                password: [</span><br><span class="line">                    &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;,</span><br><span class="line">                    &#123; min: 6, max: 10, message: &#39;长度在 6 到 10 个字符&#39;, trigger: &#39;blur&#39; &#125;</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        resetLoginForm() &#123;</span><br><span class="line">            this.$refs.loginFormRef.resetFields();</span><br><span class="line">        &#125;,</span><br><span class="line">        login() &#123;</span><br><span class="line">            this.$refs.loginFormRef.validate(async valid &#x3D;&gt; &#123;</span><br><span class="line">                if(!valid) &#123;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                const &#123;data: res&#125; &#x3D; await this.$http.post(&quot;test&quot;);</span><br><span class="line">                console.log(res);</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;style lang&#x3D;&quot;less&quot; scoped&gt;</span><br><span class="line">.login_container &#123;</span><br><span class="line">    background-color: #2b4b6b;</span><br><span class="line">    height: 100%;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">.login_box &#123;</span><br><span class="line">    width: 450px;</span><br><span class="line">    height: 300px;</span><br><span class="line">    background-color: #fff;</span><br><span class="line">    border-radius: 3px;</span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    top: 50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">    .avatar_box &#123;</span><br><span class="line">        width: 130px;</span><br><span class="line">        height: 130px;</span><br><span class="line">        border: 1px solid #eee;</span><br><span class="line">        border-radius: 50%;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        box-shadow: 0 0 10px #ddd;</span><br><span class="line">        position: absolute;</span><br><span class="line">        left: 50%;</span><br><span class="line">        transform: translate(-50%,-50%);</span><br><span class="line">        background-color: #eee;</span><br><span class="line">        img &#123;</span><br><span class="line">            width: 100%;</span><br><span class="line">            height: 100%;</span><br><span class="line">            border-radius: 50%;</span><br><span class="line">            background-color: #eee;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">.btns &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: flex-end;</span><br><span class="line">&#125;</span><br><span class="line">.login_form &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    bottom: 0%;</span><br><span class="line">    width: 100%;</span><br><span class="line">    padding: 0 10px;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>后端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sport.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  全局配置类--配置跨域请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Webconfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1.域访问路径</span></span><br><span class="line"><span class="comment">     * 2.请求来源</span></span><br><span class="line"><span class="comment">     * 3.方法</span></span><br><span class="line"><span class="comment">     * 4.允许携带token等信息</span></span><br><span class="line"><span class="comment">     * 5.设置生命周期</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;http://localhost:8080/&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;PUT&quot;</span>, <span class="string">&quot;OPTION&quot;</span>, <span class="string">&quot;DELETE&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.sport.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.CrossOrigin;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> chenhy</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2021/5/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;测试成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="原因查找"><a href="#原因查找" class="headerlink" title="原因查找"></a>原因查找</h2><p>根据报错，很明显是跨域问题。那么到底在哪里出错了？前端还是后端？</p><ul><li>一开始以为是浏览器的问题，从edge转到谷歌浏览器后，问题仍然存在。</li><li>查看了前端的axios挂载以及请求的情况，请求路径没有问题。</li><li>那么就是后端的问题了。<br>我尝试着按照网上的博客来修改Webconfig .java文件，但是没有用（自己太垃圾，没改对而已）。<br>然后，我尝试着将跨域的注解直接放到方法上面：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin(origins = &quot;http://localhost:8080&quot;, maxAge = 3600)</span></span><br></pre></td></tr></table></figure>重启后，项目竟然可以正常访问了！！！<br>这个时候，我再回看之前的跨域配置文件Webconfig .java，发现竟然是url在最后多出一条斜杠的原因。<br>需要将<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost:8080/&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br></pre></td></tr></table></figure>修改为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.allowedOrigins(<span class="string">&quot;http://localhost:8080&quot;</span>, <span class="string">&quot;null&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">【前后端分离】跨域问题</summary>
    
    
    
    <category term="前后端分离" scheme="https://born2do.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
    
    <category term="error" scheme="https://born2do.github.io/tags/error/"/>
    
    <category term="跨域" scheme="https://born2do.github.io/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
</feed>
