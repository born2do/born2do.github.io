{"meta":{"title":"ChenHY的个人博客","subtitle":"","description":"","author":"chenhy","url":"https://born2do.github.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-03-01T12:03:38.729Z","updated":"2021-03-01T12:03:38.729Z","comments":false,"path":"/404.html","permalink":"https://born2do.github.io/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-01T14:02:35.954Z","updated":"2021-03-01T14:02:35.954Z","comments":false,"path":"about/index.html","permalink":"https://born2do.github.io/about/index.html","excerpt":"","text":"致力于网站建设后端开发，梦想是成为一名架构师，开发出一套高可用、有特色的开源框架，现正为之努力着。"},{"title":"书单","date":"2021-03-01T12:03:38.819Z","updated":"2021-03-01T12:03:38.819Z","comments":false,"path":"books/index.html","permalink":"https://born2do.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-03-01T12:03:38.842Z","updated":"2021-03-01T12:03:38.842Z","comments":false,"path":"categories/index.html","permalink":"https://born2do.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-03-01T12:03:38.854Z","updated":"2021-03-01T12:03:38.854Z","comments":true,"path":"links/index.html","permalink":"https://born2do.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-03-01T12:31:07.872Z","updated":"2021-03-01T12:03:38.880Z","comments":false,"path":"repository/index.html","permalink":"https://born2do.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-03-01T12:03:38.906Z","updated":"2021-03-01T12:03:38.906Z","comments":false,"path":"tags/index.html","permalink":"https://born2do.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GIT学习","slug":"GIT学习","date":"2021-07-12T23:37:30.000Z","updated":"2021-07-12T23:38:11.393Z","comments":true,"path":"2021/07/13/GIT学习/","link":"","permalink":"https://born2do.github.io/2021/07/13/GIT%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Git 工作流程一般工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 下图展示了 Git 的工作流程： Git 工作区、暂存区和版本库基本概念我们先来理解下 Git 工作区、暂存区和版本库概念： 工作区：就是你在电脑里能看到的目录。 暂存区：英文叫 stage 或 index。一般存放在 .git 目录下的 index 文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。 版本库：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。 下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系： 图中左侧为工作区，右侧为版本库。在版本库中标记为 “index” 的区域是暂存区（stage/index），标记为 “master” 的是 master 分支所代表的目录树。 图中我们可以看出此时 “HEAD” 实际是指向 master 分支的一个”游标”。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。 图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。 当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。 当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 当执行 **git rm –cached ** 命令时，会直接从暂存区删除文件，工作区则不做出改变。 当执行 git checkout . 或者 **git checkout – ** 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 当执行 git checkout HEAD . 或者 **git checkout HEAD ** 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。 Git基本操作Git的安装以及配置不在此做过多赘述。以下实操均在Windows10环境下操作。 1）在D盘新建文件夹“workspace”，进入该文件夹，右键鼠标，选择“Git Bash Here”，进入git命令行，可执行Linux下的一些命令。 12$ git init learnGitInitialized empty Git repository in D:/workspace/learnGit/.git/ 我们可以看到workspace文件夹下新建了learnGit文件夹，并且在learnGit文件夹中有个**.git**文件夹，这个文件夹就是Git的本地版本库。 2）在learnGit文件夹下新建文件readme.txt： 1234567891011121314$ cd learnGit$ ls -lrttotal 0$ vi readme.txt$ ls -lrttotal 1-rw-r--r-- 1 *** 197121 4 3月 11 21:31 readme.txt$ cat readme.txtone 3）查看文件状态： 123456789101112$ git statusOn branch masterNo commits yetUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) readme.txtnothing added to commit but untracked files present (use &quot;git add&quot; to track) 可以看到readme.txt这个文件的状态是既没有添加到缓存区也没有提交到本地版本库。 4）添加文件到缓存区，并再次查看状态： 123456789101112$ git add readme.txt warning: LF will be replaced by CRLF in readme.txt.The file will have its original line endings in your working directory$ git status On branch masterNo commits yetChanges to be committed: (use &quot;git rm --cached &lt;file&gt;...&quot; to unstage) new file: readme.txt 可以看到，文件已经添加至缓存区，等待提交至版本库。 5）提交文件到版本库，并再次查看状态： 1234567$ git commit -m &quot;first commit&quot; [master (root-commit) 805a3d4] first commit 1 file changed, 1 insertion(+) create mode 100644 readme.txt$ git status On branch masternothing to commit, working tree clean 此时，本地文件与本地版本库已经完全一致。 6）使用编辑器修改本地文件readme.txt，再比较本地文件（工作区）与缓存区的差异。 123456789101112131415$ cat readme.txtonetwo$ git diffwarning: LF will be replaced by CRLF in readme.txt.The file will have its original line endings in your working directorydiff --git a/readme.txt b/readme.txtindex 5626abf..814f4a4 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1,2 @@ one+two 可以看到工作区比暂存区文件多出一行。 7）比较工作区与本地版本库文件的差异： 1234567891011$ git diff masterwarning: LF will be replaced by CRLF in readme.txt.The file will have its original line endings in your working directorydiff --git a/readme.txt b/readme.txtindex 5626abf..814f4a4 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1,2 @@ one+two 8）将文件添加至缓存区，比较缓存区与本地版本库的差异： 1234567891011$ git add readme.txt warning: LF will be replaced by CRLF in readme.txt.The file will have its original line endings in your working directory$ git diff --cached diff --git a/readme.txt b/readme.txtindex 5626abf..814f4a4 100644--- a/readme.txt+++ b/readme.txt@@ -1 +1,2 @@ one+two 9）添加至版本库，并查看提交日志。 1234567891011121314151617181920$ git commit -m &quot;secode&quot;[master 2238358] secode 1 file changed, 1 insertion(+)$ git log -vcommit 22383582753d734a5e57c816be15d79e9ce26754 (HEAD -&gt; master)Author: *** &lt;***@163.com&gt;Date: Thu Mar 11 22:17:59 2021 +0800 secodecommit 805a3d475a05485393de8b85374b35accccae9feAuthor: *** &lt;***@163.com&gt;Date: Thu Mar 11 21:41:48 2021 +0800 first commit$ git log --pretty=oneline22383582753d734a5e57c816be15d79e9ce26754 (HEAD -&gt; master) secode805a3d475a05485393de8b85374b35accccae9fe first commit 可以看到全部共两次提交的记录。 10）回退到上一个版本 12345$ git reset --hard head^ HEAD is now at 805a3d4 first commit$ cat readme.txtone 11）回退到任意版本（hard后面的版本号不必写全） 1234567$ git reset --hard 22383582753d734a5e57c816be15d79e9ce26754HEAD is now at 2238358 secode$ cat readme.txtonetwo 使用文本的方式演示实在是太麻烦了，更多实用操作请自行检索。 也可参照B站视频，走一遍流程也就差不多了。 视频地址：https://www.bilibili.com/video/BV1oJ411d71q?p=1 参考https://www.runoob.com/git/git-tutorial.html","categories":[{"name":"GIT","slug":"GIT","permalink":"https://born2do.github.io/categories/GIT/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"https://born2do.github.io/tags/GIT/"}],"author":"chenhy"},{"title":"本地maven仓库清理","slug":"本地maven仓库清理","date":"2021-07-12T23:08:33.000Z","updated":"2021-07-12T23:11:19.611Z","comments":true,"path":"2021/07/13/本地maven仓库清理/","link":"","permalink":"https://born2do.github.io/2021/07/13/%E6%9C%AC%E5%9C%B0maven%E4%BB%93%E5%BA%93%E6%B8%85%E7%90%86/","excerpt":"","text":"Windows环境下，清理本地maven仓库。 清理脚本如下： 1234567set REPOSITORY_PATH=D:\\MavenRepositoryrem 正在搜索...for /f &quot;delims=&quot; %%i in (&#x27;dir /b /s &quot;%REPOSITORY_PATH%\\*lastUpdated*&quot;&#x27;) do ( del /s /q %%i)rem 搜索完毕pause 对路径稍作修改，运行一下即可。","categories":[{"name":"清理","slug":"清理","permalink":"https://born2do.github.io/categories/%E6%B8%85%E7%90%86/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://born2do.github.io/tags/maven/"}],"author":"chenhy"},{"title":"注解+AOP实现日志功能","slug":"注解-AOP实现日志功能","date":"2021-07-06T14:23:52.000Z","updated":"2021-07-06T15:04:27.599Z","comments":true,"path":"2021/07/06/注解-AOP实现日志功能/","link":"","permalink":"https://born2do.github.io/2021/07/06/%E6%B3%A8%E8%A7%A3-AOP%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E5%8A%9F%E8%83%BD/","excerpt":"","text":"背景现有项目有两类日志系统，一个是logback日志，一个是框架层面自己实现的对特定库表数据增删改查操作的日志。但是对于前台的用于生成文档、或是生成库表数据的按钮并没有加以控制，无法得知操作人员进行了哪些操作。项目经理要求加这么个通用模块，也的确很有必要。 思路 对于这个通用日志模块，首先肯定是要设计一个库表，自行设计即可。用户、模块、方法功能、参数列表、参数值、时间戳等等。 采用何种方式去实现该功能？系统现有的两个日志框架，对于这个通用日志模块的开发，并无太大用处。需要另辟蹊径。 实现该功能应该注意哪些？由于是对原有系统功能加操作日志，首先不能影响原有功能的实现，其次不能对原有代码造成过大的侵入性（这也是我拒绝在原有代码中进行将操作日志插入库表的原因），还有不能影响效率等等。 考虑到这，我的选择是AOP，因为切面的方式可以完美解决上述考虑。 但是，我们对哪些操作需要进行记录操作日志是有选择的，考虑到项目比较大，总不能指定所有的包吧？所以我选择了使用自定义注解的方式。 最终，自定义注解+AOP的实现方式被我采纳。 实现自定义注解： 123456789101112131415161718192021package com.born2do.emsys.annotation;import java.lang.annotation.*;/** * 自定义日志注解 * @author chenhy * @date 2021/7/1 */@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface LogAnnotation &#123; String module(); //模块名 String function(); //功能名 String remark() default &quot;&quot;; //自定义内容&#125; 切面： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package com.born2do.emsys.aop;import com.born2do.emsys.annotation.LogAnnotation;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.context.annotation.EnableAspectJAutoProxy;import org.springframework.stereotype.Component;import java.lang.reflect.Method;/** * @author chenhy * @date 2021/7/1 */@Aspect //表示为切面类@Component //交由spring去管理@EnableAspectJAutoProxy(proxyTargetClass = true) //默认为false。true表示使用cglib代理，false表示jdk动态代理public class LogAnnotationAspect &#123; //设置切入点（此处为使用LogAnnotation注解的方法） @Pointcut(&quot;@annotation(com.born2do.emsys.annotation.LogAnnotation)&quot;) public void pointcutConfig() &#123; &#125; @Before(&quot;pointcutConfig()&quot;) public void doBefore(JoinPoint joinPoint) &#123; System.out.println(&quot;前置通知--方法前执行&quot; + joinPoint); &#125; @After(&quot;pointcutConfig()&quot;) public void doAfter(JoinPoint joinPoint) &#123; System.out.println(&quot;后置通知--方法后执行&quot; + joinPoint); &#125; @AfterReturning(&quot;pointcutConfig()&quot;) public void doAfterReturning(JoinPoint joinPoint) &#123; System.out.println(&quot;返回通知--调用获得返回值后执行&quot; + joinPoint); &#125; @AfterThrowing(&quot;pointcutConfig()&quot;) public void doAfterThrowing(JoinPoint joinPoint) &#123; System.out.println(&quot;异常通知--抛出异常后执行&quot; + joinPoint); &#125; @Around(&quot;pointcutConfig()&quot;) public Object doAround(ProceedingJoinPoint pjp) &#123; /*result为连接点的放回结果*/ Object result = null; // 目标类 Class targetClass = pjp.getTarget().getClass(); // 目标类的所有方法 Method[] methods = targetClass.getMethods(); // 切点方法 String methodName = pjp.getSignature().getName(); // 切点方法传入的参数值 Object[] argsValue = pjp.getArgs(); for (Method method : methods) &#123; //找到切入点对应的方法 if (method.getName().equals(methodName)) &#123; //拿到方法上的注解对象，获取参数值 LogAnnotation logAnnotation = method.getAnnotation(LogAnnotation.class); String module = logAnnotation.module(); String function = logAnnotation.function(); String remark = logAnnotation.remark(); // 获取该切点方法的参数列表 Object[] param = method.getParameters(); &#125; &#125; /*前置通知*/ System.out.println(&quot;前置通知：目标类名：&quot; + targetClass.getName()); /*执行目标方法*/ try &#123; result = pjp.proceed(); /*返回通知*/ System.out.println(&quot;返回通知：目标方法名&quot; + methodName + &quot;，返回结果为：&quot; + result); &#125; catch (Throwable e) &#123; /*异常通知*/ System.out.println(&quot;异常通知：目标方法名&quot; + methodName + &quot;，异常为：&quot; + e.getMessage()); &#125; /*后置通知*/ System.out.println(&quot;后置通知：目标方法名&quot; + methodName); // 基本上所有参数都已经获取，在此处可以进行插入库表等操作 return result; &#125;&#125; 测试类： 123456789101112131415161718192021222324package com.born2do.emsys.controller;import com.born2do.emsys.annotation.LogAnnotation;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;/** * @author chenhy * @date 2021/6/4 */@RestControllerpublic class TestController &#123; @LogAnnotation(module = &quot;测试模块&quot;, function = &quot;用于测试SpringMVC项目框架是否搭建成功&quot;) @RequestMapping(&quot;/test&quot;) public String test(@RequestParam(&quot;id&quot;) int id) &#123; System.out.println(&quot;进入 /test 路径&quot;); return &quot;OK&quot;; &#125;&#125; 通用日志功能的实现主要依靠于前两个类，当然，在目标方法上添加自定义注解也很重要。 如想运行上述代码，还请自行新建SpringBoot项目，将代码嵌入项目中。 测试结果浏览器访问 localhost:50000/test?id=1 控制台输出如下日志： 1234567前置通知：目标类名：com.born2do.emsys.controller.TestController前置通知--方法前执行execution(String com.born2do.emsys.controller.TestController.test(int))进入 &#x2F;test 路径返回通知--调用获得返回值后执行execution(String com.born2do.emsys.controller.TestController.test(int))后置通知--方法后执行execution(String com.born2do.emsys.controller.TestController.test(int))返回通知：目标方法名test，返回结果为：OK后置通知：目标方法名test","categories":[],"tags":[{"name":"注解","slug":"注解","permalink":"https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"AOP","slug":"AOP","permalink":"https://born2do.github.io/tags/AOP/"}],"author":"chenhy"},{"title":"【MySQL】MySQL自带数据库解析","slug":"【MySQL】MySQL自带数据库解析","date":"2021-06-02T14:36:12.000Z","updated":"2021-06-02T14:38:59.106Z","comments":true,"path":"2021/06/02/【MySQL】MySQL自带数据库解析/","link":"","permalink":"https://born2do.github.io/2021/06/02/%E3%80%90MySQL%E3%80%91MySQL%E8%87%AA%E5%B8%A6%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E6%9E%90/","excerpt":"","text":"MySQL数据库版本Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 265Server version: 5.7.25 MySQL Community Server (GPL)Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type ‘help;’ or ‘\\h’ for help. Type ‘\\c’ to clear the current input statement. information_schemainformation_schema保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。在information_schema中，有数个只读表。它们实际上是视图，而不是基本表，因此，你将无法看到与之相关的任何文件。information_schema数据库表说明:SCHEMATA：提供了当前mysql实例中所有数据库的信息。show databases;TABLES：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。show tables from schemaname;COLUMNS：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。show columns from schemaname.tablename;STATISTICS：提供了关于表索引的信息。show index from schemaname.tablename;USER_PRIVILEGES（用户权限）：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。SCHEMA_PRIVILEGES（方案权限）：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。TABLE_PRIVILEGES（表权限）：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。COLUMN_PRIVILEGES（列权限）：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。CHARACTER_SETS（字符集）：提供了mysql实例可用字符集的信息。show character set;COLLATIONS：提供了关于各字符集的对照信息。COLLATION_CHARACTER_SET_APPLICABILITY：指明了可用于校对的字符集。这些列等效于show collation;的前两个显示字段。TABLE_CONSTRAINTS：描述了存在约束的表。以及表的约束类型。KEY_COLUMN_USAGE：描述了具有约束的键列。ROUTINES：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。VIEWS：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。TRIGGERS：提供了关于触发程序的信息。必须有super权限才能查看该表。 mysqlmysql是mysql的核心数据库，主要负责存储数据库的用户、权限设置、关键字等mysql自己需要使用的控制和管理信息。 performance_schemaperformance_schema主要用于收集数据库服务器性能参数，如提供进程等待的详细信息，包括锁、互斥变量、文件信息；保存历史的事件汇总信息，为提供MySQL服务器性能做出详细的判断；对于新增和删除监控事件点都非常容易，并可以改变MySQL服务器的监控周期等。 12345678910111213141516171819202122232425mysql&gt; use performance_schema;Database changedmysql&gt; show tables;+----------------------------------------------+| Tables_in_performance_schema |+----------------------------------------------+| cond_instances || events_waits_current || events_waits_history || events_waits_history_long || events_waits_summary_by_instance || events_waits_summary_by_thread_by_event_name || events_waits_summary_global_by_event_name || file_instances || file_summary_by_event_name || file_summary_by_instance || mutex_instances || performance_timers || rwlock_instances || setup_consumers || setup_instruments || setup_timers || threads |+----------------------------------------------+17 rows in set (0.00 sec) 这里的数据表分为几类：1）setup table ： 设置表，配置监控选项。2）current events table : 记录当前那些thread 正在发生什么事情。3）history table 发生的各种事件的历史记录表4）summary table 对各种事件的统计表5）其他。setup 表： 12345678910mysql&gt; SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES -&gt; WHERE TABLE_SCHEMA &#x3D; &#39;performance_schema&#39; -&gt; AND TABLE_NAME LIKE &#39;setup%&#39;;+-------------------+| TABLE_NAME |+-------------------+| setup_consumers || setup_instruments || setup_timers |+-------------------+ setup_consumers 描述各种事件setup_instruments 描述这个数据库下的表名以及是否开启监控。setup_timers 描述监控选项已经采样频率的时间间隔 syssys是MySQL5.7新增的系统数据库，其在MySQL5.7中是默认存在的，在MySQL5.6及以上版本可以手动导入。这个库通过视图的形式把information_schema和performance_schema结合起来，查询出更加令人容易理解的数据。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/tags/MySQL/"}],"author":"chenhy"},{"title":"【FTP】Windows访问vsftp服务器报错","slug":"【FTP】Windows访问vsftp服务器报错","date":"2021-05-26T13:24:24.000Z","updated":"2021-05-26T13:30:50.747Z","comments":true,"path":"2021/05/26/【FTP】Windows访问vsftp服务器报错/","link":"","permalink":"https://born2do.github.io/2021/05/26/%E3%80%90FTP%E3%80%91Windows%E8%AE%BF%E9%97%AEvsftp%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%A5%E9%94%99/","excerpt":"","text":"情景再现Windows连接vsftp服务器放置文件，报错如下： 打开FTP服务器上的文件夹时发生错误。请检查是否有权限访问该文件夹。详细信息：200 Switching to ASCII model.277 Entering Passive Model(192,184,90). 原因port方式在传输数据时，是Server端连接client端，有一个条件：它必须有一个公网ip。如果client处于防火墙或net网关后面，server就找不到client端，就会报错。所有的ftp客户端软件都支持两种传输方式，IE默认是port(主动)。 解决IE浏览器-&gt;Internet选项-&gt;高级-&gt;将“使用被动FTP（用于防火墙和DSL调制解调器的兼容）”选项去掉勾选-&gt;确定。 扩展FTP主动模式(active mode)与被动模式(passive mode)的工作原理主动模式（服务器向客户端敲门，然后客户端开门）FTP：客户机与服务器之间建立连接时，客户机是大于1024的端口上，服务器是20端口。客户机的端口是大于1024的，而服务器的端口是21端口接收请求，而是20端口给客户机回应。允许FTP客户机从大于1024的端口连接服务器的21端口。允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。允许FTP服务器从20端口主动连接FTP客户机中大于1024的端口。允许FTP客户机从大于1024的端口回应来自FTP服务器的20端口的网络连接。命令连接：客户端大于1024的端口 -&gt; 服务器 21端口数据连接：服务器 20端口 -&gt; 客户端大于1024的端口 被动模式（客户端向服务器敲门，然后服务器开门）FTP：客户机与服务器之间建立连接都是在大于1024的端口上的。客户机的端口是大于1024的，而服务器的端口是21端口接收请求，而是从大于1024端口给客户机回应。允许FTP客户机从大于1024的端口连接服务器的21端口。允许FTP服务器从21端口回应FTP客户机中大于1024端口的网络连接。允计FTP客户机从大于1024的端口连接FTP服务器的大于1024端口。允许FTP服务器从大于1024的端口回应来自FTP客户机大于1024端口的网络连接。命令连接：客户端大于1024的端口 -&gt; 服务器 21端口数据连接：客户端大于1024的端口 -&gt; 服务器大于1024的端口","categories":[{"name":"FTP","slug":"FTP","permalink":"https://born2do.github.io/categories/FTP/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【Linux】给其他用户开启crontab","slug":"【Linux】给其他用户开启crontab","date":"2021-05-24T13:58:54.000Z","updated":"2021-05-24T13:59:21.728Z","comments":true,"path":"2021/05/24/【Linux】给其他用户开启crontab/","link":"","permalink":"https://born2do.github.io/2021/05/24/%E3%80%90Linux%E3%80%91%E7%BB%99%E5%85%B6%E4%BB%96%E7%94%A8%E6%88%B7%E5%BC%80%E5%90%AFcrontab/","excerpt":"","text":"在服务器上新建了vlog用户，想要开启定时任务，但是系统直接提示没有crontab权限。解决：使用vlog用户登录，执行如下命令即可： 1234# 找到crontab命令所在路径cd /usr/bin# 给其他用户赋权限chmod o+x crontab","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"crontab","slug":"crontab","permalink":"https://born2do.github.io/tags/crontab/"}],"author":"chenhy"},{"title":"【Java】IO流未正确关闭导致的读写问题","slug":"【Java】IO流未正确关闭导致的读写问题","date":"2021-05-22T08:58:55.000Z","updated":"2021-05-22T08:59:30.628Z","comments":true,"path":"2021/05/22/【Java】IO流未正确关闭导致的读写问题/","link":"","permalink":"https://born2do.github.io/2021/05/22/%E3%80%90Java%E3%80%91IO%E6%B5%81%E6%9C%AA%E6%AD%A3%E7%A1%AE%E5%85%B3%E9%97%AD%E5%AF%BC%E8%87%B4%E7%9A%84%E8%AF%BB%E5%86%99%E9%97%AE%E9%A2%98/","excerpt":"","text":"情景再现同事写的一段代码，主要功能是生成本地文件并调用脚本将其连同上级文件夹进行打包，应用环境为Linux。但是，在服务器上运行后，发现打包的文件为空文件。 问题排查因为本地开发环境为Windows，并不能执行shell脚本，所以同事在本地开发测试时认为文件正常生成就基本没问题了，也就没顾及太多将代码提交了。因为本地正常生成文件，而服务器的压缩包没有文件内容，所以我首先对本地与SVN上的代码进行了比对，排查是否是由于代码问题导致源文件根本就没有生成内容继而导致目标压缩包中的文件也没有内容。 比对本地代码与SVN上的代码后，并无发现异常，排除代码提交问题。 修改了应用服务器上的shell脚本，使其在正常打包后不删除源文件。再次执行相关作业，源文件内容正常，目标压缩包中的文件为空白。排除了代码导致的源文件内容未正常生成。 代码和文件都没有发现问题，源文件也正常生成，那就可能是打包的问题了。在源文件正常存在的情形下，使用相关用户执行该脚本，发现正常打包，文件一切正常。 手工执行脚本，文件正常打包，而应用执行脚本却发生了，打包后文件内容为空白的情况。我又怀疑是权限问题，因为如果没有读写权限的话，cp或是tar也会发生目标文件为空的情况。我在脚本中给源文件夹添加了777的权限，这下总不能再失败了吧。 执行结果与前几次相同，目标压缩包中的文件仍为空白。排除权限问题。 排除到这时候，已经没有了方向。我尝试着对其他文件夹进行打包操作，发现全部都正常打包了，并未发生内容丢失的情况。说明脚本中打包命令的使用是没有问题的。 在目标文件夹放入了其他文件，和之前生成的源文件（名字改掉），再次执行作业，打包的结果显示，只有程序生成的那个文件打包后发生内容丢失的情况。排查方向又再次回来了，打包时文件的状态不对劲。 文件状态不对，又涉及到文件读写，我的第一反应是IO流的处理。但是我们是有代码扫描的，之前她就提过一版专门修复流的问题，是通过的呀？流肯定是关闭了的。 我在本地更新代码后，一眼就看到了问题。IO流的确是被关闭了，但是调用脚本进行打包的时机不对，那个时候流还未关闭。这就导致了，调用脚本在进行打包操作时，源文件的状态是正在被写入当中，服务器在执行tar命令时，读取到的文件是空白的，这也很好地解释了为什么源文件正常，而目标压缩包中文件为空白。也能解释为什么手工执行脚本，一切正常，因为那时候源文件的状态已经是写完成的状态了，不再被其他线程占用。 下面是问题代码的demo123456789101112131415161718192021222324252627public static void main(String[] args) throws Exception &#123; FileOutputStream fos = null; OutputStreamWriter osw = null; BufferedWriter bw = null; try &#123; fos = new FileOutputStream(&quot;d:\\\\a.txt&quot;); osw = new OutputStreamWriter(fos, &quot;UTF-8&quot;); bw = new BufferedWriter(osw); bw.write(&quot;java IO close test&quot;); // 调用shell脚本进行打包操作 doTarFile(); &#125; finally &#123; if (bw != null) &#123; System.out.println(&quot;bw未关闭&quot;); bw.close(); &#125; if (osw != null) &#123; System.out.println(&quot;osw未关闭&quot;); osw.close(); &#125; if (fos != null) &#123; System.out.println(&quot;fos未关闭&quot;); fos.close(); &#125; &#125;&#125; 问题解决脚本不做改动，代码中调用脚本的那段代码提出来，放到外层方法的写文件方法之后。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"IO流","slug":"IO流","permalink":"https://born2do.github.io/tags/IO%E6%B5%81/"}],"author":"chenhy"},{"title":"【DB2】常用SQL函数","slug":"【DB2】常用SQL函数","date":"2021-05-16T09:32:22.000Z","updated":"2021-05-16T09:32:48.085Z","comments":true,"path":"2021/05/16/【DB2】常用SQL函数/","link":"","permalink":"https://born2do.github.io/2021/05/16/%E3%80%90DB2%E3%80%91%E5%B8%B8%E7%94%A8SQL%E5%87%BD%E6%95%B0/","excerpt":"","text":"coalesce函数COALESCE是一个函数，(expression_1, expression_2, …,expression_n)依次参考各参数表达式，遇到非null值即停止并返回该值。如果所有的表达式都是空值，最终将返回一个空值。使用COALESCE在于大部分包含空值的表达式最终将返回空值。 1select coalesce(null,33) as test; 返回33。 case函数简单case函数12345case sex when &#39;1&#39; then &#39;男&#39; when &#39;2&#39; then &#39;女&#39; else &#39;其他&#39; end case搜索函数12345case when sex &#x3D; &#39;1&#39; then &#39;男&#39; when sex &#x3D; &#39;2&#39; then &#39;女&#39; else &#39;其他&#39; end 说明： 这两种方式，可以实现相同的功能。简单case函数的写法相对比较简洁，但是和case搜索函数相比，功能方面会有些限制，比如写判定式。 还有一个需要注重的问题，case函数（两种）只返回第一个符合条件的值，剩下的case部分将会被自动忽略。","categories":[{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/categories/DB2/"}],"tags":[{"name":"函数","slug":"函数","permalink":"https://born2do.github.io/tags/%E5%87%BD%E6%95%B0/"}],"author":"chenhy"},{"title":"【eclipse】新建的maven工程没有显示.calsspath、.project等文件","slug":"【eclipse】新建的maven工程没有显示-calsspath、-project等文件","date":"2021-05-15T08:53:20.000Z","updated":"2021-05-15T08:53:38.533Z","comments":true,"path":"2021/05/15/【eclipse】新建的maven工程没有显示-calsspath、-project等文件/","link":"","permalink":"https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BA%E7%9A%84maven%E5%B7%A5%E7%A8%8B%E6%B2%A1%E6%9C%89%E6%98%BE%E7%A4%BA-calsspath%E3%80%81-project%E7%AD%89%E6%96%87%E4%BB%B6/","excerpt":"","text":"描述： 使用eclipse新建的maven工程没有显示.calsspath、.project等文件 解决：1.选中工程，选择Filters。 2.取消.resources勾选，点击OK即可。 3.设置完成。","categories":[{"name":"maven","slug":"maven","permalink":"https://born2do.github.io/categories/maven/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【eclipse】新建maven项目后pom.xml文件报错","slug":"【eclipse】新建maven项目后pom-xml文件报错","date":"2021-05-15T08:52:33.000Z","updated":"2021-05-15T08:52:58.139Z","comments":true,"path":"2021/05/15/【eclipse】新建maven项目后pom-xml文件报错/","link":"","permalink":"https://born2do.github.io/2021/05/15/%E3%80%90eclipse%E3%80%91%E6%96%B0%E5%BB%BAmaven%E9%A1%B9%E7%9B%AE%E5%90%8Epom-xml%E6%96%87%E4%BB%B6%E6%8A%A5%E9%94%99/","excerpt":"","text":"报错： pom.xml命名空间报错。 war报错。 解决： 右键项目，选择maven，然后update project即可。命名空间报错消失。 打包方式报错是由于工程中缺少了web.xml文件（/src/main/webapp/WEB-INF/web.xml）。项目名称–&gt;右键–&gt;Java EE Tools–&gt;generate deployment descriptor stub ，鼠标点击后，系统会自动加入 web.xml 省去手动 复制web.xml的步骤。","categories":[{"name":"maven","slug":"maven","permalink":"https://born2do.github.io/categories/maven/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【2019】牛客网Java笔记","slug":"【2019】牛客网Java笔记","date":"2021-05-13T14:24:23.000Z","updated":"2021-05-13T14:25:40.277Z","comments":true,"path":"2021/05/13/【2019】牛客网Java笔记/","link":"","permalink":"https://born2do.github.io/2021/05/13/%E3%80%902019%E3%80%91%E7%89%9B%E5%AE%A2%E7%BD%91Java%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一星题 方法重载：方法名称相同，参数列表不同（可以是参数的类型、个数、顺序不同） 方法重载满足的条件： 同一个类中，方法名相同，参数列表不同的2个或多个方法构成方法的重载 参数列表不同指参数的类型，参数的个数，参数的顺序至少一项不同 方法的返回值类型，方法的修饰符可以不同。 注意 ，如果两个方法只有返回值类型不同， 这两个方法在编译器看来还是同一个方法。 java源文件的后缀名是.java。 源文件通过jvm虚拟机编译后会生成二进制字节码文件，后缀是.class。 javac.exe是编译功能javaCompilerjava.exe是执行class 如果没有编译的话是不能执行的，同理，javac.exe编译完以后如果没有java.exe执行的话也是没有运行的。 一个jvm中默认的classloader有Bootstrap ClassLoader、Extension ClassLoader、App ClassLoader，分别各司其职： Bootstrap ClassLoader：负责加载java基础类，主要是 %JRE_HOME/lib/ 目录下的rt.jar、resources.jar、charsets.jar和class等。 Extension ClassLoader：负责加载java扩展类，主要是 %JRE_HOME/lib/ext 目录下的jar和class。 App ClassLoader：负责加载当前java应用的classpath中的所有类。 classloader 加载类用的是全盘负责委托机制。所谓全盘负责，即是当一个classloader加载一个Class的时候，这个Class所依赖的和引用的所有 Class也由这个classloader负责载入，除非是显式的使用另外一个classloader载入。所以，当我们自定义的classloader加载成功了 com.company.MyClass以后，MyClass里所有依赖的class都由这个classLoader来加载完成。 比较两个类是否相等，只有这两个类是由同一个类加载器加载才有意义。否则，即使这两个类是来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类必定不相等。 我们应用程序都是由以上三种类加载器互相配合进行加载的，还可以加入自己定义的类加载器。称为类加载器的双亲委派模型，这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的。 优先级：单目&gt;运算&gt;移位&gt;比较&gt;按位&gt;逻辑&gt;三目&gt;赋值 简记：淡云一笔安洛三幅。 动态 INCLUDE 用 jsp:include 动作实现 &lt;jsp:include page=”included.jsp” flush=”true” /&gt; 它总是会检查所含文件中的变化 , 适合用于包含动态页面 , 并且可以带参数。各个文件分别先编译，然后组合成一个文件。 静态 INCLUDE 用 include 伪码实现 , 定不会检查所含文件的变化 , 适用于包含静态页面 &lt;%@ include file=”included.htm” %&gt; 。先将文件的代码被原封不动地加入到了主页面从而合成一个文件，然后再进行翻译，此时不允许有相同的变量。 以下是对 include 两种用法的区别 ， 主要有两个方面的不同：一、执行时间上 : &lt;%@ include file=”relativeURI”%&gt; 是在翻译阶段执行 &lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 在请求处理阶段执行。 二、引入内容的不同 : &lt;%@ include file=&quot;relativeURI&quot;%&gt; 引入静态文本 (html,jsp), 在 JSP 页面被转化成 servlet 之前和它融和到一起。 &lt;jsp:include page=&quot;relativeURI&quot; flush=&quot;true&quot; /&gt; 引入执行页面或 servlet 所生成的应答文本。 方法的重写需要满足：三同一大一小（方法名、返回值类型、形参相同；访问权限&gt;=重写前；抛出异常&lt;=重写前） 优先级高的并不一定会马上执行。 sleep方法会阻塞一个线程并不会终止。 创建一个新的线程时也不会终止另一个线程。 当抛出一个异常后程序会结束，所以线程也会被终止。 java中将ISO8859-1字符串转成GB2312编码，语句为 ？ new String(“ISO8859-1”.getBytes(“ISO8859-1”),”GB2312”) 创建并启动线程的过程为：定义线程—》实例化线程—》启动线程。 一 、定义线程：1、扩展java.lang.Thread类。 2、实现java.lang.Runnable接口。 二、实例化线程： 1、如果是扩展java.lang.Thread类的线程，则直接new即可。 2、如果是实现了java.lang.Runnable接口的类，则用Thread的构造方法： 12345&gt;Thread(Runnable target) &gt;Thread(Runnable target, String name) &gt;Thread(ThreadGroup group, Runnable target) &gt;Thread(ThreadGroup group, Runnable target, String name) &gt;Thread(ThreadGroup group, Runnable target, String name, long stackSize) Exception（异常）是程序本身可以处理的异常。主要包含RuntimeException等运行时异常和IOException，SQLException等非运行时异常。运行时异常包括：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常（编译异常）包括：RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 io流方面的知识：要将文件中一个字符写入另一个文件，首先要读入（FileInputStream）到内存中去，然后再读出（FileOutputStream）。 结构型模式是描述如何将类对象结合在一起，形成一个更大的结构，结构模式描述两种不同的东西：类与类的实例。故可以分为类结构模式和对象结构模式。 在GoF设计模式中，结构型模式有： 1.适配器模式 Adapter 适配器模式是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 两个成熟的类需要通信，但是接口不同，由于开闭原则，我们不能去修改这两个类的接口，所以就需要一个适配器来完成衔接过程。 2.桥接模式 Bridge 桥接模式将抽象部分与它的实现部分分离，是它们都可以独立地变化。它很好的支持了开闭原则和组合锯和复用原则。实现系统可能有多角度分类，每一种分类都有可能变化，那么就把这些多角度分离出来让他们独立变化，减少他们之间的耦合。 3.组合模式 Composite 组合模式将对象组合成树形结构以表示部分-整体的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。 4.装饰模式 Decorator 装饰模式动态地给一个对象添加一些额外的职责，就增加功能来说，它比生成子类更灵活。也可以这样说，装饰模式把复杂类中的核心职责和装饰功能区分开了，这样既简化了复杂类，有去除了相关类中重复的装饰逻辑。 装饰模式没有通过继承原有类来扩展功能，但却达到了一样的目的，而且比继承更加灵活，所以可以说装饰模式是继承关系的一种替代方案。 5.外观模式 Facade 外观模式为子系统中的一组接口提供了同意的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式中，客户对各个具体的子系统是不了解的，所以对这些子系统进行了封装，对外只提供了用户所明白的单一而简单的接口，用户直接使用这个接口就可以完成操作，而不用去理睬具体的过程，而且子系统的变化不会影响到用户，这样就做到了信息隐蔽。 6.享元模式 Flyweight 享元模式为运用共享技术有效的支持大量细粒度的对象。因为它可以通过共享大幅度地减少单个实例的数目，避免了大量非常相似类的开销。 享元模式是一个类别的多个对象共享这个类别的一个对象，而不是各自再实例化各自的对象。这样就达到了节省内存的目的。 7.代理模式 Proxy 为其他对象提供一种代理，并由代理对象控制对原对象的引用，以间接控制对原对象的访问。 CGI(Common Gateway Interface)，通用网关接口通用网关接口，简称CGI，是一种根据请求信息动态产生回应内容的技术。通过CGI，Web服务器可以将根据请求不同启动不同的外部程序，并将请求内容转发给该程序，在程序执行结束后，将执行结果作为回应返回给客户端。也就是说，对于每个请求，都要产生一个新的进程进行处理。因为每个进程都会占有很多服务器的资源和时间，这就导致服务器无法同时处理很多的并发请求。另外CGI程序都是与操作系统平台相关的，虽然在互联网爆发的初期，CGI为开发互联网应用做出了很大的贡献，但是随着技术的发展，开始逐渐衰落。ServletServlet最初是在1995年由James Gosling提出的，因为使用该技术需要复杂的Web服务器支持，所以当时并没有得到重视，也就放弃了。后来随着Web应用复杂度的提升，并要求提供更高的并发处理能力，Servlet被重新捡起，并在Java平台上得到实现，现在提起Servlet，指的都是Java Servlet。JavaServlet要求必须运行在Web服务器当中，与Web服务器之间属于分工和互补关系。确切的说，在实际运行的时候Java Servlet与Web服务器会融为一体，如同一个程序一样运行在同一个Java虚拟机（JVM）当中。与CGI不同的是，Servlet对每个请求都是单独启动一个线程，而不是进程。这种处理方式大幅度地降低了系统里的进程数量，提高了系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也就解决了跨平台问题。如果没有Servlet的出现，也就没有互联网的今天。在Servlet出现之后，随着使用范围的扩大，人们发现了它的一个很大的一个弊端。那就是为了能够输出HTML格式内容，需要编写大量重复代码，造成不必要的重复劳动。为了解决这个问题，基于Servlet技术产生了JavaServet Pages技术，也就是JSP。Servlet和JSP两者分工协作，Servlet侧重于解决运算和业务逻辑问题，JSP则侧重于解决展示问题。Servlet与JSP一起为Web应用开发带来了巨大的贡献，后来出现的众多Java Web应用开发框架都是基于这两种技术的，更确切的说，都是基于Servlet技术的。——————–分割线————————- Servlet处于服务器进程中，它通过多线程方式运行其service方法，一个实例可以服务于多个请求，并且其实例一般不会销毁。 而CGI对每个请求都产生新的进程，服务完成后就销毁，所以效率上低于Servlet 。 CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。 顶层容器是指可以不能被其他容器包含 ，是容纳其他容器的容器组件，顶层容器包含JApplet、JDialog、JFrame和JWindow及其子类.JFrame中就可以放Jtree（树形组件）。 Java继承中对构造函数是不继承的，只是显式或者隐式调用。 Java中有两种方式实现线程： class A继承Thread，并重写run方法，new A().start()，就执行了线程 class A实现Runnable，实现run方法，new Thread(new A()).start() 2.class A实现Runnable，实现run方法，new Thread(new A()).start() 当然以上方式run方法都是无返回值的，如果需要返回值，需要Callable接口。 public static void main (String[] args) &#123; String classFile = &quot;com.jd.&quot;. replaceAll(&quot;.&quot;, &quot;/&quot;) + &quot;MyClass.class&quot;; System.out.println(classFile); &#125; 12345678910111213141516171819202122232425262728293031 由于replaceAll方法的第一个参数是一个正则表达式，而&quot;.&quot;在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成&quot;&#x2F;&quot;。如果想替换的只是&quot;.&quot;，那么久要写成&quot;\\\\.&quot;。故结果为&#96;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;MyClass.class&#96;。19. 通过JDBC访问数据库包含下面哪几步？ - 载入JDBC驱动程序 - 建立连接 - 执行查询或更新 - 关闭连接20. 重载对返回值没有要求，可以相同，也可以不同；但是如果参数的个数、类型、次序都相同，方法名也相同，仅返回值不同，则无法构成重载。21. HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值前，会去判断当前Map中是否含有该key对象，内部是先通过key的hashCode，确定有相同的hashCode之后，再通过equals方法判断是否相同。22. &gt; Character 字符封装类 &gt; &gt;String 常量池中字符串 &gt; &gt;StringBuffer 存放字符数组 &gt; &gt;Vector 数组23. 二维数组声明： &#96;&#96;&#96;java int [][] table &#x3D; new int[2][2]; int [][] table1 &#x3D; new int[2][]; int [] table2 [] &#x3D; new int[2][2]; int [] table3 [] &#x3D; new int[2][]; int table4 [][] &#x3D; new int[2][2]; int table5 [][] &#x3D; new int[2][]; 接口中声明的成员变量默认为static final成员（不管是基础数据类型还是引用类型），且必须初始化； 接口中声明的方法默认为public且不能有实现体，即｛｝，方法体可有参数； 实现接口的类，必须实现接口中所有方法，且不能降低方法的运用域，即必须显示声明为public； 抽象类不需要实现接口的方法。抽象类也可以实现接口，但是可以实现部分或者一个都不实现； 在jdk8之后添加了默认方法，在返回值加上default关键字，然后还有方法体;该接口被扩展时，可以直接继承或重新声明。还添加了静态方法。 非构造方法必须要有返回类型，其实构造方法的返回类型是void，只不过不能写出来而已。 局部变量的作用范围仅仅在定义它的方法内，或者是在定义它的控制流块中。 实例方法可直接调用本类的类方法。 在Applet中，方法执行的顺序是init(), start(), paint(),stop(),destroy()。 局部变量是定义在方法中的变量，必须要进行初始化，否则不能通过编译。 class X&#123; Y y=new Y(); public X()&#123; System.out.print(&quot;X&quot;); &#125; &#125; class Y&#123; public Y()&#123; System.out.print(&quot;Y&quot;); &#125; &#125; public class Z extends X&#123; Y y=new Y(); public Z()&#123; System.out.print(&quot;Z&quot;); &#125; public static void main(String[] args) &#123; new Z(); &#125; &#125; 初始化过程： 初始化父类中的静态成员变量和静态代码块 ； 初始化子类中的静态成员变量和静态代码块 ； 初始化父类的普通成员变量和代码块，再执行父类的构造方法； 初始化子类的普通成员变量和代码块，再执行子类的构造方法； （1）初始化父类的普通成员变量和代码块，执行 Y y=new Y(); 输出Y（2）再执行父类的构造方法；输出X（3）初始化子类的普通成员变量和代码块，执行 Y y=new Y(); 输出Y（4）再执行子类的构造方法；输出Z 所以输出YXYZ。 客户端要获取一个socket对象通过实例化，而服务器获得一个socket对象则通过什么方法的返回值? 答：getRemoteSocketAddress()。 public class Example&#123; String str=new String(&quot;good&quot;); char[]ch=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;; public static void main(String args[])&#123; Example ex=new Example(); ex.change(ex.str,ex.ch); System.out.print(ex.str+&quot; and &quot;); System.out.print(ex.ch); &#125; public void change(String str,char ch[])&#123; //引用类型变量，传递的是地址，属于引用传递。 str=&quot;test ok&quot;; ch[0]=&#39;g&#39;; &#125; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 1、java语言参数之间只有值传递，包括按值调用和按引用调用。 一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 按值调用：包括八大基本数据类型都是按值调用。传值的时候，也就是说方法得到的是所有参数值的一个拷贝。 按引用调用：数组、对象。传值时候，传递的是引用地址的拷贝，但是都是指向同一个对象。 2、String是不可变类（final and Immutable）,这里只是把副本的指向修改成指向“test ok”，原地址str的指向的值没有发生改变。 3、运行结果为：good and gbc。33. &gt; 运行时数据区包括：虚拟机栈区，堆区，方法区，本地方法栈，程序计数器 &gt; &gt;**虚拟机栈区**：也就是我们常说的栈区，**线程私有**，存放基本类型，对象的引用和returnAddress，在编译期间完成分配。 &gt; &gt;**堆区**，JAVA堆，也称GC堆，所有**线程共享**，存放对象的实例和数组，JAVA堆是垃圾收集器管理的主要区域。 &gt; &gt;**方法区**：所有**线程共享**，存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。这个区域的内存回收目标主要是针对常量池的对象的回收和对类型的卸载。 &gt; &gt;**程序计数器**：**线程私有**，每个线程都有自己独立的程序计数器，用来指示下一条指令的地址。34. Panel 和 Applet 的默认布局管理器是FlowLayout。35. &gt; 关于synchronized和volatile的比较: &gt; &gt;- 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且只能修改变量，而synchronized可以修饰方法，以及代码块。 &gt;- 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。 &gt;- volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。 &gt;- 关键字volatile解决的是变量在多线程之间的可见性；而synchronized解决的是多线程之间资源同步问题。36. finally语句块 - 不管catch是否捕获异常，finally语句块都是要被执行的 - 在try语句块或catch语句块中执行到System.exit(0)直接退出程序 - finally块中的return语句会覆盖try块中的return返回 - finally块中的内容会先于try中的return语句执行，如果finall语句块中也有return语句的话，那么直接从finally中返回了，但是不建议在finally中return。37. &gt; 类的复用有两种方式：组成(has-a)和继承(is-a) &gt; 1）组成就是在新的类中直接创建旧类的对象，这里我们复用的只是代码的功能而不是它的形式。 &gt; 2）继承是在原有的类的基础上建立一个新类，新类具有旧类的形式，但也加入了一些新的特性。 &gt; &gt; 继承：指一个新的类继承原有类的基本特性，并增加了新的特性。（Java不允许多继承，而C++可以） &gt; &gt; 多态性： 指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。 &gt; 1）多态存在的三个必要条件 &gt; ①要有继承 ②要有重写 ③父类引用指向子类对象（向上转型） &gt; 2）实现多态性的三种形式 &gt; ①方法的重载 ②通过继承机制而产生方法覆盖 ③通过接口实现方法覆盖 &gt; 3）多态的分类 &gt; 多态分为编译时多态和运行时多态。其中编译 时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编译之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们平常所说的多态性。 38. - Java中，赋值是有返回值的 ，赋什么值，就返回什么值。比如这题，x&#x3D;y，返回y的值，所以括号里的值是1。 - Java跟C的区别，C中赋值后会与0进行比较，如果大于0，就认为是true；而Java不会与0比较，而是直接把赋值后的结果放入括号。 39. &#96;&#96;&#96;java public class Test &#123; public static void changeStr(String str) &#123; str &#x3D; &quot;welcome&quot;; &#125; public static void main(String[] args) &#123; String str &#x3D; &quot;1234&quot;; changeStr(str); System.out.println(str); &#125; &#125; Java方法调用中，只存在值传递调用。 此处，实参str是引用变量，由于java方法调用是值传递，所以形参str得到的是实参str的一个拷贝。此时形参str和实参str均指向字符串&quot;1234&quot;。 然后，在changeStr方法中，形参str指向了一个新的字符串&quot;welcom&quot;，而后方法结束，形参str被销毁。而实参str仍然指向字符串&quot;1234&quot;。 jvm堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区）。 常量池属于 PermGen（方法区） 所有类的实例和数组都是在堆上分配内存的 对象所占的堆内存是由自动内存管理系统回收 堆内存由存活和死亡的对象,空闲碎片区组成 CopyOnWriteArrayList适用于写少读多的并发场景 ReadWriteLock即为读写锁，他要求写与写之间互斥，读与写之间互斥，读与读之间可以并发执行。在读多写少的情况下可以提高效率 ConcurrentHashMap是同步的HashMap，读写都加锁 volatile只保证多线程操作的可见性，不保证原子性 ConcurrentHashMap实际上时 HashTable的升级版，使用segment来分段和管理锁，并不是synchronized; HashMap实现的接口有：Serializable, Cloneable, Map&lt;K,V&gt; ,没有实现Collection; Arrays.asList()方法返回的列表是Arrays.ArrayList类型的，并不是java.util.ArrayList； SimpleDateFormat是线程不安全的 private修饰的东西，只是不能在别的类中访问，但是本类中还是可以的。同时利用反射也可以做到。 JUnit主要用来完成单元测试。 Log4j支持按分钟为间隔生成新的日志文件 Log4j是一个打印日志用的组件 Log4j支持按年为间隔生成新的日志文件 Log4j的日志打印级别不可以在运行时重新设置 日志的级别之间的大小关系：ALL&lt; TRACE&lt; DEBUG&lt; INFO&lt; WARN&lt; ERROR&lt; FATAL&lt; OFF。 Log4j建议只使用四个级别，优先级从高到低分别是 ERROR &gt; WARN &gt; INFO &gt; DEBUG。 在类方法中不能有this关键字，this指的是当前对象，类方法依附于类而不是对象，使用this会编译出错。 下面哪种情况会导致持久区jvm堆内存溢出？ 答：使用CGLib技术直接操作字节码运行，生成大量的动态类 在Struts框架中如果要使用Validation作验证的话，需要使用以下哪个Form？ 答：DynaValidatorActionForm 动态验证表单 内部类前面可以修饰public,protected和private 外部类只能用 public、abstract、final修饰 单例模式中，两个基本要点是 构造函数私有 唯一实例 常用的servlet包的名称： javax.servlet javax.servlet.http 数组： 数组是一个对象，不同类型的数组具有不同的类 数组是一个连续的存储结构 二星题 java.io.Serializable接口是一个标志性接口，在接口内部没有定义任何属性与方法。只是用于标志此接口的实现类可以被序列化与反序列化。 java.lang.Cloneable接口是一个标志性接口，在接口内部没有定义任何属性与方法。以指示Object.clone()方法可以合法地对该类实例进行按字段复制。 java.lang.CharSequence接口对许多不同种类的char序列提供统一的只读访问接口。CharSequence是char值的一个可读序列。 java.lang.Comparable接口，此接口强制对实现它的每个类的对象进行整体排序，此序列被称为该类的自然排序。 需要注意的是，super关键字只能指代直接父类，不能指代父类的父类。 基本数据类型都是以小写字母开头，引用数据类型则是以大写字母开头。 Java的Daemon线程，setDaemon( )设置必须要在start之前。 释放掉占据的内存空间是由gc完成，但是程序员无法明确强制其运行，该空间在不被引用的时候不一定会立即被释放，这取决于GC本身，无法由程序员通过代码控制。 静态内部类不可以直接访问外围类的非静态数据，而非静态内部类可以直接访问外围类的数据，包括私有数据。 spring spring是一个轻量级JAVA EE的框架集合 spring是“依赖注入”模式的实现 使用spring可以实现声明事务 转发重定向，转发的时候pageContent内的属性值不能被传递。 HashMap,TreeMap 未进行同步考虑，是线程不安全的。 HashTable 和 ConcurrentHashMap 都是线程安全的。区别在于他们对加锁的范围不同，HashTable 对整张Hash表进行加锁，而ConcurrentHashMap将Hash表分为16桶(segment)，每次只对需要的桶进行加锁。 Collections 类提供了synchronizedXxx()方法，可以将指定的集合包装成线程同步的集合。比如，List list = Collections.synchronizedList(new ArrayList());Set set = Collections.synchronizedSet(new HashSet()); 以下方法可以取到http请求中的cookie值： request.getHeader request.getCookies 同一个类的对象使用不同的内存段，但静态成员共享相同的内存空间。 使用super()或者this()方法是必须放在构造函数的第一行。 由于this函数指向的构造函数默认有super()方法，所以规定this()和super()不能同时出现在一个构造函数中。 因为staic方法或者语句块没有实例时可以使用，而此时不需要构造实例，所以不能用this()和super()。 普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。 1、List接口和Set接口都继承自Collection接口，Collection接口继承Iterable接口（Iterable有一个Iterator方法），即可迭代的；Collection只能存储引用类型，并且是单个存储；2、List接口存储元素特点：有序（存进去什么顺序取出来还什么顺序），可重复；Set接口存储元素特点：无序，不可重复3、实现List接口主要的类包括ArrayList，LinkedList，Vector；实现Set的主要类包括：hashSet，另外还有一个TreeSet接口继承它（自动排序）4、Map接口以键值对方式存储元素，键无序不可重复，Map和Collection没有任何关系 一个完整的URL地址由协议，主机名，端口和文件四部分组成。 泛型只在编译的时候保证数据类型的正确性，和运行期间的性能无关。 用new创建的对象在堆区 函数中的临时变量在栈去 java中的字符串在字符串常量区 HashMap不能保证元素的顺序,HashMap能够将键设为null，也可以将值设为null Hashtable不能将键和值设为null，否则运行时会报空指针异常错误 HashMap线程不安全，Hashtable线程安全 对于集合的三种遍历方式删除：1.普通for循环：可以删除 注意每次删除之后索引要-- 2.Iterator遍历：可以删除 不过要使用Iterator类中的remove方法，如果用List中的remove方法会报错 3.增强for循环foreach：不能删除 强制用List中的remove方法会报错 Java在序列化时不会实例化static变量和transient修饰的变量，因为static代表类的成员，transient代表对象的临时数据，被声明这两种类型的数据成员不能被序列化。 序列化的是对象，不是类，类变量不会被序列化。 Math.floor(x) 返回小于等于x的最接近整数，类型为double。 final修饰变量，变量的引用（也就是指向的地址）不可变，但是引用的内容可以变（地址中的内容可变）。 finalize方法，一个对象只能执行一次，只能在第一次进入被回收的队列，而且对象所属于的类重写了finalize方法才会被执行。第二次进入回收队列的时候，不会再执行其finalize方法，而是直接被二次标记，在下一次GC的时候被GC。 下列操作会使线程释放锁资源： wait() join()—–&gt;join()底层就是调用wait()方法的，wait()释放锁资源，故join也释放锁资源。 synchronized：用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这个段代码。 volatile：用来确保将变量的跟新操作通知到其他线程，当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。然而，在访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量是一种比 synchronized关键字更轻量级的同步机制。 serialize：Java 对象序列化为二进制文件。 在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。但是，反射最大程度破坏了面向对象的封装特性。 面向对象设计方法主要特征的是继承。 java采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。 jdbc的事务必须在一个数据库连接上完成。编程时必须去掉数据库的自动提交功能。当成功后调用commit，当失败后调用rollback。 单目运算符：+（正号），-（负号），++，–算数运算符：+，-，*，/，%移位运算符：&lt;&lt;,&gt;&gt;关系运算符：&gt;,&lt;,&gt;=,&lt;=,==,!=位运算符：&amp;，|，~，^,逻辑运算符：&amp;&amp;，||三目运算符：表达式1？表达式2：表达式3;赋值运算符：= 命令javac-d参数的用途是：指定编译后类层次的根目录 常用ASCII码值：空格为32；数字0为48；“A”为65；“a”值为97。 Java文件与Bean所定义的类名可以不同，但一定要注意区分字母的大小写。 虚拟机中没有泛型，只有普通类和普通方法 所有泛型类的类型参数在编译时都会被擦除 创建泛型对象时请指明类型，让编译器尽早的做参数检查 ArrayList的构造函数总共有三个：（1）ArrayList()构造一个初始容量为 10 的空列表。这种是默认创建大小为10的数组，每次扩容大小为1.5倍。 （2）ArrayList(Collection&lt;? extends E&gt; c)构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。（3）ArrayList(int initialCapacity)构造一个具有指定初始容量的空列表。这种是指定数组大小的创建，没有扩充。 计算余弦值使用Math类的cos()方法 toRadians()是将角度转换为弧度 toDegrees()是将弧度转换为角度 包装类是针对基本数据类型的。 Collection是java.util下的接口，它是各种集合结构的父接口 Collections是java.util下的类，它包含有各种有关集合操作的静态方法 线程局部存储TLS(thread local storage) 解决多线程中的对同一变量的访问冲突的一种技术 TLS会为每一个线程维护一个和该线程绑定的变量的副本 Java平台的java.lang.ThreadLocal是TLS技术的一种实现 一个线程调用yield方法，可以使具有相同优先级线程获得处理器 在Java中，高优先级的可运行的线程会抢占低优先级线程的资源 sleep与yield的其中一个区别：sleep给其他Thread运行不考虑优先级，而yield只给同等优先级或更高优先级运行。 三星题 ArrayList是基于数组实现的，所以查询快，增删慢；LinkedList是基于链表实现的，所以查找慢，增删快。 AOP和OOP都是一套方法论，也可以说成设计模式、思维方式、理论规则等等。AOP不能替代OOP，OOP是obejct abstraction，而AOP是concern abstraction，前者主要是对对象的抽象，诸如抽象出某类业务对象的公用接口、报表业务对象的逻辑封装，更注重于某些共同对象共有行为的抽象，如报表模块中专门需要报表业务逻辑的封装，其他模块中需要其他的逻辑抽象，而AOP则是对分散在各个模块中的共同行为的抽象，即关注点抽象。一些系统级的问题或者思考起来总与业务无关又多处存在的功能，可使用AOP，如异常信息处理机制统一将自定义的异常信息写入响应流进而到前台展示、行为日志记录用户操作过的方法等，这些东西用OOP来做，就是一个良好的接口、各处调用，但有时候会发现太多模块调用的逻辑大都一致、并且与核心业务无大关系，可以独立开来，让处理核心业务的人专注于核心业务的处理，关注分离了，自然代码更独立、更易调试分析、更具好维护。核心业务还是要OOP来发挥作用，与AOP的侧重点不一样，前者有种纵向抽象的感觉，后者则是横向抽象的感觉，AOP只是OOP的补充，无替代关系。 同步是害怕在操作过程的时候被其他线程也进行读取操作，一旦是原子性的操作就不会发生这种情况。因为一步到位的操作，其他线程不可能在中间干涉。另外三项都有读取、操作两个步骤，而X=1则是原子性操作。 public class Test &#123; public static void main(String[] args) &#123; System.out.println(args[0]); &#125; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225 若采用命令行“java Test one two three”调用，则程序输出的结果为： one 解析：采用命令行“ java Test one two three ”调用，其中Test为调用的方法，而one two three则为Test方法里面main函数的参数。System.out.println(args[0]);表示输出第一个元素，故为one。5. 管道( pipe )：管道是一种**半双工**的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。 6. CGI不可移植，为某一特定平台编写的CGI应用只能运行于这一环境中。每一个CGI应用存在于一个由客户端请求激活的进程中，并且在请求被服务后被卸载。这种模式将引起很高的内存、CPU开销，而且在同一进程中不能服务多个客户。 7. volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性。8. 进入DEAD的线程，它还可以恢复，GC不会回收。9. DBMS 中实现事务持久性的子系统是**恢复管理子系统**。10. Java.Thread的方法resume()负责重新开始被suspend方法中断的线程的执行。11. - HashMap实现了Map接口的，它的Key和Value都可以是null，但是Hashtable种，Key和Value都不能是null。 - ArrayList与LinkedList都实现了List接口，继承了AbstractList类。12. 在**函数代码小，频繁调用**情况下适宜采用内联函数。13. &gt; - Java 中单实现通过 implements 关键字，多实现通过 extends 关键字 &gt; - Java 中单继承通过 extends 关键字，没有多继承 &gt; - 如果同时出现继承和实现，则必须先继承（extends）再实现（implements）14. try的形式有三种： - try-catch - try-finally - try-catch-finally 但catch和finally语句不能同时省略！ 15. &gt; 一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 &gt; 但某些情况下，这个类的有些属性需要序列化，而其他属性不需要被序列化，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。16. 饿汉式单例模式，在类创建时，就已经实例化完成，在调用getInstance()时，直接获取静态对象。obj1和obj2其实是一个对象,应该返回true。17. - java中的字符串存储在字符串常量区，不会改变，发生改变是会新创建一个对象 - StringBuffer是线程安全的StringBuilder - StringBuilder跟StringBuffer功能相同，区别是StringBuilder不是线程安全 - StringBuilder和StringBuffer底层都是以字符数组存放的，可以修改内容 18. J2EE中，当把来自客户机的HTTP请求委托给servlet时，会调用HttpServlet的**service**方法。19. HttpServletResponse完成：设置http头标，设置cookie，设置返回数据类型，输出返回数据； 读取路径信息是HttpServletRequest做的。20. - forward，服务器获取跳转页面内容传给用户，用户地址栏不变 - redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址21. ThreadLocalMap中使用开放地址法来处理散列冲突，而HashMap中使用的是分离链表法。之所以采用不同的方式主要是因为：在ThreadLocalMap中的散列值分散得十分均匀，很少会出现冲突。并且ThreadLocalMap经常需要清除无用的对象，使用纯数组更加方便。22. 父类没有**无参**的构造函数，所以子类需要在自己的构造函数中显式调用父类的构造函数。23. - ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。 - 对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。 - 对于新增和删除操作add和remove，LinkedList比较占优势，因为ArrayList要移动数据。 - ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间。24. - java不允许单独的方法，过程或函数存在,需要隶属于某一类中。 - Java的静态方法属于类的成员，实例方法属于对象的成员。25. - 静态方法不能访问非静态变量 - 抽象类中的抽象方法不能有方法体 - 一个类中有多个类声明时，只能有一个public类26. 一般用(System.in)创建InputStream对象,表示从标准输入中获取数据,用(System.out)创建OutputStream对象，表示输出到标准输出设备中。27. &gt; length 返回当前长度 &gt; 如果字符串长度没有初始化长度大，capacity返回初始化的长度 &gt; 如果append后的字符串长度超过初始化长度，capacity返回增长后的长度 &gt; PS: &gt; StringBuffer和StringBuilder的默认大小为16 &gt; ArrayList和LinkedList的默认大小10 28. 关于 Socket 通信编程， - 服务器端通过new ServerSocket()创建TCP连接对象 - 服务器端通过TCP连接对象调用accept()方法创建通信的Socket对象 - 客户端通过new Socket()方法创建通信的Socket对象29. JSP分页代码中，先取总记录数，得到总页数，最后显示本页的数据。30. java在运行时才进行翻译指令。31. 使用ObjectOutputStream和ObjectInputStream可以将对象进行传输。## 四星题1. 对于&quot;&#x3D;&#x3D;&quot;： - 用于基本数据类型相互比较，比较二者的值是否相等。 - 用于引用数据类型相互比较，比较二者地址是否相等。 - 不能用于基本数据类型与引用型比较。 对于&quot;equals&quot;： - 不能用于基本数据类型比较(因为这是一个方法, 继承自object)。 - 用于进行对象的比较, 比较二者的引用地址是否相同。2. 适配器模式 ，屏蔽远程对象，通过适配器模拟本地对象，本地对象称之为存根。与动态链接技术有关。3. ThreadLocalMap使用开放定址法解决hash冲突，HashMap使用链地址法解决hash冲突。4. 没有final修饰的变量相加后会被自动提升为int型，与目标类型byte不相容，需要强制转换（向下转型）。 5. 关于OutOfMemoryError， &gt; - java.lang.OutOfMemoryError: PermGen space 增加-XX:MaxPermSize这个参数的值的话，这个问题通常会得到解决。 &gt; - java.lang.OutOfMemoryError: Requested array size exceeds VM limit当你正准备创建一个超过虚拟机允许的大小的数组时，这条错误将会出现。 &gt; - java.lang.OutOfMemoryError: Java heap space 一般情况下解决这个问题最快的方法就是通过-Xmx参数来增加堆的大小。6. JDK提供的用于并发编程的同步器： - Semaphore - CyclicBarrier - CountDownLatch7. &gt; Java语言中的异常处理包括声明异常、抛出异常、捕获异常和处理异常四个环节。 &gt; &gt; - throw用于抛出异常。 &gt; - throws关键字可以在方法上声明该方法要抛出的异常，然后在方法内部通过throw抛出异常对象。 &gt; - try是用于检测被包住的语句块是否出现异常，如果有异常，则抛出异常，并执行catch语句。 &gt; - cacth用于捕获从try中抛出的异常并作出处理。 &gt; - finally语句块是不管有没有出现异常都要执行的内容。 8. - run()方法用来执行线程体中具体的内容 - start()方法用来启动线程对象，使其进入就绪状态 - sleep()方法用来使线程进入睡眠状态 - suspend()方法用来使线程挂起，要通过resume()方法使其重新启动 9. - Semaphore：类，控制某个资源可被同时访问的个数; - ReentrantLock：类，具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大； - Future：接口，表示异步计算的结果； - CountDownLatch： 类，可以用来在一个线程中等待多个线程完成任务的类。10. Hibernate 中 get()和load() 的区别： - get()采用立即加载方式,而load()采用延迟加载; get()方法执行的时候,会立即向数据库发出查询语句, 而load()方法返回的是一个代理(此代理中只有一个id属性),只有等真正使用该对象属性的时候,才会发出 sql语句 - 如果数据库中没有对应的记录,get()方法返回的是null。而load()方法出现异常ObjectNotFoundException 11. hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。 那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠， 所以我们可以得出： - equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。 - hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的12. SimpleDateFormat是线程不安全的。13. 在java中，我们可以用异常（Exception）来抛出一些并非错误的消息，但这样比直接从函数返回一个结果要更大的系统开销。14. java用（监视器）机制实现了进程之间的同步执行。15. jre 判断程序是否执行结束的标准是**所有的前台线程执行完毕**。16. 我们在执行&#96;URL u &#x3D;new URL(&quot;http:&#x2F;&#x2F;www.123.com&quot;);&#96;这句话的时候确实要抛出异常，但是这个异常属于IOException，不管网址是否存在，最后都会返回该网址的一个链接，打印出来就是该网址。17. 关于JSP生命周期的叙述， - JSP会先解释成Servlet源文件，然后编译成Servlet类文件 - 每当用户端运行JSP时，jsp service()方法都会运行一次18. 有关java的引用类型， - 对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中 - 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收 - 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存 - 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间## 五星题1. 一般关系数据模型和对象数据模型之间有以下对应关系：表对应类，记录对应对象，表的字段对应类的属性。2. 实现GBK编码字节流到UTF-8编码字节流的转换： dst&#x3D;new String(src，&quot;GBK&quot;).getBytes(&quot;UTF-8&quot;);3. 对于线程而言，start是让线程从new变成runnable。run方法才是执行体的入口。 但是在Thread中，run方法是个空方法，没有具体实现。 Bground(新类)继承了Thread，但是没有重写run方法，那么调用run方法肯定是无输出。4. Java数据库连接库JDBC用到**桥接模式** 。5. &gt; SpringMVC的原理： &gt; SpringMVC是Spring中的模块，它实现了mvc设计模式的web框架，首先用户发出请求，请求到达SpringMVC的前端控制器（DispatcherServlet）,前端控制器根据用户的url请求处理器映射器查找匹配该url的handler，并返回一个执行链，前端控制器再请求处理器适配器调用相应的handler进行处理并返回给前端控制器一个modelAndView，前端控制器再请求视图解析器对返回的逻辑视图进行解析，最后前端控制器将返回的视图进行渲染并把数据装入到request域，返回给用户。 &gt; DispatcherServlet作为springMVC的前端控制器，负责接收用户的请求并根据用户的请求返回相应的视图给用户。 &gt; 实现业务操作时在service层。6. 一个 try 块可能有多个 catch 块。若如此，则执行第一个匹配块。即Java虚拟机会把实际抛出的异常对象依次和各个catch代码块声明的异常类型匹配，如果异常对象为某个异常类型或 其子类的实例，就执行这个catch代码块，不会再执行其他的 catch代码块 。7. 鲁棒性(Robust,即健壮性) Java在编译和运行程序时，都要对可能出现的问题进行检查，以消除错误的产生。它提供自动垃圾收集来进行内存管理，防止程序员在管理内存时容易产生 的错误。通过集成的面向对象的例外处理机制，在编译时，Java揭示出可能出现但未被处理的例外，帮助程序员正确地进行选择以防止系统的崩溃。另外， Java在编译时还可捕获类型声明中的许多常见错误，防止动态运行时不匹配问题的出现。 8. &#96;&#96;&#96;java public class Base &#123; private String baseName &#x3D; &quot;base&quot;; public Base() &#123; callName(); &#125; public void callName() &#123; System. out. println(baseName); &#125; static class Sub extends Base &#123; private String baseName &#x3D; &quot;sub&quot;; public void callName() &#123; System. out. println (baseName) ; &#125; &#125; public static void main(String[] args) &#123; Base b &#x3D; new Sub(); &#125; &#125; new Sub();在创造派生类的过程中首先创建基类对象，然后才能创建派生类。 创建基类即默认调用Base()方法，在方法中调用callName()方法，由于派生类中存在此方法，则被调用的callName（）方法是派生类中的方法，此时派生类还未构造，所以变量baseName的值为null。 最终结果为：null JVM内存区：程序计数器、虚拟机栈、本地方法栈、堆、方法区（包括常量池）。 我们可以直接调用Thread对象中的run方法，但就起不到多线程的目的了。 ThreadLocal用于创建线程的本地变量，该变量是线程之间不共享的 Java中字节流的流对象： FileInputStream BufferedInputStream PushbackInputStream ByteArrayInputStream LinkedBlockingQueue是一个基于节点链接的可选是否有界的阻塞队列，不允许null值。 LinkedBlockingQueue是一个线程安全的阻塞队列，实现了先进先出等特性。 PriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）。 PriorityQueue是不同于先进先出队列的另一种队列。每次从队列中取出的是具有最高优先权的元素。ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，该队列的元素遵循FIFO原则。 Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 程序运行时异常由Java虚拟机自动进行处理。 依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁。 依赖注入能够独立开发各组件，然后根据组件间关系进行组装 依赖注入提供使用接口编程 依赖注入指对象在使用时动态注入 有一个源代码，只包含import java.util.* ; 这一个import语句，能访问java/util目录下的所有类，不能访问java/util子目录下的所有类。 在有除法存在的代码处，抛不抛出异常均可。 一般而言，PreparedStatement比Statement执行效率更高 PreparedStatement会预编译SQL语句 Statement每次都会解析/编译SQL，确立并优化数据获取路径 weblogic中开发消息Bean时的persistent与non-persisten的差别： persistent方式的MDB可以保证消息传递的可靠性,也就是如果EJB容器出现问题而JMS服务器依然会将消息在此MDB可用的时候发送过来。 non－persistent方式的消息将被丢弃。 Iterator支持从源集合中安全地删除对象，只需在 Iterator 上调用 remove() 即可。 由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。 使用匿名内部类时，必须继承一个类或实现一个接口 匿名内部类由于没有名字，因此不能定义构造函数 匿名内部类中不能含有静态成员变量和静态方法 Object类的部分方法： notify() notifyAll() wait() PS： 不是恶意诽谤牛客网，实在是题目质量得不到保证。有的题目错，有的答案错，甚至你在刷Java题目时动不动就来个C语言的题目，很是让人无语。牛客网的题目似乎是用户传上去的，只丢个答案在那里，没有官方解答，题目下方评论区的确有大神做解答，但鱼龙混杂，也有辣鸡在装X的（随意粘贴别处的知识点，最可恶的是解答是错的，这种人是真的恶心）。一星题与五星题的区别并不是你想的那样，仅仅是多选题数量的增多而已，估计这也是安卓端无法进行题目筛选的原因，因为根本没用。还有，强烈建议牛客网将Java题库中的Swing、AWT有关的题目去除，现在还有鬼在用这个东西啊？至于题目涉及的范围倒还好，都是基础知识，建议多加一些框架相关的题目，毕竟现在的开发都是会用到框架的。 刷了3天的题库，400多道题，刷完立刻看解析，边刷题边写笔记。然而并没有什么卵用，考试题全是Spring，一脸懵逼，蓝瘦、香菇。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"chenhy"},{"title":"【DB2】DB2基础_表空间和缓冲池","slug":"【DB2】DB2基础-表空间和缓冲池","date":"2021-05-13T12:43:06.000Z","updated":"2021-05-13T12:43:56.683Z","comments":true,"path":"2021/05/13/【DB2】DB2基础-表空间和缓冲池/","link":"","permalink":"https://born2do.github.io/2021/05/13/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%BC%93%E5%86%B2%E6%B1%A0/","excerpt":"","text":"简介对于刚涉足 DB2 领域的 DBA 或未来的 DBA 而言，新数据库的设计和性能选择可能会很令人困惑。在本文中，我们将讨论 DBA 要做出重要选择的两个方面：表空间和缓冲池。表空间和缓冲池的设计和调优会对 DB2 服务器的性能产生深远的影响，因此我们将着重讨论这些活动。 在我们的示例中，我们将使用 DB2 V8.1 企业服务器版。大多数示例也适用于低级版本。我们会让您知道某个示例是否只适用于 V8.1。 在 第 1 节中，我们将从定义表空间的类型开始，并将说明 DB2 如何将数据存储在表空间中。我们将介绍配置选项并向您介绍创建和管理表空间的整个过程。接下来，我们将着重讨论 缓冲池，介绍缓冲池是什么以及如何创建和使用它。在 第 2 节中，我们将结合这两个方面并讨论该如何组织缓冲池和表空间才能获得最佳性能。 第 1 节：定义表空间数据库中的所有数据都存储在许多表空间中。可以认为表空间是孩子而数据库是其父母，其中表空间（孩子）不能有多个数据库（父母）。由于表空间有不同用途，因此根据它们的用途和管理方式将它们分类。根据用途有五种不同的表空间： 目录表空间 每个数据库只有一个目录表空间，它是在发出 CREATE DATABASE 命令时创建的。目录表空间被 DB2 命名为 SYSCATSPACE，它保存了系统目录表。总是在创建数据库时创建该表空间。 常规表空间 常规表空间保存表数据和索引。它还可以保存诸如大对象（Large Object，LOB）之类的长数据，除非这些数据显式地存储在长表空间中。如果某些表空间是数据库管理的空间（Database Managed Space，DMS），则可以将表及其索引分别放到单独的常规表空间中。我们将在本文后面定义 DMS 和系统管理的空间（System Managed Space，SMS）之间的区别。每个数据库中必须至少有一个常规表空间。创建数据库时指定该表空间的缺省名为 USERSPACE1。 长表空间 长表空间用于存储长型或 LOB 表列，它们必须驻留在 DMS 表空间中。它们还可以存储结构化类型的列或索引数据。如果没有定义长表空间，那么将把 LOB 存储在常规表空间中。长表空间是可选的，缺省情况下一个都不创建。 系统临时表空间 系统临时表空间用于存储 SQL 操作（比如排序、重组表、创建索引和连接表）期间所需的内部临时数据。每个数据库必须至少有一个系统临时表空间。随数据库创建的系统临时表空间的缺省名为 TEMPSPACE1。 用户临时表空间 用户临时表空间存储已声明的全局临时表。创建数据库时不存在用户临时表空间。至少应当创建一个用户临时表空间以允许定义已声明的临时表。用户临时表空间是可选的，缺省情况下一个都不创建。 表空间管理可以用两种不同的方式管理表空间： 系统管理的空间（SMS） SMS 表空间由操作系统进行管理。容器被定义成常规操作系统文件，并且是通过操作系统调用访问的。这意味着所有的常规操作系统功能将处理以下内容：操作系统将缓冲 I/O；根据操作系统约定分配空间；如有必要就自动扩展表空间。但是，不能从 SMS 表空间删除容器，并且仅限于将新的容器添加到分区的数据库。前一节中所说明的那三个缺省表空间都是 SMS。 数据库管理的空间（DMS） DMS 表空间是由 DB2 管理的。可以将容器定义成文件（在创建表空间时将把给定的大小全部分配给它们）或设备。分配方法和操作系统允许多少 I/O，DB2 就可以管理多少 I/O。可以通过使用 altER TABLESPACE 命令来扩展容器。还可以释放未使用的那部分 DMS 容器（从 V8 开始）。 下面是一个示例，向您说明该如何增大容器大小（V7 和 V8 都支持此功能）： 1ALTER TABLESPACE TS1 RESIZE (FILE &#x27;/conts/cont0&#x27; 2000, DEVICE &#x27;/dev/rcont1&#x27; 2000, FILE &#x27;cont2&#x27; 2000) 请注意，只有 V8 才支持将原始容器的大小调整得更小。 如何创建和查看表空间当您创建数据库时，将创建三个表空间（SYSCATSPACE、TEMPSPACE1 和 USERSPACE1）。通过使用 DB2 命令窗口（Command Window）或 UNIX 命令行，创建一个名为 testdb 的数据库，连接至该数据库，然后列出表空间： 1CREATE DATABASE testdb CONNECT TO testdb LIST TABLESPACES 下面的 清单 1显示了 LIST TABLESPACES 命令的输出。 清单 1. LIST TABLESPACES 命令的输出 1Tablespaces for Current Database Tablespace ID &#x3D; 0 Name &#x3D; SYSCATSPACE Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 1 Name &#x3D; TEMPSPACE1 Type &#x3D; System managed space Contents &#x3D; System Temporary data State &#x3D; 0x0000 Detailed explanation: Normal Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal 上面所示的这三个表空间是通过 CREATE DATABASE 命令自动创建的。用户可以通过在该命令中包含表空间说明来覆盖缺省的表空间创建，但是在创建数据库时必须创建一个目录表空间和至少一个常规表空间，以及至少一个系统临时表空间。通过使用 CREATE DATABASE 命令或以后使用 CREATE TABLESPACE 命令，可以创建更多的所有类型的表空间（目录表空间除外）。 容器每个表空间都有一个或多个容器。重申一次，您可以认为容器是孩子，而表空间是其父母。每个容器只能属于一个表空间，但是一个表空间可以拥有许多容器。可以将容器添加到 DMS 表空间，或者从 DMS 表空间中删除容器，而且可以更改容器的大小。只能将容器添加到某个分区中分区数据库上的 SMS 表空间，在添加之前该分区还未给表空间分配容器。添加新的容器时，将启动一个自动的重新均衡操作以便将数据分布到所有容器上。重新均衡操作不会妨碍对数据库的并发访问。 表空间设置可以在创建表空间时给它们指定许多设置，或者也可以稍后使用 altER TABLESPACE 语句时指定其设置。 页大小（Page size） 定义表空间所使用的页大小。所支持的大小为 4K、8K、16K 和 32K。页大小根据下表限定了可放到表空间中的表的行长度和列数： 表 1. 页大小的含义 页大小 行大小 限制列数 限制最大容量 4 KB 4 005 500 64 GB 8 KB 8 101 1 012 128 GB 16 KB 16 293 1 012 256 GB 32 KB 32 677 1 012 512 GB 表空间最多可包含 16384 个页，因此选择较大的页大小可以增加表空间的容量。 扩展块大小（Extent size） 指定在跳到下一个容器之前将写到当前容器中的页数。存储数据时数据库管理器反复循环使用所有容器。该参数只有在表空间中有多个容器时才起作用。 预取大小（Prefetch size） 指定当执行数据预取时将从表空间读取的页数。预取操作在查询引用所需的数据之前读入这些数据，这样一来查询就不必等待执行 I/O 了。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，它就选择预取操作。 开销（Overhead）和传送速率（Transfer rate） 这些值用于确定查询优化期间的 I/O 成本。这两个值的测量单位都是毫秒，而且它们应当分别是所有容器开销和传送速率的平均值。开销是与 I/O 控制器活动、磁盘寻道时间和旋转延迟时间相关联的时间。传送速率是将一个页读入内存所必需的时间量。它们的缺省值分别是 24.1 和 0.9。可以根据硬件规格计算这些值。 CREATE TABLESPACE 语句的示例下列语句将创建一个常规表空间。所讨论的所有设置都是为了进行说明。 1CREATE TABLESPACE USERSPACE3 PAGESIZE 8K MANAGED BY SYSTEM USING (&#x27;d:\\\\usp3_cont1&#x27;, &#x27;e:\\\\usp3_cont2&#x27;, &#x27;f:\\\\usp3_cont3&#x27;) EXTENTSIZE 64 PREFETCHSIZE 32 BUFFERPOOL BP3 OVERHEAD 24.1 TRANSFERRATE 0.9 如何查看表空间的属性和容器指定 LIST TABLESPACES 命令的 SHOW DETAIL 选项将显示其它信息： 1LIST TABLESPACES SHOW DETAIL 清单 2显示了 USERSPACE1 表空间的输出。缺省情况下，将列出创建数据库时所创建的那三个表空间。 清单 2. LlST TABLESPACES SHOW DETAIL 命令的输出 1Tablespaces for Current Database Tablespace ID &#x3D; 2 Name &#x3D; USERSPACE1 Type &#x3D; System managed space Contents &#x3D; Any data State &#x3D; 0x0000 Detailed explanation: Normal Total pages &#x3D; 336 Useable pages &#x3D; 336 Used pages &#x3D; 336 Free pages &#x3D; Not applicable High water mark (pages) &#x3D; Not applicable Page size (bytes) &#x3D; 4096 Extent size (pages) &#x3D; 32 Prefetch size (pages) &#x3D; 16 Number of containers &#x3D; 1 要列出容器，我们需要使用以上输出中的 Tablespace ID： 1LIST TABLESPACE CONTAINERS FOR 2 清单 3. LIST TABLESPACE CONTAINERS 命令的输出 1Tablespace Containers for Tablespace 2 Container ID &#x3D; 0 Name &#x3D; C:\\\\DB2\\\\NODE0000\\\\SQL00004\\\\SQLT0002.0 Type &#x3D; Path 该命令将列出指定表空间中的所有容器。如上所示的路径指向容器物理上所在的位置。 缓冲池一个缓冲池是与单个数据库相关联的，可以被多个表空间使用。当考虑将缓冲池用于一个或多个表空间时，必须保证表空间页大小和缓冲池页大小对于缓冲池所“服务”的所有表空间而言都是一样的。一个表空间只能使用一个缓冲池。 创建数据库时，会创建一个名为 IBMDEFAULTBP 的缺省缓冲池，所有的表空间都共享该缓冲池。可以使用 CREATE BUFFERPOOL 语句添加更多的缓冲池。缓冲池的缺省大小是 BUFFPAGE 数据库配置参数所指定的大小，但是可以通过在 CREATE BUFFERPOOL 命令中指定 SIZE 关键字来覆盖该缺省值。足够的缓冲池大小是数据库拥有良好性能的关键所在，因为它可以减少磁盘 I/O 这一最耗时的操作。大型缓冲池还会对查询优化产生影响，因为更多的工作可在内存中完成。 基于块的缓冲池V8 允许您留出缓冲池的一部分（最高可达 98%）用于基于块的预取操作。基于块的 I/O 可以通过将块读入相邻的内存区而不是将它分散装入单独的页，来提高预取操作的效率。每个缓冲池的块大小必须相同，并且由 BLOCKSIZE 参数进行控制。该值等于块的大小（单位为页），从 2 到 256，缺省值为 32。 扩展存储器DB2 不将扩展存储器用于缓冲区。但是，可以用扩展存储器来高速缓存内存页，使得从内存移出页变得更快。 CREATE BUFFERPOOL 语句的示例下面是 CREATE BUFFERPOOL 语句的一个示例： 1CREATE BUFFERPOOL BP3 SIZE 2000 PAGESIZE 8K 该缓冲池被分配给上面的 CREATE TABLESPACE 示例上的 USERSPACE3，并且在创建表空间之前创建该缓冲池。请注意，缓冲池和表空间的页大小都是 8K，两者是相同的。如果您在创建缓冲池之后创建表空间，则可以省去 CREATE TABLESPACE 语句中的 BUFFER POOL BP3 语法。相反，可以使用 altER TABLESPACE 命令将缓冲池添加到现有的表空间： 1ALTER TABLESPACE USERSPACE3 BUFFERPOOL BP3 如何查看缓冲池属性通过查询 SYSCAT.BUFFERPOOLS 系统视图可以列出缓冲池信息： 1SELECT * FROM SYSCAT.BUFFERPOOLS BPNAME BUFFERPOOLID NGNAME NPAGES PAGESIZE ES ------------------ ------------ ------------------ ----------- ----------- -- IBMDEFAULTBP 1 - 250 4096 N 1 record(s) selected. 要找出哪个缓冲池被分配给了表空间，请运行下面这个查询： 1SELECT TBSPACE, BUFFERPOOLID FROM SYSCAT.TABLESPACES TBSPACE BUFFERPOOLID ------------------ ------------ SYSCATSPACE 1 TEMPSPACE1 1 USERSPACE1 1 3 record(s) selected. 可以在上一个查询中找到 BUFFERPOOLID，该查询使您能够看到每个表空间与哪个缓冲池相关联。 数据库如何保存表空间的可视化图表既然我们已经描述了表空间和缓冲池是什么以及如何创建它们，那么就让我们研究一下有关如何在数据库中将它们直观地组织起来的示例。 图 1. 表空间和缓冲池 该数据库有 5 个表空间：一个目录表空间、两个常规表空间、一个长表空间和一个系统临时表空间。没有创建用户临时表空间。另外有 8 个容器。 在这个方案中，缓冲池可能如下分配：将 BP1（4K）分配给 SYSCATSPACE 和 USERSPACE2将 BP2（8K）分配给 USERSPACE1将 BP3（32K）分配给 LARGESPACE 和 SYSTEMP1 第 2 节：性能含义一般而言，在物理设备上设计如何放置表空间和容器时，目标是使 I/O 并行性和缓冲区利用率达到最优。要实现这个目标，应当全面了解数据库设计和应用程序。只有这样您才能确定类似于下面这样的问题：将两张表分隔到不同的设备会不会产生并行 I/O，或者，是否应当在单独的表空间中创建表以便可以对它进行完全缓冲。 设计新数据库的物理布局应当从设计表空间的组织开始： 第一步是确定表设计所给出的约束。这些可能会导致必须使用多个常规表空间。 第二步是考虑如果让表空间中的表具有不同的设置，是否有可能显著提高性能。 一旦作出了一个试验性的表空间设计，那么就必须考虑缓冲池的利用率。这可能会使前面的表空间设计产生一些变化。 最后，必须给表空间分配容器。 这个是一个有反复的过程，应该通过压力测试和基准测试验证该设计。很显然，实现最佳的设计可能需要花费大量精力，并且仅当数据库性能必须可能是最佳时才能证明设计是最佳的。通常： 从最简单的可行设计入手。 只有根据测试证明有充分的性能理由时才增加复杂性。 通常，为了降低管理和保持一个较为简单的数据库设计的复杂性，稍微降低一点性能是值得的。DB2 具有一种非常成熟的资源管理逻辑，往往不用进行精心的设计就能产生非常好的性能。 表空间组织通常应该将目录表空间和系统临时表空间作为 SMS 分配。没有必要拥有多个具有相同页大小的临时表空间，通常只需一个具有最大页大小的临时表空间就够了。 突出的问题在于是否要将用户数据分割到多个表空间中。一个考虑因素是页的利用率。不能将行分割到不同的页，因此具有长行的表需要有合适的页大小。但是，一个页上的行不能超过 255 个，因此具有较短行的表不能利用整个页。例如，在页大小为 32K 的表空间中放置行长度为 12 字节的表，它大约只能利用每个页的 10%（即，（255 行 * 12 字节 + 91 字节的开销） / 32k 页大小 = ~10%）。 如果表很大，这只是一个考虑因素，因此浪费的空间就非常大。它还会使 I/O 和缓存的效率降低，因为每个页的实际有用内容很少。如果可以将表放到具有较小页的表空间中，以及可以充分利用较大的页大小，那么最常用的访问方法将确定哪一个更好。如果通常是顺序访问大量行（该表可能进行了群集），那么比较大的页大小会比较有效。如果随机访问行，那么较小的页大小可以允许 DB2 更好地利用缓冲区，因为同样的存储区域可以容纳更多页。 一旦根据页大小对表进行了分组，那么访问频率和类型将确定把数据进一步分组到独立的表空间中是否有意义。每张表根据自己被最频繁访问的方式，可以具有一组最有效的表空间设置：PAGESIZE、EXTENTSIZE 和 PREFETCHSIZE。上面已介绍了 PAGESIZE。EXTENTSIZE 是在将数据写入到下一个容器之前写入到当前容器中的数据的页数（如果表空间中存在多个容器的话）。 PREFETCHSIZE 指定在执行数据预取时将从表空间读取的页数。当数据库管理器确定顺序 I/O 是适当的，并且确定预取操作可能有助于提高性能时，会使用预取操作（通常是大型表扫描）。比较好的做法是将 PREFETCHSIZE 值显式地设置成表空间的 EXTENTSIZE 值与表空间容器数的乘积的倍数。例如，如果 EXTENTSIZE 是 32，并且表空间中有 4 个容器，那么理想的 PREFETCHSIZE 应当是 128、256 等等。如果一个或多个频繁使用的表需要的这组参数的值不同于那些最适用于表空间其它表的性能的参数值，那么将这些表放入单独的表空间可能会提高整体性能。 如果预取操作是表空间中的重要因素，那么请考虑留出一部分缓冲区用于基于块的 I/O。块大小应当等于 PREFETCHSIZE。 缓冲池的利用率使用多个用户表空间的最重要原因是管理缓冲区的利用率。一个表空间只能与一个缓冲池相关联，而一个缓冲池可用于多个表空间。 缓冲池调优的目标是帮助 DB2 尽可能好地利用可用于缓冲区的内存。整个缓冲区大小对 DB2 性能有巨大影响，这是因为大量的页可以显著地减少 I/O 这一最耗时的操作。但是，如果总的缓冲区大小太大，并且没有足够的存储器可用来分配给它们，那么将为每种页大小分配最少的缓冲池，性能就会急剧下降。要计算最大的缓冲区大小，DB2、操作系统以及其它任何应用程序都必须考虑其它所有存储器的利用率。一旦确定了总的可用大小，就可以将这个区域划分成不同的缓冲池以提高利用率。如果有一些具有不同页大小的表空间，那么每种页大小必须至少有一个缓冲池。 拥有多个缓冲池可以将数据保存在缓冲区中。例如，让我们假设一个数据库有许多频繁使用的小型表，这些表通常全部都位于缓冲区中，因此访问起来就非常快。现在让我们假设有一个针对非常大的表运行的查询，它使用同一个缓冲池并且需要读取比总的缓存区大小还多的页。当查询运行时，来自这些频繁使用的小型表的页将会丢失，这使得再次需要这些数据时就必须重新读取它们。 如果小型表拥有自己的缓冲池，那么它们就必须拥有自己的表空间，因此大型查询就不能覆盖它们的页。这有可能产生更好的整体系统性能，虽然这会对大型查询造成一些小的负面影响。经常性地进行调优是为了实现整体的性能提高而在不同的系统功能之间做出的权衡。区分功能的优先级并记住总吞吐量和使用情况，同时对系统性能进行调整，这是非常重要的。 V8 所引入的新功能能够在不关闭数据库的情况下更改缓冲池大小。带有 IMMEDIATE 选项的 altER BUFFERPOOL 语句会立刻生效，只要数据库共享的内存中有足够的保留空间可以分配给新空间。可以使用这个功能，根据使用过程中的周期变化（例如从白天的交互式使用转换到夜间的批处理工作）来调优数据库性能。 物理存储器组织一旦将表分布到多个表空间中，就必须决定它们的物理存储器。表空间可以存储在多个容器中，并且它可以是 SMS 或 DMS。SMS 更容易管理，对于包含许多不同的小型表的表空间（例如目录表空间），尤其是那些包含 LOB 的表的表空间而言，SMS 可能是个不错的选择。为了降低每次一页地扩展 SMS 容器的开销，应当运行 db2empfa命令。这会将数据库配置参数 MULTIPAGE_ALLOC 的值设置成 YES。 DMS 通常有更好的性能，并且它提供了分别地存储索引和 LOB 数据的灵活性。通常应当将一个表空间的多个容器分开存放在单独的物理卷上。这可以提高某些 I/O 的并行性。当有多个用户表空间和多个设备时，应当考虑应用程序逻辑，这样就可以尽可能平均地在这些设备上分配工作负载。 RAID 设备有它们自己的特殊考虑。EXTENTSIZE 应该等于 RAID 条带大小或者是它的倍数。PREFETCHSIZE 应该等于 RAID 条带大小乘以 RAID 并行设备数（或者等于该乘积的倍数），这个值应该是 EXTENTSIZE 的倍数。DB2 提供了自己的注册表变量，允许您增强您的特定环境。通过执行下面这个命令，可以在一个容器中启用 I/O 并行性： 1db2set DB2_PARALLEL_IO&#x3D;* 另一个注册表变量 DB2_STRIPED_CONTAINERS=ON 可以将容器标记大小从一个页更改成整个扩展块，因此就能使表空间扩展块和 RAID 条带一致。 至于性能评估的其它方面，要知道某个更改是否有益，唯一稳妥的方法就是进行基准测试。如果物理组织发生了更改，那么执行该任务稍微有些复杂，这是因为这时要更改表空间必须要付出相当大的精力。最实用的方法就是减少设计阶段中的案例数，这样的话稍后需要进行基准测试的案例就比较少了。只有在性能极其重要并且不同的设计之间有可能存在显著的性能差别时，才值得花时间和精力进行严格的基准测试来比较设计。应当把重点放在缓冲池上，确保没有将它们分配到虚拟内存中，并确保以最有效的方式利用它们。 有关移动数据库的考虑事项在将数据库移到另一个系统之前，始终应该重新评估它的调优参数和物理组织，即便这些系统是同一种平台也应如此。在实际情况中，DBA 将经过良好调优的数据库从具有 1 GB 内存的 Windows 服务器复制到具有 256 MB 内存的膝上型计算机中。在服务器上进行连接所花的时间小于一秒，而在膝上型计算机中却要用掉 45 分钟。通过减少缓冲池大小和其它内存参数就能解决这个问题。 如果平台不一样，那么这个问题就变得更难了。即使是在 UNIX 和 Windows 之间进行移动，在一个系统上已是最佳性能，在另一个系统上却未必如此。如果复制数据库是为了进行生产，那么应当重复调优过程。如果必须将数据库移到 zSeries™，那么这里讨论的某些内容则不适用，而应该参考有关的手册和红皮书。在 iSeries 系统上，物理设置和调优是在数据库环境之外一起完成的，应当参考 iSeries™ 系统管理手册。 结束语我们在本文中介绍了许多内容，但是您应当了解的有关数据库设计和性能的知识决不仅限于此。我们着重讨论了数据库设计的两个比较大的问题，而没有深入研究查询优化和应用程序考虑事项的细节。设计数据库是第一位的，因为这是其它所有事情的前提，因此您的初始规划应该非常全面。为了方便您的学习，我们在下面提供了其它联机参考资料，这样您就可以继续学习有关本主题的内容。 本文转载自IBM官方网站，原文地址：https://www.ibm.com/developerworks/cn/data/library/techarticles/0212wieser/0212wieser.html","categories":[{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/categories/DB2/"}],"tags":[{"name":"表空间","slug":"表空间","permalink":"https://born2do.github.io/tags/%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"name":"缓冲池","slug":"缓冲池","permalink":"https://born2do.github.io/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"}],"author":"chenhy"},{"title":"【VUE+SpringBoot】前台更改数据后，报错，但是数据库明明更改了","slug":"【VUE-SpringBoot】前台更改数据后，报错，但是数据库明明更改了","date":"2021-05-11T13:30:30.000Z","updated":"2021-05-11T13:30:56.115Z","comments":true,"path":"2021/05/11/【VUE-SpringBoot】前台更改数据后，报错，但是数据库明明更改了/","link":"","permalink":"https://born2do.github.io/2021/05/11/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E5%8F%B0%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%8E%EF%BC%8C%E6%8A%A5%E9%94%99%EF%BC%8C%E4%BD%86%E6%98%AF%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%8E%E6%98%8E%E6%9B%B4%E6%94%B9%E4%BA%86/","excerpt":"","text":"问题前台操作，更改了数据，显示失败。但是数据库中数据的的确确更改掉了。 12345678910111213editUserInfo() &#123; this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123; if(!valid) &#123; return; &#125; const &#123;data: res&#125; &#x3D; this.$http.put(&quot;editUser&quot;, this.editForm); if(res&#x3D;&#x3D;&quot;success&quot;) &#123; this.$message.success(&quot;操作成功&quot;); this.editDialogVisible &#x3D; false; this.getUserList(); &#125; else &#123; this.$message.error(&quot;操作失败&quot;); &#125; &#125;);&#125;, 思路 数据库中数据被更改掉了，说明前端的put请求是成功的，后台也正常处理掉了。 在前端控制台打印日志，查看访问后台后返回的数据是否正常。然而，控制台报错undefined 。仔细查看前端的数据处理，发现缺少await关键字。这也是为什么报错“undefined ”的原因了，根本就没有对后台返回的数据进行接收处理。处理添加上await关键字即可。最终代码如下：12345678910111213editUserInfo() &#123; this.$refs.editFormRef.validate(async valid &#x3D;&gt; &#123; if(!valid) &#123; return; &#125; const &#123;data: res&#125; &#x3D; await this.$http.put(&quot;editUser&quot;, this.editForm); if(res&#x3D;&#x3D;&quot;success&quot;) &#123; this.$message.success(&quot;操作成功&quot;); this.editDialogVisible &#x3D; false; this.getUserList(); &#125; else &#123; this.$message.error(&quot;操作失败&quot;); &#125; &#125;);&#125;, 归纳async + await 组合，用于异步处理后台返回的数据。","categories":[{"name":"VUE+SpringBoot","slug":"VUE-SpringBoot","permalink":"https://born2do.github.io/categories/VUE-SpringBoot/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【VUE+SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致","slug":"【VUE-SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致","date":"2021-05-10T13:04:07.000Z","updated":"2021-05-10T13:04:36.023Z","comments":true,"path":"2021/05/10/【VUE-SpringBoot】前端获取到的数据与后台从数据库中获取到的数据不一致/","link":"","permalink":"https://born2do.github.io/2021/05/10/%E3%80%90VUE-SpringBoot%E3%80%91%E5%89%8D%E7%AB%AF%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8E%E5%90%8E%E5%8F%B0%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/","excerpt":"","text":"问题后台从数据库中查询到的数据，转换成JSON字符串传到前端后，缺少部分字段。 123456@RequestMapping(&quot;/getUpdateUser&quot;)public String getUpdateUser(int id) &#123; User user = userDao.getUpdateUser(id); String string = JSON.toJSONString(user); return string;&#125; 12345async showEditDialog(id) &#123; const &#123;data: res&#125; = await this.$http.get(&quot;/getUpdateUser?id=&quot;+id); this.editForm = res;// 查询用户信息，回填用户编辑表单 this.editDialogVisible = true;&#125;, 思路 打印出后台从数据库中查询出的数据，发现字段是完整的，并无缺失。 打印JSON字符串，发现缺少字段，定位到问题入口。 查看JSON.toJSONString()方法后，并未发现异常。 将该模块的所有文件重新审阅一遍后发现，实体类User.java中有个布尔类型的成员变量的get方法不对头，如下：12345private boolean state; // 状态public boolean isState() &#123; return state;&#125; 并不是我们平常的get方法：123public boolean getState() &#123; return state;&#125; 这就导致JSON将User对象转换成json字符串时，无法通过反射获取到其state字段，最终给前端的json数据也就没有该字段。处理重写实体类User的get、set方法并检验，确保不再出错。重启后，测试显示正常。归纳 对于布尔类型的成员变量，在使用IDEA生成get方法后，需要进行修改。否则，将无法通过一般的反射获取其全部成员变量，项目容易出问题。","categories":[{"name":"VUE+SpringBoot","slug":"VUE-SpringBoot","permalink":"https://born2do.github.io/categories/VUE-SpringBoot/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【SpringBoot】Project 'org.springframework.boot:spring-boot-starter-parent:2.4.5' not found","slug":"【SpringBoot】Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found","date":"2021-05-09T15:21:43.000Z","updated":"2021-05-09T15:22:10.628Z","comments":true,"path":"2021/05/09/【SpringBoot】Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/","link":"","permalink":"https://born2do.github.io/2021/05/09/%E3%80%90SpringBoot%E3%80%91Project-org-springframework-boot-spring-boot-starter-parent-2-4-5-not-found/","excerpt":"","text":"问题新建SpringBoot项目后，项目正常运行，但是pom.xml文件提示“Project ‘org.springframework.boot:spring-boot-starter-parent:2.4.5’ not found” 。 解决出现这种问题，是由于在当前的仓库中找不到指定的版本Jar包。通常我们在本地会将远程仓库配置成阿里云镜像，如果pom.xml文件中指定的版本过高，可能阿里云镜像仓库中会没有，也就导致了该错误。降低版本即可。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;&#x2F;version&gt; &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;&lt;&#x2F;parent&gt;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://born2do.github.io/categories/SpringBoot/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【前后端分离】跨域问题","slug":"【前后端分离】跨域问题","date":"2021-05-08T13:07:55.000Z","updated":"2021-05-08T13:08:28.415Z","comments":true,"path":"2021/05/08/【前后端分离】跨域问题/","link":"","permalink":"https://born2do.github.io/2021/05/08/%E3%80%90%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E3%80%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题VUE前端项目和SpringBoot后端项目起起来后，发现前端无法访问后台地址。报错如下： 1Access to XMLHttpRequest at &#39;http:&#x2F;&#x2F;localhost:9000&#x2F;test&#39; from origin &#39;http:&#x2F;&#x2F;localhost:8080&#39; has been blocked by CORS policy: No &#39;Access-Control-Allow-Origin&#39; header is present on the requested resource. 前端： 12345678910111213141516171819202122import Vue from &#39;vue&#39;import App from &#39;.&#x2F;App.vue&#39;import router from &#39;.&#x2F;router&#39;import &#39;.&#x2F;plugins&#x2F;element.js&#39;&#x2F;&#x2F; 添加全局样式import &#39;.&#x2F;assets&#x2F;css&#x2F;global.css&#39;&#x2F;&#x2F; 引入iconfontimport &#39;.&#x2F;assets&#x2F;font&#x2F;iconfont.css&#39;&#x2F;&#x2F; 导入axiosimport axios from &#39;axios&#39;&#x2F;&#x2F; 挂载axiosVue.prototype.$http &#x3D; axios&#x2F;&#x2F; 设置访问路径(后端地址)axios.defaults.baseURL &#x3D; &quot;http:&#x2F;&#x2F;localhost:9000&#x2F;&quot;Vue.config.productionTip &#x3D; falsenew Vue(&#123; router, render: h &#x3D;&gt; h(App)&#125;).$mount(&#39;#app&#39;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;template&gt; &lt;div class&#x3D;&quot;login_container&quot;&gt; &lt;div class&#x3D;&quot;login_box&quot;&gt; &lt;!-- 头像 --&gt; &lt;div class&#x3D;&quot;avatar_box&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 登陆表单 --&gt; &lt;el-form ref&#x3D;&quot;loginFormRef&quot; :rules&#x3D;&quot;loginRules&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;login_form&quot; label-width&#x3D;&quot;0&quot;&gt; &lt;el-form-item prop&#x3D;&quot;username&quot;&gt; &lt;el-input v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-usercenter&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item prop&#x3D;&quot;password&quot;&gt; &lt;el-input v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-unlock&quot; type&#x3D;&quot;password&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item class&#x3D;&quot;btns&quot;&gt; &lt;el-button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;login()&quot;&gt;提交&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;info&quot; @click&#x3D;&quot;resetLoginForm()&quot;&gt;重置&lt;&#x2F;el-button&gt; &lt;&#x2F;el-form-item&gt; &lt;&#x2F;el-form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; &#x2F;&#x2F; 表单数据 loginForm: &#123; username: &quot;admin&quot;, password: &quot;123456&quot; &#125;, &#x2F;&#x2F; 表单校验 loginRules: &#123; username: [ &#123; required: true, message: &#39;请输入用户名&#39;, trigger: &#39;blur&#39; &#125;, &#123; min: 5, max: 12, message: &#39;长度在 5 到 12 个字符&#39;, trigger: &#39;blur&#39; &#125; ], password: [ &#123; required: true, message: &#39;请输入密码&#39;, trigger: &#39;blur&#39; &#125;, &#123; min: 6, max: 10, message: &#39;长度在 6 到 10 个字符&#39;, trigger: &#39;blur&#39; &#125; ], &#125;, &#125; &#125;, methods: &#123; resetLoginForm() &#123; this.$refs.loginFormRef.resetFields(); &#125;, login() &#123; this.$refs.loginFormRef.validate(async valid &#x3D;&gt; &#123; if(!valid) &#123; return; &#125; const &#123;data: res&#125; &#x3D; await this.$http.post(&quot;test&quot;); console.log(res); &#125;) &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;.login_container &#123; background-color: #2b4b6b; height: 100%;&#125;.login_box &#123; width: 450px; height: 300px; background-color: #fff; border-radius: 3px; position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%); .avatar_box &#123; width: 130px; height: 130px; border: 1px solid #eee; border-radius: 50%; padding: 5px; box-shadow: 0 0 10px #ddd; position: absolute; left: 50%; transform: translate(-50%,-50%); background-color: #eee; img &#123; width: 100%; height: 100%; border-radius: 50%; background-color: #eee; &#125; &#125;&#125;.btns &#123; display: flex; justify-content: flex-end;&#125;.login_form &#123; position: absolute; bottom: 0%; width: 100%; padding: 0 10px; box-sizing: border-box;&#125;&lt;&#x2F;style&gt; 后端： 12345678910111213141516171819202122232425262728293031323334package com.example.sport.util;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.CorsRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;/** * @author chenhy * @date 2021/5/6 *//** * 全局配置类--配置跨域请求 */@Configurationpublic class Webconfig extends WebMvcConfigurerAdapter &#123; /** * 1.域访问路径 * 2.请求来源 * 3.方法 * 4.允许携带token等信息 * 5.设置生命周期 * @param registry */ @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedOrigins(&quot;http://localhost:8080/&quot;, &quot;null&quot;) .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;OPTION&quot;, &quot;DELETE&quot;) .allowCredentials(true) .maxAge(3600); &#125;&#125; 12345678910111213141516171819package com.example.sport.controller;import org.springframework.web.bind.annotation.CrossOrigin;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author chenhy * @date 2021/5/6 */@RestControllerpublic class LoginController &#123; @RequestMapping(&quot;/test&quot;) public String test() &#123; return &quot;测试成功！&quot;; &#125;&#125; 原因查找根据报错，很明显是跨域问题。那么到底在哪里出错了？前端还是后端？ 一开始以为是浏览器的问题，从edge转到谷歌浏览器后，问题仍然存在。 查看了前端的axios挂载以及请求的情况，请求路径没有问题。 那么就是后端的问题了。我尝试着按照网上的博客来修改Webconfig .java文件，但是没有用（自己太垃圾，没改对而已）。然后，我尝试着将跨域的注解直接放到方法上面：1@CrossOrigin(origins = &quot;http://localhost:8080&quot;, maxAge = 3600) 重启后，项目竟然可以正常访问了！！！这个时候，我再回看之前的跨域配置文件Webconfig .java，发现竟然是url在最后多出一条斜杠的原因。需要将1.allowedOrigins(&quot;http://localhost:8080/&quot;, &quot;null&quot;) 修改为1.allowedOrigins(&quot;http://localhost:8080&quot;, &quot;null&quot;)","categories":[{"name":"前后端分离","slug":"前后端分离","permalink":"https://born2do.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"},{"name":"跨域","slug":"跨域","permalink":"https://born2do.github.io/tags/%E8%B7%A8%E5%9F%9F/"}],"author":"chenhy"},{"title":"【vue】在lang=less的style中编写样式报错","slug":"【vue】在lang-less的style中编写样式报错","date":"2021-05-07T16:04:40.000Z","updated":"2021-05-07T16:05:06.270Z","comments":true,"path":"2021/05/08/【vue】在lang-less的style中编写样式报错/","link":"","permalink":"https://born2do.github.io/2021/05/08/%E3%80%90vue%E3%80%91%E5%9C%A8lang-less%E7%9A%84style%E4%B8%AD%E7%BC%96%E5%86%99%E6%A0%B7%E5%BC%8F%E6%8A%A5%E9%94%99/","excerpt":"","text":"背景最近在学习vue，照着B站上的一个项目直接进行实战学习。链接：https://www.bilibili.com/video/BV1q5411s7wH?t=93前端项目建好，创建登录页面，更改样式的时候报错了。报错截图：源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;div class&#x3D;&quot;login_container&quot;&gt; &lt;div class&#x3D;&quot;login_box&quot;&gt; &lt;!-- 头像 --&gt; &lt;div class&#x3D;&quot;avatar_box&quot;&gt; &lt;img src&#x3D;&quot;..&#x2F;assets&#x2F;logo.png&quot; &#x2F;&gt; &lt;&#x2F;div&gt; &lt;!-- 登陆表单 --&gt; &lt;el-form ref&#x3D;&quot;loginFormRef&quot; :model&#x3D;&quot;loginForm&quot; class&#x3D;&quot;login_form&quot; label-width&#x3D;&quot;0&quot;&gt; &lt;el-form-item&gt; &lt;el-input v-model&#x3D;&quot;loginForm.username&quot; prefix-icon&#x3D;&quot;iconfont icon-usercenter&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item&gt; &lt;el-input v-model&#x3D;&quot;loginForm.password&quot; prefix-icon&#x3D;&quot;iconfont icon-unlock&quot;&gt;&lt;&#x2F;el-input&gt; &lt;&#x2F;el-form-item&gt; &lt;el-form-item class&#x3D;&quot;btns&quot;&gt; &lt;el-button type&#x3D;&quot;primary&quot;&gt;提交&lt;&#x2F;el-button&gt; &lt;el-button type&#x3D;&quot;info&quot;&gt;重置&lt;&#x2F;el-button&gt; &lt;&#x2F;el-form-item&gt; &lt;&#x2F;el-form&gt; &lt;&#x2F;div&gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; loginForm: &#123; username: &quot;username&quot;, password: &quot;password&quot; &#125; &#125; &#125;&#125;&lt;&#x2F;script&gt;&lt;style lang&#x3D;&quot;less&quot; scoped&gt;.login_container &#123; background-color: #2b4b6b; height: 100%;&#125;.login_box &#123; width: 450px; height: 300px; background-color: #fff; border-radius: 3px;&#125;&lt;&#x2F;style&gt; 思路根据报错信息，很快便定位到是版本问题。在网上查找了相关的博客，大多表示是由于less-loader版本过高。我尝试着将less-loader的版本降低，但是仍然报错。然后，我按照视频中up主使用的版本，将less以及less-loader卸载后重新安装低版本，项目正常编译。 解决12345npm uninstall less-loadernpm uninstall lessnpm install less@3.11.1 --save npm install less-loader@6.1.0 --save","categories":[{"name":"vue","slug":"vue","permalink":"https://born2do.github.io/categories/vue/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【DB2】DB2基础_表分区","slug":"【DB2】DB2基础-表分区","date":"2021-05-06T12:49:05.000Z","updated":"2021-05-06T12:50:02.031Z","comments":true,"path":"2021/05/06/【DB2】DB2基础-表分区/","link":"","permalink":"https://born2do.github.io/2021/05/06/%E3%80%90DB2%E3%80%91DB2%E5%9F%BA%E7%A1%80-%E8%A1%A8%E5%88%86%E5%8C%BA/","excerpt":"","text":"开始之前CREATE TABLE 语句的 PARTITION BY 子句指定了表数据的分区。该定义中使用的列被称为表分区键列。 关于该特性的详细说明可参见 “Table partitioning in DB2 9”（developerWorks，2006 年 5 月）。 表分区特性提供以下收益： 表数据可轻易实现转入和转出 对大型表的管理更加轻松 灵活的索引放置 更高的业务智能样式查询的性能 关于本教程本教程中的练习将引领您使用表分区特性，并演示了表数据的转入转出、更轻松的大型表管理、灵活的索引放置和对业务智能样式查询的性能改善。 这些练习旨在演示上述各领域内的一个或多个任务。 目标本教程的目标是在以下方面探究 DB2 9 范围分区的特性和优点： 创建范围分区表 分区的转入和转出 分区表的管理 索引管理和放置 先决条件本教程的目标读者是那些技能和经验刚刚迈入中级水平的 DB2 专业人员。要学习本教程，您应该熟悉 DB2 命令行、DB2 管理工具的使用，还应具备 SQL 实践经验。 系统需求要运行本教程的示例，需要具备以下条件： DB2 9 Data Server Microsoft® Windows® 2000 或更高版本，以及一个具有管理员权限的帐户，或具有根访问权限的 Linux®（验证版）。 确保系统中的 Java Runtime Environment 是 1.4.2 或更高版本。 参考 DB2 9 系统需求页面 确保您的硬件符合要求。 可通过上面的链接获取 DB2 9 Express C。关于安装 DB2 的步骤请参考 “DB2 XML 评估指南”（developerWorks，2006 年 6 月）。若未改动 DB2 的配置，安装后 DB2 将自动启动。 使用 partition.zip 文件提供的示例脚本和数据演示本教程的概念。将其内容解压缩到 scripts 子目录（C:\\scripts 或 home/userid/scripts）。本教程中将该目录简称为 stmm_scripts。教程假设您使用的是 DB2 默认安装目录，并且所有的 DB2 练习都通过一个数据库管理员 ID 执行。 创建分区表这个实验将探讨创建分区表、将数据载入分区表以及使用 describe 命令来说明表范围的方法： 您将登录并为所有的练习设置基本环境。 您将创建不同格式的分区表并加载数据。 您将使用 DB2 命令和 SQL 查看结果。 将对 DB2 9 表范围分区进行概述。 登录和基本指令 登录到您的机器，如图 1 所示，使用 db2inst1。 图 1. 基本设置 打开终端窗口（Linux）或 DB2 命令窗口（windows）。 切换到 scripts 子目录。 清单 1. 切换目录 12cd /scripts or cd c:\\scripts 使用db2start命令启动 DB2，并连接到 SAMPLE 数据库。 清单 2. StartDB2 12db2startdb2 connect to SAMPLE 创建基本分区表这一节将介绍分区表的基本创建和加载。您将创建不同格式的表、验证创建结果、加载数据并对表进行查询。 使用如下的数据定义语言（DDL）创建具有四个范围的 LINEITEM 表： 清单 3. 创建表 12345678910111213141516171819202122CREATE TABLE LINEITEM ( l_orderkey DECIMAL(10,0) NOT NULL, l_partkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44)) PARTITION BY RANGE(l_shipdate)( STARTING &#x27;1/1/1992&#x27; ENDING &#x27;30/06/1992&#x27;, STARTING &#x27;1/7/1992&#x27; ENDING &#x27;31/12/1992&#x27;, STARTING &#x27;1/1/1993&#x27; ENDING &#x27;30/6/1993&#x27;, STARTING &#x27;1/7/1993&#x27; ENDING &#x27;31/12/1993&#x27;) 创建该表的 SQL 语句位于 EX1-6.sql 文件中，可使用如下命令运行该文件： 清单 4. 运行 EX1-6 1db2 –vtf EX1-6.sql 使用下面的命令说明为 LINEITEM 表创建的分区的范围： 清单 5. 说明 1db2 describe data partitions for table LINEITEM 图 2. 说明为 LINEITEM 表创建的分区范围 注意：创建了四个数据分区。其中的范围包括边界值。 将数据导入到 LINEITEM 表。该操作的导入命令位于 EX1-8.sql 文件中，可使用如下命令运行： 清单 6. 带有拒绝的加载 1db2 –vtf EX1-8.sql 图 3. 将数据导入到 LINEITEM 表 注意：导入时拒绝了 729 行数据，这是因为它们不具有位于当前 LINEITEM 表的数据分区定义范围内的 l_shipdate。 标量函数可用于显示行所属的数据分区号（datapartitionnum）。执行以下示例 SQL 查看标量函数的输出： 清单 7. 查询 - 匹配日期的分区 123db2 &quot;select datapartitionnum(l_shipdate) as PartitionId, l_shipdate from lineitem where l_shipdate between &#x27;01/06/1992&#x27; and &#x27;31/07/1992&#x27; order by l_shipdate&quot; 图 4. 标量函数的输出 注意：标量函数（datapartitionnum）返回的值和describe 命令返回的是同一个 PartitionId。该语句的子句间使用的谓词范围超出了 PartitionId 0 和 PartitionId 1 的边界 具有全部范围的分区表 创建具有两个额外数据分区的新 LINEITEM 表，其中一个分区用来捕获低于当前范围的值，另一个分区用来捕获高于当前范围的值。首先使用下面的命令删除现有的 LINEITEM 分区表： 清单 8. 删除表 1db2 drop TABLE LINEITEM 然后使用如下 DDL 创建 LINEITEM 表的新版本： 清单 9. 创建表 123456789101112131415161718192021222324CREATE TABLE LINEITEM ( l_orderkey DECIMAL(10,0) NOT NULL, l_partkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44)) PARTITION BY RANGE(l_shipdate)( STARTING MINVALUE, STARTING &#x27;1/1/1992&#x27; ENDING &#x27;30/06/1992&#x27;, STARTING &#x27;1/7/1992&#x27; ENDING &#x27;31/12/1992&#x27;, STARTING &#x27;1/1/1993&#x27; ENDING &#x27;30/6/1993&#x27;, STARTING &#x27;1/7/1993&#x27; ENDING &#x27;31/12/1993&#x27;, ENDING MAXVALUE) 创建该表的 SQL 位于 EX1-10.sql 文件中，可使用下列命令运行： 清单 10. 运行 EX1-10 1db2 –vtf EX1-10.sql 使用下面的命令说明为 LINEITEM 表创建的分区范围。 清单 11. 说明 1db2 describe data partitions for table LINEITEM 图 5. 说明为 LINEITEM 表创建的分区范围 注意：新的 MINVALUE 范围具有一个最高值，该值和下一个数据分区开始部分的值相等，但它并不包含该值。MAXVALUE 范围具有一个最低值，该值和前一个范围结束部分的值相等，但它不包含该值。这将创建一个无间隙的连续范围。 将数据导入到 LINEITEM 表中。该操作的导入命令位于 EX1-8.sql 文件中，可使用下面的命令运行该文件： 清单 12. 全面加载 1db2 –vtf EX1-8.sql 图 6. 将数据导入到 LINEITEM 表中 具有生成范围的分区表 创建一个新 LINEITEM 表，它具有从 1992 年 1 月 1 日到 1998 年 12 月 31 日按月划分的数据分区生成范围。同样，添加 minvalue 和 maxvalue 范围来存放具有超过此范围的 l_shipdate 的值的行。首先使用以下命令删除现有的 LINEITEM 分区表： 清单 13. 删除表 1db2 drop TABLE LINEITEM 然后使用如下 DDL 创建 LINEITEM 表的新版本： 清单 14. 创建表 12345678910111213141516171819202122CREATE TABLE lineitem(l_orderkey DECIMAL(10,0) NOT NULL, l_cpartkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44)) PARTITION BY RANGE(l_shipdate) (STARTING MINVALUE, STARTING &#x27;1/1/1992&#x27; ENDING &#x27;31/12/1998&#x27; EVERY 1 MONTH, ENDING MAXVALUE); 创建该表的 SQL 位于 EX1-13.sql 文件中，可使用下面的命令运行该文件： 清单 15. 运行 EX1-13 1db2 –vtf EX1-13.sql 使用如下命令来说明为 LINEITEM 表创建的分区范围： 清单 16. 说明 1db2 describe data partitions for table LINEITEM 图 7. 说明为 LINEITEM 表创建的分区范围 注意：创建了 86 个数据分区，但是没有包括这些范围的最高值，因为这些最高值将和之后的数据分区的最低值重叠。 将数据导入到 LINEITEM 表。此操作的导入命令位于 EX1-8.sql 文件中，可使用下面的命令运行该文件： 清单 17. 加载并生成 1db2 –vtf EX1-8.sql 图 8. 将数据导入到 LINEITEM 表 使用下面的 SQL 来验证 LINEITEM 表每一个数据分区的行数： 清单 18. 查询数据 1234db2 &quot;select year(l_shipdate) as year, month(l_shipdate) as month, count(*) as count from lineitem group by year(l_shipdate), month(l_shipdate) order by 1, 2&quot; 使用以下的 SQL 语句验证 LINEITEM 表的每一个数据分区的行数： 清单 19. 查询数据脚本 1db2 –vtf EX1-16.sql 图 9. 检验行数 注意：执行加载操作后，86 个范围中有 82 个范围包含一个或多个行。 放置分区表该实验探讨放置分区表以及使用 describe 命令说明表内的范围和放置情况的方法： 您将为数据放置练习创建新的表空间。 你将创建不同格式的分区表。 您将使用 db2 命令和 SQL 查看结果。 基本环境设置 使用describe data partitions命令以及show detail方法来显示表空间的分区放置。 清单 20. 创建表 1db2 describe data partitions for table LINEITEM show detail 图 10. 表空间的分区放置 注意：TableSpID 列给出了包含分区的表空间的 ID 号。在本例中，TableSpID 是 ‘3’。 使用list tablespaces命令标识与 TableSpId 相关联的表空间。 清单 21. 说明 1db2 list tablespaces 图 11. 标识表空间 注意：相应值为 ‘2’ 的 TableSpID 是 USERSPACE1 或默认的表空间。 现在将创建五个表空间来说明不同的放置选项。使用如下命令： 清单 22. 说明 12345db2 create tablespace dms_d1 managed by database using (file &#x27;c:\\ts1&#x27; 10000);db2 create tablespace dms_d2 managed by database using (file &#x27;c:\\ts2&#x27; 10000);db2 create tablespace dms_d3 managed by database using (file &#x27;c:\\ts3&#x27; 10000);db2 create tablespace dms_d4 managed by database using (file &#x27;c:\\ts4&#x27; 10000);db2 create tablespace dms_i1 managed by database using (file &#x27;c:\\ts5&#x27; 10000); 创建该表空间的 SQL 位于 EX2-3.sql 文件中，可使用下面的命令运行该文件： 清单 23. 查询数据脚本 1db2 –vtf EX2-3.sql 创建一个新的 LINEITEM 表，具有位于 dms_d1 和 dms_d2 表空间的生成分区集。首先，使用如下命令删除现有的 LINEITEM 分区表： 清单 24. 删除表 1db2 drop TABLE LINEITEM 然后，使用下面的 DDL 创建 LINEITEM 表的新版本： 清单 25. 创建表 1234567891011121314151617181920212223CREATE TABLE LINEITEM(l_orderkey DECIMAL(10,0) NOT NULL, l_partkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44)) IN DMS_D1, DMS_D2 PARTITION BY RANGE(l_shipdate)(STARTING MINVALUE, STARTING &#x27;1/1/1992&#x27; ENDING &#x27;31/12/1998&#x27; EVERY 1 MONTH, ENDING MAXVALUE); 创建该表的 SQL 位于 EX2-4.sql 文件中，可使用下面的命令运行该文件： 清单 26. 运行 EX2-4 1db2 –vtf EX2-4.sql 使用下面的命令说明为 LINEITEM 表创建的分区范围： 清单 27. 说明 1db2 describe data partitions for table LINEITEM show detail 图 12. 说明为 LINEITEM 表创建的分区范围 图 13. 分区 注意：TableSpID 列给出了包含分区的表空间的 ID 号。在本例中，TableSpID 为 4（对应于 DMS_D1）或 5（对应于 DMS_D2）。本例中将生成的分区依次分配给指定的表空间。 分区的显式放置 创建一个具有四个数据分区的新 LINEITEM 表，每一个数据分区被显式地放在表空间中。首先使用如下命令删除现有的 LINEITEM 表： 清单 28. 删除表 1db2 drop TABLE LINEITEM 然后使用下面的 DDL 创建 LINEITEM 表的新版本： 清单 29. 创建表 12345678910111213141516171819202122CREATE TABLE LINEITEM (l_orderkey DECIMAL(10,0) NOT NULL, l_partkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44)) PARTITION BY RANGE(l_shipdate) ( STARTING MINVALUE IN DMS_D1, STARTING &#x27;1/1/1992&#x27; ENDING &#x27;31/12/1992&#x27; IN DMS_D2, STARTING &#x27;1/1/1993&#x27; ENDING &#x27;31/12/1993&#x27; IN DMS_D3, ENDING MAXVALUE IN DMS_D4 ); 创建表的 SQL 位于 EX2-6.sql 文件中，可使用下面的命令运行该文件： 清单 30. 运行 EX2-6 1db2 –vtf EX2-6.sql 使用下面的命令说明为 LINEITEM 表创建的分区范围： 清单 31. 说明 1db2 describe data partitions for table LINEITEM show detail 图 14. 说明为 LINEITEM 表创建的分区范围 注意：在本例中，每一个分区被放置在一个不同的 TableSpID 中，这个 TableSpID 和创建表的 DDL 中指定的表空间是相对应的。 创建一个具有四个数据分区的 LINEITEM 表，每一个数据分区被显式地放在表空间并且索引被放在表空间 DMS_I1 中。 在这一步中，将引入命名分区的概念，而不是使用默认的生成名称。 首先，使用下面的命令删除现有的 LINEITEM 分区表： 清单 32. 删除表 1db2 drop TABLE LINEITEM 然后，使用以下的 DDL 创建 LINEITEM 表的新版本： 清单 33. 创建表 1234567891011121314151617181920212223CREATE TABLE LINEITEM(l_orderkey DECIMAL(10,0) NOT NULL, l_partkey INTEGER, l_suppkey INTEGER, l_linenumber INTEGER, l_quantity DECIMAL(12,2), l_extendedprice DECIMAL(12,2), l_discount DECIMAL(12,2), l_tax DECIMAL(12,2), l_returnflag CHAR(1), l_linestatus CHAR(1), l_shipdate DATE, l_commitdate DATE, l_receiptdate DATE, l_shipinstruct CHAR(25), l_shipmode CHAR(10), l_comment VARCHAR(44))INDEX IN DMS_I1PARTITION BY RANGE(l_shipdate)( PART JAN1992 STARTING &#x27;1/1/1992&#x27; ENDING &#x27;30/6/1992&#x27; IN DMS_D1, PART JULY1992 STARTING &#x27;1/7/1992&#x27; ENDING &#x27;31/12/1992&#x27; IN DMS_D2, PART JAN 1993 STARTING &#x27;1/1/1993&#x27; ENDING &#x27;30/6/1993&#x27; IN DMS_D3, PART JULY1993 STARTING &#x27;1/7/1993&#x27; ENDING &#x27;31/12/1993&#x27; IN DMS_D4); 创建表的 SQL 位于 EX2-8.sql 文件中，可使用下面的命令运行该文件： 清单 34. 运行 EX2-8 1db2 –vtf EX2-8.sql 在 LINEITEM 表中创建一个索引，并将它放置在表空间 DMS_I1 中。使用如下 SQL： 清单 35. 索引 1db2 &quot;create index I_LINEITEM on LINEITEM(L_SHIPDATE) in DMS_I1&quot; 使用下面的 SQL 检验和该表相关联的索引的位置： 清单 36. 说明 1db2 &quot;select tabname, index_tbspace from syscat.tables where tabname = &#x27;LINEITEM&#x27;&quot; 图 15. 检验索引的位置 注意：索引空间是 DMS_I1。如果没有为分区表指定表空间，那么默认情况下索引位于连接着的第一个表空间。 在 CREATE TABLE 中定义表空间是很好的实践。然而，无论您是否在创建表语句 ID 中指定索引表空间，这并不限制您将来放置索引的位置。您可以在 CREATE INDEX 语句本身显式地指定索引表空间。 同一分区表的不同索引可以放置在不同的表空间。 管理分区表这个实验将查看如何管理和操作分区表： 您将添加和删除分区。 您将执行对分区的转入转出操作。 在执行查看操作时将使用 DB2 命令和 SQL。 使用现有的表添加一个新的分区 将数据导入 LINEITEM 表。创建表空间的 SQL 位于 EX3-1.sql 文件中，可使用下面的命令运行该文件： 清单 37. 导入数据 1db2 –vtf EX3-1.sql 图 16. 将数据导入到 LINEITEM 表 注意：分区表中的记录数，以及将进行连接和分离的记录数对于说明数据库中的数据何时可用非常重要。 创建一个名为 NP_LINEITEM 的新表。脚本 EX3-2.sql 创建一个具有 87 行的新表 NP_LINEITEM: 清单 38. 新分区 1db2 –vtf EX3-2.sql 图 17. 将数据导入到 NP_LINEITEM 表 使用下面的命令说明为 LINEITEM 表创建的分区范围： 清单 39. 说明 1db2 describe data partitions for table LINEITEM show detail 图 18. LINEITEM 表的分区 注意：LINEITEM 表目前包含 4 个数据分区。 使用Alter语句将一个新的分区连接（转入）到现有的 LINEITEM 表。 清单 40. 新分区 123ALTER TABLE LINEITEM ATTACH PARTITION JAN1994STARTING &#x27;1/1/1994&#x27; ENDING &#x27;30/6/1994&#x27;FROM NP_LINEITEM 可以使用以下命令运行脚本 EX3-4： 清单 41. 新分区 1db2 –vtf EX3-4.sql 图 19. 脚本 EX3-4 注意：LINEITEM 表被置于 SET INTEGRITY PENDING 状态。 连接后，使用describe data partitions命令来说明为 LINEITEM 表创建的分区范围： 清单 42. 说明 1db2 describe data partitions for table LINEITEM show detail 图 20. LINEITEM 表的分区 注意：新数据分区（JAN1994）PartitionId 4 现在连接到了 LINEITEM 表。然而连接的分区的 AccessMode 值为 ‘N’ 并且 Status 的值为 ‘A’。 AccessMode 可能的值有： D = 没有数据移动 F = 完全访问 N = 不访问 R = 只读访问 Status 可能的值有： A = 数据分区是新连接的 D = 数据分区是分离的 I = 只有在执行异步索引清除时才对条目位于目录的分离的数据分区进行维护；当所有引用分离数据分区的索引记录删除后，将删除 STATUS 值为 ‘I’ 的行。 Empty string = 数据分区是可见的（普通状态） 运行两个select count语句来检查连接语句涉及的两个表中数据的可用性。 清单 43. Count Lineitem 1db2 &quot;select count(*) from lineitem&quot; 图 21. select count 语句的结果 注意：LINEITEM 表最初的分区是可用的，但是 PartitionId 4 中的新数据仍不可见。 清单 44. Count np-lineitem 1db2 &quot;select count(*) from np_lineitem&quot; 图 22. select count 语句的结果 注意：NP_LINEITEM 表现在是一个未定义的对象，在 LINEITEM 表内只能将其作为一个分区使用。 创建一个异常表并与 SET INTEGRITY 语句结合使用。执行该操作的 DDL 位于 EX3-7.sql 文件，可使用下面的命令运行该文件： 清单 45. 异常表 1db2 –vtf EX3-7.sql 对 LINEITEM 分区表运行set integrity语句 。 清单 46. 设置完整性 1234SET INTEGRITY FOR LINEITEMALLOW WRITE ACCESSIMMEDIATE CHECKEDFOR EXCEPTION IN LINEITEM USE LINEITEM_EX 执行该操作的 SQL 位于 EX3-8.sql 文件中，可以使用下面的命令运行该文件： 清单 47. 设置完整性 1db2 –vtf EX3-8.sql 图 23. EX3-8.sql 文件 注意：SET INTEGRITY对于检查新连接的数据是否在范围内是必需的，它还执行对索引和其他独立对象（例如物化查询表）所有必需的维护工作。只有得到SET INTEGRITY语句的允许，新的数据才能变为可见。然而，当运行SET INTEGRITY时，可以对 LINEITEM 表中的现有数据进行完全访问，包括读和写操作。 用户应该执行SET INTEGRITY事务从而能够使用整个表。当运行SET INTEGRITY时，不能够对表执行 DDL 或其他实用类型的操作。 在这个练习中，在 NP_LINEITEM 表中创建并被连接到 LINEITEM 表的所有的行，都在连接语句指定的范围内。如果这些行中存在超出此范围的行，则需要在SET INTEGRITY语句中创建一个异常表来防止语句发生错误。所以推荐您始终在SET INTEGRITY语句中包含一个异常表。如果没有提供异常表的话，SET INTEGRITY语句发现的错误将导致语句失败并且所有的工作都必须从头做起。如果使用大量数据时，这可能是一个长期操作。有一点值得注意，如果SET INTEGRITY操作失败，所有工作都需要重做，与之相比较，LOAD仅仅抛弃存在问题的行。 对 LINEITEM 表运行select count SQL 以检查连接的分区中数据的可用性： 清单 48. Count Lineitem 1db2 &quot;select count(*) from lineitem&quot; 图 24. select count 语句的结果 注意：成功执行SET INTEGRITY操作后，LINEITEM 表应包含 PartitionId 4 的数据。 从分区表中分离一个分区 使用describe data partitions show detail命令来标识一个分区的 PartitionName，您将把这个分区从 LINEITEM 分区表中分离（转出）出来。 清单 49. 说明表 1db2 describe data partitions for table LINEITEM show detail 图 25. LINEITEM 表的分区 注意：将分离最早的分区范围 PartitionId 0。该分区的 PartitionName 是 JAN1992。将在DETACH操作中使用它来标识被转出的分区。同样还需注意成功执行了SET INTEGRITY操作后，分区 JAN1994 的 AccessMode 的值为 ‘F’，Status 值为空。TableSpId、PartObjId 和 LongTblSpId 的结果可能和这里显示的不一样。 使用Alter语句将 JAN1992 从 LINEITEM 表中分离（转出）。 清单 50. Alter 表 1ALTER TABLE LINEITEM DETACH PARTITION JAN1992 INTO LINEITEM_JAN1992 创建文件的 SQL 位于 EX3-11.sql 文件中，可使用下面的命令运行该文件： 清单 51. Alter 表 1db2 –vtf EX3-11.sql 注意：将 JAN1992 成功分离后，将创建一个新的表 LINEITEM_JAN1992。在DETACH操作中没有涉及数据移动，并且位于相同表空间的新表的行为和它作为 LINEITEM 分区表的一部分时是一样的。此时不需要对 LINEITEM 表运行SET INTEGRITY语句，因为没有对 LINEITEM 表定义的 MQTs。 还有一点值得注意，如果从 Multi-Dimensional Clustering（MDC）分离一个分区从而创建了一个新表时，这个表也将是一个 MDC。这个规则同样适用于下面这个情况：从一个分布式表中分离分区从而在相同的分区组创建分布式表。执行DETACH操作后产生的表使用 MDC 索引定义而不是其他的索引。对于 MDC，在首次访问连接的表时将重新构建索引。在这种情况下，将自动对分离的分区进行索引清除操作。将从执行DETACH操作的用户 ID 继承索引的模式、权限和表空间。 运行两个select count语句检查DETACH语句涉及的两个表中的数据的可用性。 清单 52. Count Lineitem_jan1992 1db2 &quot;select count(*) from lineitem_jan1992&quot; 图 26. select count 语句的结果 注意：创建的 LINEITEM_JAN1992 表包含 38 行，它被包含在 LINEITEM 分区表的 JAN1992 分区中。 清单 53. Count lineitem 1db2 &quot;select count(*) from lineitem&quot; 图 27. select count 语句的结果 注意：此时 LINEITEM 表完全可用，并且不包括 PART0 中的数据。 当数据被移动到分区表中，或当希望将数据加载到或直接插入分区表中时，一个更合适的方法是向现有的分区表添加一个空的分区。使用下面的命令向现有的 LINEITEM 表添加一个空的分区： 清单 54. 说明 12db2 &quot;ALTER TABLE LINEITEM ADD PARTITION JULY1994 STARTING &#x27;1/7/1994&#x27; ENDING &#x27;31/12/1994&#x27;&quot;&quot; 图 28. 向现有的 LINEITEM 表添加一个空的分区 使用describe data partitions show detail命令来检验 PartitionName 为 JULY1994 的分区是否被添加到 LINEITEM 中： 清单 55. 说明 1db2 describe data partitions for table LINEITEM show detail 图 29. LINEITEM 表的分区 分区表的访问计划本实验将研究如何在访问计划中描述分区表： 您将更新分区表中的统计信息。 您将使用 db2expln 命令并分析结果。 您将在执行查看的操作中使用 DB2 命令和 SQL 。 对 LINEITEM 表执行RUNSTATS操作： 清单 56. Runstats 1db2 runstats on table db2inst1.lineitem 说明以下 SQL 语句并检查说明输出： 清单 57. 说明 1db2 &quot;select l_shipdate,sum(l_quantity) from LINEITEM group by l_shipdate&quot; 要进行说明的 SQL 位于 EX4-2.sql 文件，可以使用下面的命令运行该文件： 清单 58. 说明输出 1db2expln –d SAMPLE –t –f EX4-2.sql 图 30. 说明输出 注意：该 SQL 执行了 LINEITEM 表的索引扫描。说明输出中有一个关于表分区的要点需要注意，所访问的表是被分区的，并且在扫描过程中所有数据分区都将被访问。 说明下面的 SQL 语句并检查说明输出： 清单 59. 说明 1234db2 &quot;select l_shipdate, l_partkey, l_returnflagfrom LINEITEMwhere l_shipdate between &#x27;01/01/1993&#x27; and &#x27;31/08/1993&#x27;and l_partkey = 49981&quot; 要进行说明的 SQL 语句位于 EX4-3.sql 文件中，可使用下面的命令运行该文件： 清单 60. 说明输出 1db2expln –d SAMPLE –t –f EX4-3.sql 图 31. 说明输出 注意：这个 SQL 语句执行了 LINEITEM 表的索引扫描。在本例中，可以看到优化器能够执行数据分区排除操作。在说明输出中要注意的是关于表分区，访问的表是被分区的，将执行分区排除功能以及删除活动数据分区的值。 在本例中，活动的数据分区为 1-2。这里引用的是 syscat.datapartitions 中的序列号（seqno）而不是describe data partitions命令中的 PartitionId。 使用下面的 SQL 确定在前面说明示例中活动的分区的名称： 清单 61. 说明 123db2 &quot;select seqno,datapartitionnamefrom syscat.datapartitionswhere tabname = ‘LINEITEM’ order by seqno&quot; 图 32. 分区名称 注意：序列号 1 和 2 分别映射的是 JAN1993 和 JULY1993 分区名称。 结束语本教程基于 IBM DB2 9 Data Partitioning 特性。您已在以下几个方面获得了第一手的经验： 如何定义分区表 如何将分区表放置在底层磁盘子系统 如何维护分区表 如何使用 DB2 Explain 说明分区表 范围分区将数据映射到基于关键值范围的分区，用户为每一个分区建立关键值范围。例如，企业通常希望以月份为单位，将销售数据划分到各月的分区中。与 MDC 功能集合使用时，范围分区将更加方便地定位数据，从而加快通过复杂查询检索信息的速度。 下载资源 本文的示例脚本和数据 (exfiles.zip | 60KB) 本文转载自IBM官方网站，原文地址：https://www.ibm.com/developerworks/cn/education/data/dm0612read/dm0612read.html","categories":[{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/categories/DB2/"}],"tags":[{"name":"表分区","slug":"表分区","permalink":"https://born2do.github.io/tags/%E8%A1%A8%E5%88%86%E5%8C%BA/"}],"author":"chenhy"},{"title":"DB2数据库学习_表空间、表分区","slug":"DB2数据库学习-表空间、表分区","date":"2021-05-05T08:28:24.000Z","updated":"2021-05-05T08:28:51.665Z","comments":true,"path":"2021/05/05/DB2数据库学习-表空间、表分区/","link":"","permalink":"https://born2do.github.io/2021/05/05/DB2%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0-%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E8%A1%A8%E5%88%86%E5%8C%BA/","excerpt":"","text":"表空间表空间是数据库系统中数据库逻辑结构与操作系统物理结构之间建立映射的重要存储结构，它作为数据库与实际存放数据的容器之间的中间层，用于指明数据库中数据的物理位置。任何数据库的创建都必须显式或隐式的为其指定表空间，且数据库中的所有数据都位于表空间中。 用户可以根据硬件环境以及成本等需求，通过指定建立在不同容器上的表空间来自由选择数据的物理存储位置。同时由于备份和恢复可以在表空间级别执行，用户能够进行更多粒度的备份恢复控制。 创建一个表之前要给表准备一个容器（Container）来存储表，这个容器就是表空间。 理解表空间前先理解容器。 容器（Container） 容器是物理存储设备，可以通过目录名、设备名或文件名进行标识。事实上，这也正是三种容器类型。设备容器（如磁带等）和文件容器被同等看待，通常直接将其理解为数据文件（磁盘存储内部结构中有介绍，数据文件中包含若干Extent）。系统管理表空间只能使用目录容器，数据库管理表空间只能使用设备容器和文件容器。 容器被分配给某个表空间，单个表空间可以使用多个容器，但容器只能属于一个表空间。也即表空间与容器的映射关系为1:n。但通常都是1:1的映射关系，便于查找和管理。 DB2的表空间按管理方式分为两种： 系统管理表空间（System Managed Space，SMS） 数据库管理表空间（Database Managed Space，DMS） 系统管理表空间（SMS）SMS表空间由操作系统的文件系统管理器分配并管理。在这种表空间中，数据存储空间完全由操作系统管理，SMS表空间能够使用的唯一容器是目录容器，SMS表空间可以定义多个容器，目录容器可以根据需要增加大小，因此SMS表空间的大小是可以动态增加的。但是一旦SMS表空间创建，就不能再为表空间增加或删除容器了。SMS表空间中通常包含多个文件，这些文件代表了存储在文件系统空间中的表对象，比如表数据，表索引，表大对象都是单独占用一个或若干个文件的。一旦为表指定了SMS表空间，那么表中的数据就不允许分开存储，即表的常规数据，索引，大对象数据不能位于不同的表空间中。在DB2 V9之前的数据库版本中，创建数据库（创建数据库时如果不指定表空间则会默认创建3个表空间）或表空间的默认类型就是SMS表空间。 1PS：只有DB2数据库允许有系统管理表空间，Oracle数据库的表空间都是数据库管理的，不存在系统管理表空间。 SMS每个容器是操作系统的文件空间中的一个目录，该目录中， SQL*.DAT数据文件存放表中的常规数据； SQL*.DTR数据文件存放由于重组，表连接等产生的临时数据； SQL*.INX数据文件存放表中的索引； 还有LF后缀的存放LONG VARCHAR或LONG VARGRAPHIC数据，LB后缀的存放BLOB,CLOB和DBLOB数据，LBA后缀的存放LB后缀文件的分配和可用空间信息等。 使用SMS表空间的每一个表都会在表空间的容器（也就是目录）下对应产生一系列的SQL*.DAT,SQL*.INX等文件。表和其对应的文件的信息存放在SYSIBM.SYSTABLES这个系统编目表中，每个表对应一个FID（表所在的文件组编号）和TID（表所在的表空间编号），可以使用查询语句进行查询： 1SELECT FID,TID, NAME FROM SYSIBM.SYSTABLES 数据库管理表空间（DMS）DMS表空间由数据库管理系统（DBMS）自己管理控制，本质上讲，这种类型的表空间是为了最大程度满足数据库管理器的需要而设计并实现的一种特定目的的文件系统。DMS表空间是由有限数量的容器所组成的，DMS表空间可以使用的容器有设备容器和文件容器，这些容器的空间都是在创建时预先分配的。DMS表空间创建时需要手动指定一个或多个容器。以文件为容器的表空间创建完以后就是一个单独的文件。使用DMS表空间的表的数据可以分开存储，即为常规数据，索引和大对象数据指定不同的DMS表空间。 SMS的管理比较简单，由操作系统自动管理，空间大小最数据量的变化由系统自动调整。 DMS是由数据库管理的，空间大小在创建时确定。空间不够时，通过使用 ALTER TABLESPACE 命令来扩展容器。空间多余时，可以释放未使用的那部分 DMS 容器空间（从 V8 开始）。 DMS自动存储表空间（Automatic Storage DMS）自动存储表空间不是真正意义上的独立类型的表空间。它是DMS存储的另外一种处理方法。DMS需要很多的维护操作，而自动存储器则是作为一种简化的空间管理手段，能够自动进行表空间的管理维护，它是DB2 V8.8.2中引入的概念，目前取代SMS成为默认的表空间类型。 三种表空间对比 特性 SMS DMS 自动存储 是否条带化/分段（Strping） 是 是 是 默认类型 Version 8 无 Version 9 对象管理 操作系统 DB2 DB2 空间分配 按需增长/收缩 预先分配；大小可以收缩和增长，但是需要DBA干预 预先分配；可以自动增长 管理的简便性 最好；很少需要调优，甚至不需要调优 好，但是需要一些调优 最好；很少需要调优，甚至不需要调优 性能 不太好 最好，可通过原始容器多获得5%到10%的收益 最好，但是不可以使用原始容器 容器 目录 文件/物理设备 文件/物理设备 表空间最大大小 64GB（4K页面） 2TB（4K页面） 2TB（4K页面） DMS与自动存储DMS那么DMS和自动存储哪种方式更佳呢？自动存储允许 DBA 为数据库设置在创建所有表空间容器时可以使用的存储路径。DBA 不必显式地定义表空间的位置和大小，系统将自动地分配表空间。在 DB2 9 中，数据库在创建时将启用自动存储，除非 DBA 显式地覆盖这个设置。 启用自动存储的数据库有一个或多个相关联的存储路径。表空间可以定义为 “由自动存储进行管理”，它的容器由 DB2 根据这些存储路径进行分配。数据库只能在创建时启用自动存储。对于在最初没有启用自动存储的数据库，不能在以后启用这个特性。同样，对于在最初启用了自动存储的数据库，也不能在以后禁用这个特性。 非自动存储和自动存储之间的一些差异： 特性 非自动存储 自动存储 容器的创建 必须在创建表空间时显示地提供容器。 允许 DBA 为数据库设置在创建所有表空间容器时可以使用的存储路径。不能在创建表空间时提供容器，他们将由DB2自动分配。 容器大小的调整 在默认情况下，表空间大小的自动调整是关闭的（AUTORESIZE NO）。 在默认情况下，表空间大小的自动调整是关闭的（AUTORESIZE YES）。 初始大小 不能使用INITIALSIZE子句指定表空间初始大小 使用INITIALSIZE子句指定表空间初始大小 容器的修改 可以使用 ALTER TABLESPACE语句（ADD、DROP等等）执行容器操作 不能执行容器操作，因为由DB2控制空间管理 管理的便捷性 可以使用重定向的恢复操作重新定义与表空间相关联的容器 不能使用重定向的恢复操作重新定义与表空间相关联的容器，因为由DB2控制空间管理 实操 表空间创建 创建SMS表空间 12CREATE TABLESPACE &lt;NAME&gt;MANEGED BY SYSTEM USING(&#x27;&lt;PATH&gt;&#x27;) 创建DMS表空间 12CREATE TABLESPACE &lt;NAME&gt;MANEGED BY DATABASE USING(FILE &#39;&lt;PATH&gt;&#39; &lt;SIZE&gt;) 创建常规表空间（自动存储DMS） 123CREATE REGULAR TABLESPACE &lt;NAME&gt; -常规表空间名称PAGESIZE 4K -页大小MANEGED BY AUTOMATIC STORAGE -使用自动存储DMS 自定义页大小、容器大小、缓冲池 1234CREATE LARGE TABLESPACE &lt;NAME&gt; -表空间名称PAGESIZE 16K -页大小MANAGED BY DATABASE USING (FILE &#x27;&lt;PATH&gt;&#x27; &lt;CONTAINER_SIZE&gt;) -容器路径及大小BUFFERPOOL &lt;BFP_NAME&gt; -指定缓冲池（已创建） 表空间查看 linux查看表空间使用情况： 1db2 list tablespaces show detail 查看具体表空间： 1db2 list tablespace containers for TablespaceID(具体的id) show detail SQL查看 12SELECT * FROM SYSCAT.TABLESPACES;SELECT TBSPACE, BUFFERPOOLID FROM SYSCAT.TABLESPACES; 表空间修改 12345ALTER TABLESPACE &lt;NAME&gt; EXTEND (ALL CONTAINERS &lt;SIZE&gt;);-增加表空间ALTER TABLESPACE &lt;NAME&gt; REDUCE (ALL CONTAINERS &lt;SIZE&gt;);-减小表空间 ALTER TABLESPACE &lt;name&gt; bufferpool &lt;bfp_name&gt;; --修改表空间缓冲池ALTER TABLESPACE &lt;name&gt; no file system caching; --修改缓存级别 表空间删除 1drop tablespace 表空间名; 表分区表分区是一种数据组织模式，在这种模式中，数据将以一个或多个表列的值为依据，分割到多个称为数据分区（或范围）的存储对象中。每一个数据分区被分别存储。这些存储对象可以位于不同的表空间中，可以位于相同的表空间中，也可能是这两种情况的组合。 DB2 数据库分区是 DB2 企业版 DPF(Data Partitioning Feature)选件提供的，它主要用来个分区（逻辑的或物理的）上分布大型数据库提供了必要的可伸缩性，并利用了一个无共享（shared-nothing）结构。数据库在一个非共享的环境中被分解为独立的分区，每个分区都具有自己的资源，例如内存，CPU 和磁盘以及自己的数据、索引、配置文件和事务日志。数据库分区有时称为节点或数据库节点。通过 DPF“分治”的处理，可伸缩性可在单一服务器（纵向扩展）或跨服务器集群（横向扩展）中获得增强。 使用 DPF最显而易见的理由之一就是提高查询工作负载和 INSERT/UPDATE/DELETE 操作的性能。DPF 还可以克服部分 DB2 的架构限制。例如，在 DB2 中，对 4 KB 的页面大小而言，表的最大大小是 64 GB；对于 8 KB 的页面大小而言，表的最大大小是 128 GB；对于 16 KB 的页面大小而言，表的最大大小是 256 GB；对于 32 KB 的页面大小而言，表的最大大小是 512 GB。在 DB2 中，表和表空间的大小限制是根据每个分区进行规定的。跨多个分区划分数据库将允许您根据环境中分区数目的因数来增加表的最大大小。 DB2数据库分区实例图： 表分区说明在db2数据库中，可对数据表按某个字段进行分区，分区好处是：可扩展表的存储能力、对于大量数据表使用分区字段可提高查询效率。表分区不同于数据库分区，需要在创建表的时候设置分区逻辑。 在定义表分区的字段时，有几个原则： 1.不支持创建只包含长数据类型的多分区表， 2.不能改变分区键定义， 3.分区键应该包含最频繁连接的列， 4.分区键应该由经常参与group by字句的组成， 5.任何主键或唯一键必须包含分区列。 实操 表分区创建 1234567CREATE TABLE TABLE_TEST_HAOTD( DATADATE VARCHAR(8) NOT NULL, DATA1 VARCHAR(10), DATA2 VARCHAR(10) ) PARTITION BY RANGE(DATADATE) (PART &quot;P20180101&quot; STARTING(&#x27;20180101&#x27;) ENDING(&#x27;2018010&#x27;)) 表分区增加 1ALTER TABLE TABLE_TEST_HAOTD ADD PARTITION &quot;P20180102&quot; STARTING &#x27;20180102&#x27; ENDING &#x27;20180102&#x27;; 表分区删除 db2的分区是无法直接删除，要先卸载分区，再进行drop操作。 1ALTER TABLE TABLE_TEST_HAOTD DETACH PARTITION P20180101 INTO TABLE TMP_TESTHAOTD_P20180101 1DROP TABLE TMP_HAOTDTEST_P20180101 表分区查看 1SELECT * FROM SYSCAT.DATAPARTITIONS WHERE TABNAME=&#x27;表名称&#x27; 1db2 describe data partitions for table &lt;tablename&gt; show detail 部分素材来源： https://blog.csdn.net/mydriverc2/article/details/81287476 https://blog.51cto.com/5063935/2074288 https://www.cnblogs.com/haotengda/p/9719729.html","categories":[{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/tags/DB2/"}],"author":"chenhy"},{"title":"VS2019安装包及秘钥","slug":"VS2019安装包及秘钥","date":"2021-05-04T02:07:21.000Z","updated":"2021-05-04T02:08:03.006Z","comments":true,"path":"2021/05/04/VS2019安装包及秘钥/","link":"","permalink":"https://born2do.github.io/2021/05/04/VS2019%E5%AE%89%E8%A3%85%E5%8C%85%E5%8F%8A%E7%A7%98%E9%92%A5/","excerpt":"","text":"VS2019安装包及秘钥链接： https://pan.baidu.com/s/1ufRrlpgh-8ty6VsjOo7JSw 提取码：8v8x Visual Studio 2019?Enterprise 企业版： BF8Y8-GN2QH-T84XB-QVY3B-RC4DF Visual Studio 2019?Professional 专业版： NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y VS2019中，菜单栏-&gt;帮助-&gt;注册产品，，然后输入上方对应版本的激活码。","categories":[{"name":"LICENSE ","slug":"LICENSE","permalink":"https://born2do.github.io/categories/LICENSE/"}],"tags":[],"author":"chenhy"},{"title":"Sublime LICENSE","slug":"Sublime-LICENSE","date":"2021-05-04T02:05:11.000Z","updated":"2021-05-04T02:06:55.322Z","comments":true,"path":"2021/05/04/Sublime-LICENSE/","link":"","permalink":"https://born2do.github.io/2021/05/04/Sublime-LICENSE/","excerpt":"","text":"Sublime LICENSE12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 声明一下，不确定是否还有用了。","categories":[{"name":"LICENSE","slug":"LICENSE","permalink":"https://born2do.github.io/categories/LICENSE/"}],"tags":[],"author":"chenhy"},{"title":"牛客网数据库刷题笔记","slug":"牛客网数据库刷题笔记","date":"2021-05-02T23:24:42.000Z","updated":"2021-05-02T23:25:19.975Z","comments":true,"path":"2021/05/03/牛客网数据库刷题笔记/","link":"","permalink":"https://born2do.github.io/2021/05/03/%E7%89%9B%E5%AE%A2%E7%BD%91%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一星题 日志文件用来记录对数据库中数据进行的每一次更新操作。 索引是在基本表的列上建立的一种数据库对象，它同基本表分开存储，使用它能够加快数据的（查询）速度。 where子句后不能放聚合函数。 用二维表来表示实体集及实体集之间联系的数据模型称为关系模型。 数据库系统与文件系统的主要区别是：文件系统不能解决数据冗余和数据独立性问题，而数据库系统可以解决。 数据库管理系统DBMS是系统软件。 数据库系统一般由数据库、数据库管理系统（DBMS）、应用系统、数据库管理员和用户构成。DBMS是数据库系统的基础和核心。 MySQL忘记root密码，不管哪种解决方案，最终都要实现更新mysql数据库下的user表。 SQL 采用集合操作方式。 概念模型是用于信息世界的建模，与具体的 DBMS 无关。 数据库系统不仅包括数据库本身,还要包括相应的硬件、软件和各类相关人员。 在Access数据库的表设计器中可以修改字段类型、设置索引和增加字段。要想删除表中的记录，需要打开表进行删除。 SQL支持的备份类型有四种： 完全数据库备份 差异备份或称增量备份 事务日志备份 数据库文件和文件组备份 串行读(Serializable):完全串行化的读,每次读都需要获得表级共享锁,读写相互都会阻塞 未提交读(Read Uncommitted):允许脏读,也就是可能读取到其他会话中未提交事务修改的数据 提交读(Read Committed):只能读取到已经提交的数据 可重复读(Repeated Read):在同一个事务内的查询都是事务开始时刻一致的 数据库分类： Mongodb数据库属于文档型非关系数据库 PostgreSQL属于关系型数据库 Redis属于KV键值数据库 Hbase属于列数据库 在手机开发中常用的数据库是sqlLite。 关系模型中，一个关键字，可由一个或多个其值能惟一标识该关系模式中任何元组的属性组成。 在合并分E-R图时必须消除各分图中的不一致。各分E-R图之间的冲突主要有三类，即属性冲突、命名冲突和结构冲突，其中命名冲突是指同名异义或同义异名。 在数据系统中，对存取权限的定义称为授权。 索引的描述存放在数据字典中。 SQL语言具有两种使用方式，分别称为交互式SQL和嵌入式SQL。 数据库的物理结构设计的目的是：找到一个有效、可实现的数据库存储结构。 （1）若视图的字段是来自字段表达式或常数，则不允许对此视图执行INSERT、UPDATE操作，允许执行DELETE操作；（2）若视图的字段是来自库函数，则此视图不允许更新；（3）若视图的定义中有GROUP BY子句或聚集函数时，则此视图不允许更新；（4）若视图的定义中有DISTINCT任选项，则此视图不允许更新；（5）若视图的定义中有嵌套查询，并且嵌套查询的FROM子句中涉及的表也是导出该视图的基表，则此视图不允许更新；（6）若视图是由两个以上的基表导出的，此视图不允许更新；（7）一个不允许更新的视图上定义的视图也不允许更新；（8）由一个基表定义的视图，只含有基表的主键或候补键，并且视图中没有用表达式或函数定义的属性，才允许更新。 相对于非关系模型，关系数据模型的缺点之一是：存取路径对用户透明，需查询优化。 一个关系数据库文件中的各条记录，前后顺序可以任意颠倒，不影响库中的数据关系。 不借助第三方工具，通过explain plan查看SQL的执行计划。 数据库的网状模型应满足的条件是：允许一个以上结点无双亲，也允许一个结点有多个双亲。 数据库并发操作带来的数据不一致性包括丢失修改、不可重复读、读“脏”数据。 事务四大特性(简称ACID) 1、原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。2、一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。3、隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。4、持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障。 左连接时，结果集的行数可能大于左表的行数。 解释：如果 left join on的条件在右表中有所重复，那么最终记录数目会大于原表数量。 创建表：CREATE TABLE 创建视图：CREATE VIEW 创建索引：CREATE INDEX CREATE SCHEMA 是 CREATE DATABASE 的一个代名词。 子模式DDL用来描述，数据库的局部逻辑结构。 SQL语言是（非过程化）的语言。 1.等值连接，在两个表中的广义笛卡尔积中选取属性值相等的元组 2.自然连接（特殊的等值连接），在等值连接的基础上去掉重复项 3.外连接分为左外连接右外连接 注：等值连接需要标出具体哪个元组相等 对数据表进行修改时，删除列可以省略column，添加列必须说明数据类型。 alter table employee drop column age; alter table employee drop age; 关系模型的三个组成部分，是指关系数据模型的数据结构、数据操作和完整性约束。 存储过程的好处：重复使用、SQL优化、更加安全。 并发控制指的是当多个用户同时更新运行时，用于保护数据库完整性的各种技术。 DCL(数据控制语言)：grant revoke DML(数据操纵语言)：insert delete update select DDL(数据定义语言)：create drop alter TCL(事物控制语言)：commit rollback 物理独立性是指用户的应用程序与存储在磁盘上的数据库中数据是相互独立的。 逻辑独立性是指用户的应用程序与数据库的逻辑结构是相互独立的。 在数据库系统中，外模式/模式映象保证数据的逻辑独立性，模式/内模式映象保证数据的物理独立性。 对于串行调度，各个事务的操作没有交叉，也就没有相互干扰，当然也不会产生并发所引起的。事务对数据库的作用是将数据库从一个一致的状态转变为另一个一致的状态。多个事务串行执行后，数据库仍旧保持一致的状态。 可串行性(Serializability) 是并发事务正确调度的准则。在RDBMS中，作为并发控制的正确性准则。一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。 聚合函数MAX(＜列名＞)用于求某一列值的最大值，它对列名不限制数据类型。 数据库保护又叫做数据库控制，是通过四方面实现的，即安全性控制、完整性控制、并发性和数据恢复。 第一范式（1NF）：强调的是列的原子性，即列不能够再分成其他几列。 第二范式（2NF）：首先是1NF，另外包含两部分内容，一是表必须有一个主键；二是没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 第三范式（3NF）：首先是 2NF，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。 第二范式（2NF）和第三范式（3NF）的概念很容易混淆，区分它们的关键点在于，2NF：非主键列是否完全依赖于主键，还是依赖于主键的一部分；3NF：非主键列是直接依赖于主键，还是直接依赖于非主键列。 （1）实体类型的转换将每个实体类型转换成一个关系模式，实体的属性即为关系的属性，实体标识符即为关系的键。（2）联系类型的转换1）实体间的联系是1:1，可以在两个实体类型转换成两个关系模式中的任意一个关系模式的属性中加入另一个关系模式的键和联系类型的属性。2）实体间的联系是1:N，则在N端实体类型转换成的关系模式中加入1端实体类型转换成的关系模式的键和联系类型的属性。3）实体间的联系是M:N，则将联系类型也转换成关系模式，其属性为两端实体类型的键加上联系类型的属性，而键为两端实体键的组合。 注意：一对一关系，一对多关系不需要新表。 两星题 为了反映事物本身及事物之间的联系，数据库中的数据必须有一定的结构，这种结构用数据模型来表示，一个具体的数据模型应当正确地反映出数据之间存在的整体逻辑关系，所以数据模型质量的高低直接影响数据库性能的好坏。 共享锁：是非独占的，允许其他事物同时读取其锁定的资源（也可再加共享锁），但不允许修改。 独占锁（即排他锁）：只能自己使用，不允许其他事物读取和修改。 如果想使用NULL，则需要使用IS NULL或者IS NOT NULL。如果将NULL与比较运算符，则结果都是NULL。 在使用limit子句时，如果没有足够的行，MySQL将只返回它能返回的那么多行。 数据库的基本特点是： （1）数据可以共享（或数据结构化） （2）数据独立性（3）数据冗余小，易扩充 （4）统一管理和控制 数据库是按照一定的数据模型组织的，长期存储在计算机内，可为多个用户共享的数据的聚集。 选择是将表进行水平分割的运算，其目的是为了保留某些符合条件的元组。投影是对表进行垂直分割的运算，其目的是实现属性的筛选。 关系的描述称为关系模式。对关系的描述，一般表示为：关系名（属性1，属性2…..属性n）。例如：课程(课程号、课程名称、学分、任课老师) 限制输入到列的值的范围，应使用CHECK约束。 外键中的属性允许为null，只要没有被声明为not null。 在数据库的安全控制中，为了保证用户只能存取他有权存取的数据，在授权的定义中数据对象的（范围越小），授权子系统就越灵活 。 在嵌入式 SQL 中，当 SQL 语句中引用宿主语言的程序变量时，程序变量应（加前缀:）。 “元组”所表达的概念与二维表的”行”的概念最接近。 数据库系统包括数据库和数据库管理系统 [数据库系统&gt;数据库管理系统&gt;数据库]。 实体完整性指表中行的完整性 域完整性指列的值域的完整性，如数据类型、格式、值域范围、是否允许空值等等 参照完整性基于外键与被引用主键之间的关系，确保键值在所有表中的一致性 数据库管理员（Database Administrator，简称DBA），是从事管理和维护数据库管理系统(DBMS)的相关工作人员的统称，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。 关系术语 一般表格的术语 关系名 表名 关系模式 表头（表格的描述） 关系 一张二维表 元组 记录或行 属性 列 属性名 列名 属性值 列值 分量 一条记录中的一个列值 非规范关系 大表中嵌着小表 外模式又称子模式，对应于用户级。外模式反映了数据库的用户观。内模式又称存储模式，对应于物理级，它是数据库中全体数据的内部表示或底层描述,它是数据库的存储观模式又称概念模式或逻辑模式，对应于概念级.反映了数据库系统的整体观 SQL语句关键字顺序为：select, from, where, group by, having, order by, limit where增加分组前的限定，having增加分组后的限定 group by 通常和集合函数SUM()，AVG()，MAX()，MIN()，COUNT()等结合在一起，后接限制条件语句 having,不可用where语句！ 数据库常用的关系运算有三种 1、选择 从二维表中选出符合条件的记录，它是从行的角度对关系进行运算 2、投影，从二维表中选出所需要的列，它是从列的角度对关系进行运算：从关系中挑选出指定的属性组成新关系的运算 3、连接，同时涉及到两个二维表的运算，它是将两个关系在给定的属性上满足一定条件的记录连接起来 从而得到一个新的关系 聚集索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序。 非聚集索引：数据存储在一个地方，索引存储在另一个地方，索引带有指针指向数据的存储位置。 一个表只能有一个聚集索引和多个非聚集索引。 按所使用的数据模型来分，数据库可分为三种模型：层次、关系和网状。 在数据库中存储的是数据以及数据之间的联系。 数据库系统的数据独立性体现在不会因为数据存储结构与数据逻辑结构的变化而影响应用程序。 丢失更新：当两个或多个事物读入同一数据并修改，会发生丢失更新问题，即后一个事物更新的结果被前一事务所做更新覆盖 即当事务A和B同事进行时，事务A对数据已经改变但并未提交时B又对同一数据进行了修改（注意此时数据是A还未提交改变的数据），到时A做的数据改动丢失了 读‘脏数据’：指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 不可重复读：这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 幻读：幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检索范围为只读，这样就避免了幻读。 按照规范的设计方法，一个完整的 数据库设计 一般分为以下六个阶段：⑴需求分析：分析用户的需求，包括数据、功能和性能需求；⑵概念结构设计：主要采用E-R模型进行设计，包括画E-R图；⑶逻辑结构设计：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；进行关系规范化。⑷数据库物理设计：主要是为所设计的数据库选择合适的存储结构和存取路径；⑸数据库的实施：包括编程、测试和试运行；⑹数据库运行与维护：系统的运行与数据库的日常维护。 数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据包括：日志文件、数据库后备副本。 数据库中，optimize table TabName;命令可以整理表数据文件的碎片。 对数据库中表的字段进行相关操作时，添加时column可以省略，删除时column不能省略。 1ALTER TABLE tableName DROP COLUMN columnName; 1ALTER TABLE tableName ADD columnName; 三星题 1）候选键： 关系中的一个属性组，其值能唯一标识一个元组，若从该属性组中去掉任何一个属性，它就不具有这一性质了。（即该属性组内不应该存在一个真子集也能标识一个元组）。这样的属性组称作候选码。 2）主键：当有多个候选码时，可以选定一个作为主码，选定的候选码称主键 3）外键：关系R中的一个属性组，它不是R的候选码，但它与另一个关系S的候选码相对应，则称这个属性组为R的外码或外键。 候选码可以唯一标识一个实体，可以有一个或者多个。 主码唯一且非空，也是唯一标识一个实体的码。 如果候选码有多个，可以从中选定一个主码。 模式：只能有一个 内模式：只能有一个 外模式：任意多个 索引类型分类： 普通索引：没有任何限制 唯一索引：不允许建立索引的列有重复的值，但可以有空值 主索引：特殊的唯一索引，不允许有空值 候选索引：也要求唯一性，一个表中可以有多个候选索引 视图设计的几种方法： 自顶向下。先全局框架，然后逐步细化 自底向上。先局部概念结构，再集成为全局结构 由里向外。先核心结构，再向外扩张 混合策略。1与2相结合，先自顶向下设计一个概念结构的框架，再自底向上为框架设计局部概念结构 对于各种范式之间的关系如下： 5NF⊂ 4NF⊂ BCNF ⊂3NF ⊂ 2NF⊂ 1NF 等值连接是从关系R和S的广义笛卡尔积中选取A和B“属性值”相等的元组，所以只要两个关系里面的有元组属性值相等就可以进行 自然连接是要求R和S中有一个或者多个相同的属性组 3NF——只消除非主属性对主属性的传递依赖BCNF——消除所有属性对主属性的传递依赖 为了提高数据库的性能，需要针对系统设计基准测试进行压力测试，那么进行压力测试时需要考虑以下指标： 响应时间 并发性 吞吐量 关系运算中花费时间可能最长的运算是笛卡尔积。 数据库对象的四种视图模式：详细模式，小图标，大图标，列表。 WITH CHECK OPTION 用于限制视图，通过视图进行修改时，必须要能通过该视图看到修改后的结果，即对其的修改要再次满足查询中的条件。 若数据库中只包含成功事务提交的结果，则此数据库就称为处于(一致)状态。 ACCESS的字段属性，定义字段默认值的含义是该字段值不允许为空。 SQL结构化查询语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。 规范化过程主要为克服数据库逻辑结构中的插入异常、删除异常以及（冗余度大）的缺陷。 关于oracle系统进程和作用的描述： 数据写进程(dbwr)：负责将更改的数据从数据库缓冲区高速缓存写入数据文件 监控进程(pmon) ：负责在一个 Oracle 进程失败时清理资源 归档进程(arcn) ：在每次日志切换时把已满的日志组进行备份或归档 系统监控(smon) ：检查数据库的一致性，如有必要还会在数据库打开时启动数据库的恢复 概念模型是现实世界的第一层抽象，这一类模型中最著名的模型是实体-联系模型。 数据库技术的根本目标是要解决数据共享的问题。 ORDB（对象关系数据库）中，同类元素的无序集合，并且允许一个成员可多次出现，称为多集类型。 复合类型有下列五种: 1.结构类型: 不同类型元素的有序集合。 2.集合类型: 相同类型元素的无序集合，并且所有的元素必须是不同的。 3.数组类型: 同类元素的有序集合。 4.多集类型: 同类元素的无序集合并且允许有重复的元素。 (5.列表类型: 类型相同并且允许有重复的元素的有序集合。) 数据库管理系统的主要功能是定义数据库。 在使用left jion时，on和where条件的区别如下： on条件是在生成临时表时使用的条件，它不管on中的条件是否为真，都会返回左边表中的记录。 where条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有left join的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。 四星题 约束主要有一下几种: NOT NULL : 用于控制字段的内容一定不能为空（NULL）。 UNIQUE : 控制字段内容不能重复，一个表允许有多个 Unique 约束。 PRIMARY KEY: 也是用于控制字段内容不能重复，但它在一个表只允许出现一个。 FOREIGN KEY: FOREIGN KEY 约束用于预防破坏表之间连接的动作，FOREIGN KEY 约束也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。 CHECK: 用于控制字段的值范围。 DEFAULT: 用于设置新记录的默认值。 共享锁（S锁）：读锁，可查看但无法修改和删除，已加该锁则其他事务只能加S锁；排他锁（X锁）：写锁、独占锁，可写可读，已加该锁则其他事务不能再加任何类型的锁。 RDBMS 是SQL的基础，同样也是所有现代数据库系统的基础，比如MS SQL Server, IBM DB2, Oracle, MySQL以及Microsoft Access。 hadoop是分布式数据库。 Access的数据库对象：1、表，主要用于存储数据。2、查询，主要用于提取数据。3、窗体，用户与程序的交互。4、报表，主要用于展示数据。5、页，主要用于数据共享。6、宏，用于自动化完成。 候选码中属性称为主属性。 数据流程图（DFD）是用于描述结构化方法中（需求分析）阶段的工具。 sql注入中使用延时注入时常用的语句： 数据库 延时注入语句 MySQL 1. benchmark(100000000,md5(1)) 2. sleep(5) Postgresql 1. pg_sleep(5) 2. generate_series(1,10000) Microsoft Sql Server waitfor delay ‘0:0:5’ 事务是 DBMS 的基本单位，它是用户定义的一组逻辑一致的程序序列。 左联结，返回左表中所有记录及右表中联结字段相同的记录。 同理，右联结，返回右表中所有纪录及左表中联结字段相同的记录。 内部联结，只返回两个表联结字段相同的记录。 A INNER JOIN B：返回A和B中符合on条件式的记录 A LEFT JOIN B:返回A中的所有记录和B中符合on条件式的记录 A RIGHT JOIN B：返回B中的所有记录和A中符合on条件式的记录 关系规范化中的4个问题： 数据冗余，浪费很大的存储空间。 更新异常，由于数据冗余，当更新数据库中的数据时，系统要付出很大的代价来维护数据库的完整性，否则会面临数据不一致的危险。 插入异常，应该插入的数据未被插入 删除异常，不该删除数据的被删除 HAVING子句中应后跟（组条件表达式）。 在进行数据库逻辑设计时，可将E-R图中的属性表示为关系模式的属性，实体表示为元组，实体集表示为关系，联系表示为关系。 E-R图 关系模式 属性 属性 实体 元组 实体集 关系 联系 关系 关系型数据库：Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL非关系型数据库：NoSql、Cloudant、MongoDb、redis、HBase OverPS：原文档丢失了，恢复回来的就只有这些了。当文档内容被自己亲手覆盖，真的是心痛到无法呼吸，差点就自闭了。想剁了自己的右手，是他点击了“确定”，蓝瘦、香菇。一周的心血毁于一旦，也让我也体会到了，在工作中，一定要细心，有些操作是无法挽回的，造成的后果是可怕的。在细心工作中逐步提高效率，细心、安全是前提。","categories":[{"name":"刷题","slug":"刷题","permalink":"https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"}],"tags":[],"author":"chenhy"},{"title":"Eclipse、spring插件及反编译插件安装","slug":"Eclipse、spring插件及反编译插件安装","date":"2021-05-02T23:18:41.000Z","updated":"2021-05-02T23:19:13.680Z","comments":true,"path":"2021/05/03/Eclipse、spring插件及反编译插件安装/","link":"","permalink":"https://born2do.github.io/2021/05/03/Eclipse%E3%80%81spring%E6%8F%92%E4%BB%B6%E5%8F%8A%E5%8F%8D%E7%BC%96%E8%AF%91%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/","excerpt":"","text":"请提前下载好必要文件，该文主要介绍离线安装。 Eclipse安装根据自己的操作系统以及想要的eclipse版本，在eclipse官网下载软件压缩包。 下载地址：https://www.eclipse.org/downloads/packages/ 下载完成后，解压到本地磁盘即可直接使用。 反编译插件安装下载地址：http://java-decompiler.github.io/ 安装 将下载好的压缩包解压缩。 打开eclipse，Help-&gt;Install New Software…-&gt;add。 选中插件，点击“next”。 一直点击下一步即可。最终安装完成后会提醒重启eclipse，重启就好。 重启后，再次确认jd插件安装成功。Window-&gt;Preference-&gt;Java-&gt;Decompiler，出现JD-eclipse说明安装成功。 最后，进行查看器默认设置修改。直接在左上角搜索“File Associations”，选中“.class without resource”，点击下方的add，找到“JD Class File Viewer”，确认即可。 至此，反编译插件安装完成。 Spring插件安装下载 查看eclipse版本。Help-&gt;About Eclipse IDE，我的版本是4.14.0。 https://github.com/spring-projects/toolsuite-distribution/wiki/Spring-Tool-Suite-3，找到版本对应的Spring Tool Suite 3，并下载。 安装步骤与反编译插件的安装步骤一致，但是要注意，需要联网，安装时会从网络上再次更新下载部分组件，没有联网的，即使安装完了，也是不完整的，无法使用。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[],"author":"chenhy"},{"title":"Intellij配置","slug":"Intellij配置","date":"2021-05-02T23:17:46.000Z","updated":"2021-05-02T23:18:08.427Z","comments":true,"path":"2021/05/03/Intellij配置/","link":"","permalink":"https://born2do.github.io/2021/05/03/Intellij%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Intellij配置主题设置File | Settings | Appearance &amp; Behavior | Appearance 字体设置File | Settings | Editor | Font 快捷键设置File | Settings | Keymap 大小写敏感设置File | Settings | Editor | General | Code Completion 关闭大小写敏感。 MAVEN设置文件编码格式设置File | Settings | Editor | File Encodings","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[],"author":"chenhy"},{"title":"【MySQL】The MySQL server is running with the --skip-grant-tables option so it cannot execute this ...","slug":"【MySQL】The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this","date":"2021-05-02T00:04:45.000Z","updated":"2021-05-02T00:05:20.689Z","comments":true,"path":"2021/05/02/【MySQL】The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/","link":"","permalink":"https://born2do.github.io/2021/05/02/%E3%80%90MySQL%E3%80%91The-MySQL-server-is-running-with-the-skip-grant-tables-option-so-it-cannot-execute-this/","excerpt":"","text":"问题描述：新建数据库用户： 1create user test identified by &#39;password&#39;; 然后便报错： “ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement” 解决方法：刷新权限表 1flush privileges; 再重新新建用户即可。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/categories/MySQL/"}],"tags":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"}],"author":"chenhy"},{"title":"【Java】Java中子类可以继承父类所有的属性和方法","slug":"【Java】Java中子类可以继承父类所有的属性和方法","date":"2021-05-02T00:03:51.000Z","updated":"2021-05-02T00:04:12.722Z","comments":true,"path":"2021/05/02/【Java】Java中子类可以继承父类所有的属性和方法/","link":"","permalink":"https://born2do.github.io/2021/05/02/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E5%AD%90%E7%B1%BB%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%88%B6%E7%B1%BB%E6%89%80%E6%9C%89%E7%9A%84%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95/","excerpt":"","text":"某些书本表明“子类只能继承父类的非私有属性和方法”，然而事实并非如此，实际上“Java中子类可以继承父类所有的属性和方法”，只不过因为私有的原因，子类不能调用父类的私有方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//父类public class Father &#123; private String name = &quot;张三&quot;;//私有属性 private String sex = &quot;男&quot;; public void tell()&#123; System.out.println(&quot;姓名：&quot;+name); System.out.println(&quot;性别：&quot;+sex); &#125; private void speak()&#123; System.out.println(name+&quot;is speaking!&quot;); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125;&#125;//子类public class Child extends Father &#123;&#125;//测试类public class TestJava &#123; public static void main(String[] args) &#123; Child c = new Child(); c.tell();// tell方法是可以用的 // c.speak();//报错，父类的私有方法不可见 &#125;&#125; 可以看到测试类中即使没有给Child类对象的属性进行赋值，tell方法依旧是可用的。如果Child类中没有继承父类的私有属性，那么tell方法应该会报错。由此得出的结论是，子类会继承父类的所有东西，而修饰符只是影响属性或者方法对外是否可见。 Java官方文档的解释：子类不能继承父类的私有属性，但是如果子类中公有的方法影响到了父类私有属性，那么私有属性是能够被子类使用的。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"}],"author":"chenhy"},{"title":"【Java】String、StringBuffer、StringBuilder有什么区别","slug":"【Java】String、StringBuffer、StringBuilder有什么区别","date":"2021-04-30T23:09:06.000Z","updated":"2021-04-30T23:10:26.429Z","comments":true,"path":"2021/05/01/【Java】String、StringBuffer、StringBuilder有什么区别/","link":"","permalink":"https://born2do.github.io/2021/05/01/%E3%80%90Java%E3%80%91String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"String在Java中，String类用于用于创建和操作字符串。String 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，在这里不作赘述。但值得注意的是，String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了。 12345String s = &quot;Google&quot;;System.out.println(&quot;s = &quot; + s);s = &quot;Baidu&quot;;System.out.println(&quot;s = &quot; + s); 上段代码的运行结果如下： 12s = Googles = Baidu 看似String类是可以改变的，那为什么又说String类是不可改变的呢？ 答：在这里的变量s，并非String对象，而是指向对象地址的引用。变量s存储在栈空间，而真正的对象存储在堆空间。 在执行上图中的两句代码时，堆空间实际上创建了两个对象，变量s改变的是内存中对象的地址，第一个对象的内容并未发生改变，最后也会被垃圾回收机制回收内存。所以说，String 类是不可改变的，你一旦创建了 String 对象，那它的值就无法改变了。对了，String 是被 final 修饰的，他的长度是不可变的。 StringBuffer、StringBuilder当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。 和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。 StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。 由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。 三者在执行速度方面的比较：StringBuilder &gt; StringBuffer &gt; String 如何正确地、适当地使用这三个类： 如果要求字符串不可变，操作少量数据，那么应该选择String类 如果需要字符串可变并且是线程安全的，操作大量数据，那么应选择StringBuffer类 如果要求字符串可变并且不存在线程安全问题，操作大量数据，那么应选择StringBuilder类","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"String","slug":"String","permalink":"https://born2do.github.io/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://born2do.github.io/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://born2do.github.io/tags/StringBuilder/"}],"author":"chenhy"},{"title":"解决CHM文件打不开或者打开以后显示空白","slug":"解决CHM文件打不开或者打开以后显示空白","date":"2021-04-30T23:04:57.000Z","updated":"2021-04-30T23:05:13.755Z","comments":true,"path":"2021/05/01/解决CHM文件打不开或者打开以后显示空白/","link":"","permalink":"https://born2do.github.io/2021/05/01/%E8%A7%A3%E5%86%B3CHM%E6%96%87%E4%BB%B6%E6%89%93%E4%B8%8D%E5%BC%80%E6%88%96%E8%80%85%E6%89%93%E5%BC%80%E4%BB%A5%E5%90%8E%E6%98%BE%E7%A4%BA%E7%A9%BA%E7%99%BD/","excerpt":"","text":"CHM是英语“Compiled Help Manual”的简写，即“已编译的帮助文件”。CHM是微软新一代的帮助文件格式，利用HTML作源文，把帮助内容以类似数据库的形式编译储存。 从网络上下载了chm格式的帮助文档，但是无法打开。经过一番搜索，完美解决。解决方式如下： 文件之所以打不开或者打开后显示空白，是因为该文件被加锁了，解锁即可。 右键chm文件-&gt;属性-&gt;勾选“解除锁定”-&gt;应用即可。","categories":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"}],"tags":[],"author":"chenhy"},{"title":"【Windows】Windows环境生成树形目录结构","slug":"【Windows】Windows环境生成树形目录结构","date":"2021-04-30T10:03:37.000Z","updated":"2021-04-30T10:04:35.671Z","comments":true,"path":"2021/04/30/【Windows】Windows环境生成树形目录结构/","link":"","permalink":"https://born2do.github.io/2021/04/30/%E3%80%90Windows%E3%80%91Windows%E7%8E%AF%E5%A2%83%E7%94%9F%E6%88%90%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/","excerpt":"","text":"123456以图形显示驱动器或路径的文件夹结构。TREE [drive:][path] [/F] [/A] /F 显示每个文件夹中文件的名称。 /A 使用 ASCII 字符，而不使用扩展字符。 实例： 1tree D:\\backup\\软件 /F &gt; tree.txt 执行tree命令，并将结果重定向到 tree.txt 。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/categories/Windows/"}],"tags":[{"name":"树形目录结构","slug":"树形目录结构","permalink":"https://born2do.github.io/tags/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"}],"author":"chenhy"},{"title":"解决从github下载项目速度过慢或下载失败","slug":"解决从github下载项目速度过慢或下载失败","date":"2021-04-30T10:02:31.000Z","updated":"2021-04-30T10:03:10.628Z","comments":true,"path":"2021/04/30/解决从github下载项目速度过慢或下载失败/","link":"","permalink":"https://born2do.github.io/2021/04/30/%E8%A7%A3%E5%86%B3%E4%BB%8Egithub%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E9%80%9F%E5%BA%A6%E8%BF%87%E6%85%A2%E6%88%96%E4%B8%8B%E8%BD%BD%E5%A4%B1%E8%B4%A5/","excerpt":"","text":"有时候从github上下载个项目或是文件，几兆大小却花费十几分钟，速度低到极致。遇上个稍微大点的项目，运气好的下载半天好歹给你下载下来了，运气差点的下载到一半甚至90%就给你中止了，提示你网络已断开，你说气人不。 说到底还是因为那堵墙，不做过多评论。 直接来干货：将存储于github上的项目克隆到gitee上即可。 Gitee （中文名：码云 ，原名 Git@OSC ）是开源中国推出的基于 Git 的代码托管服务。因为服务器在国内，速度可不是github能比拟的。 1.打开码云（https://gitee.com/），注册并登录。 2.创建仓库。 3.在新建仓库页选择 “导入已有仓库”。 4.复制需要下载的github项目的链接，如https://github.com/lehaifeng/T-GCN.git放到导入已有仓库中。 5.点击创建，然后下载即可。 说明：有些项目在gitee上已经有过的，克隆会比较快，但如果是新项目，会稍稍耗时，但总比我们自己下载要来得快，耐心等待即可。 图片来自：https://www.cnblogs.com/USTC-ZCC/p/11163292.html","categories":[{"name":"下载","slug":"下载","permalink":"https://born2do.github.io/categories/%E4%B8%8B%E8%BD%BD/"}],"tags":[{"name":"github","slug":"github","permalink":"https://born2do.github.io/tags/github/"}],"author":"chenhy"},{"title":"localhost、127.0.0.1和本机IP之间的区别","slug":"localhost、127-0-0-1和本机IP之间的区别","date":"2021-04-29T12:44:10.000Z","updated":"2021-04-29T12:44:36.022Z","comments":true,"path":"2021/04/29/localhost、127-0-0-1和本机IP之间的区别/","link":"","permalink":"https://born2do.github.io/2021/04/29/localhost%E3%80%81127-0-0-1%E5%92%8C%E6%9C%AC%E6%9C%BAIP%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"1、localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在操作系统支持 IPv6 后，它同时还指向 IPv6 的地址 [::1] 。 2、127.0.0.1 是一个IP地址，这个地址通常分配给 loopback 接口。loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间的网络交互。只要操作系统的网络组件是正常的，loopback 就能工作。 3、本机IP，确切地说，“本机地址”并不是一个规范的名词。通常情况下，指的是“本机物理网卡所绑定的网络协议地址”。由于目前常用网络协议只剩下了IPv4，IPX/Apple Tak消失了，IPv6还没普及，所以通常仅指IP地址甚至IPv4地址。 4、一般情况下，localhost指向127.0.0.1，无需联网，供本机访问；而本机IP需要联网，供本机或外部访问。","categories":[{"name":"IP","slug":"IP","permalink":"https://born2do.github.io/categories/IP/"}],"tags":[],"author":"chenhy"},{"title":"【Linux】Linux、Unix环境下的环境变量设置","slug":"【Linux】Linux、Unix环境下的环境变量设置","date":"2021-04-29T12:42:38.000Z","updated":"2021-04-29T12:43:03.289Z","comments":true,"path":"2021/04/29/【Linux】Linux、Unix环境下的环境变量设置/","link":"","permalink":"https://born2do.github.io/2021/04/29/%E3%80%90Linux%E3%80%91Linux%E3%80%81Unix%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"12345例1. export JAVA_HOME=&quot;/var/java/lib&quot;例2. export PATH=$&#123;PATH&#125;:/var/java/lib 说明： 1、如果是系统已有变量（如PATH），那么采用例2的连接方法。在原有路径后添加新路径，如果不连接原来的${PATH}，那么原有的PATH将被覆盖，后果很严重。 2、如果是新设置的变量，则按例1设置。 3、变量名和变量值之间的等号两侧不能有空格，否则报错! 4、等号右侧的变量值可以加双引号(例1)也可以不加(例2)。 5、特殊字符简介。 123export a=/a/img:aa/imgexport B=.:/xiaomi/xiaoaiexport A=/ca/car:$A : 表示并列含义，例如变量值有多个，用:符号进行分隔。 . 表示你操作的当前目录。 $ 表示引用已定义好的变量的值。 6、set命令，显示所有本地定义的shell变量。 7、常见的环境变量 PATH:决定了shell将到哪些目录中寻找命令或程序 HOME:当前用户主目录 HISTSIZE:是指保存历史命令记录的条数 LOGNAME:是指当前用户的登录名","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"环境变量","slug":"环境变量","permalink":"https://born2do.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"}],"author":"chenhy"},{"title":"【Linux】Linux上的tar包拿到Windows下解压缩后新增了PaxHeaders文件夹以及其他文件","slug":"【Linux】Linux上的tar包拿到Windows下解压缩后新增了PaxHeaders文件夹以及其他文件","date":"2021-04-28T14:23:06.000Z","updated":"2021-04-28T14:29:27.088Z","comments":true,"path":"2021/04/28/【Linux】Linux上的tar包拿到Windows下解压缩后新增了PaxHeaders文件夹以及其他文件/","link":"","permalink":"https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91Linux%E4%B8%8A%E7%9A%84tar%E5%8C%85%E6%8B%BF%E5%88%B0Windows%E4%B8%8B%E8%A7%A3%E5%8E%8B%E7%BC%A9%E5%90%8E%E6%96%B0%E5%A2%9E%E4%BA%86PaxHeaders%E6%96%87%E4%BB%B6%E5%A4%B9%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6/","excerpt":"","text":"背景 公司项目架构升级，服务器由AIX迁移到了Linux。由硬件差异导致了一系列问题。其中之一就是，本地生成tar包送达目标系统后，无法在目标系统前台查看全部文件，部分文件下载后显示文件损坏。 排查1.我们项目近期并未改动代码，排除项目源代码问题。2.目标系统近期并未对我方系统送达的文件进行加载策略的更改，排除目标系统的问题。3.既然出发地与目的地均无问题，那就只能是文件的问题或是传输过程中出现问题。 为保证万无一失，我们在新老系统切换时，进行了一个并行运行的操作，一旦出问题，切换到老系统。而这也为我们查找问题提供了依据。 4.原AIX生成的文件大小与新Linux生成的文件大小存在差异。但是在服务器上解压缩后，文件却又是一样的，真的头大了。5.将目标系统的文件拿到Windows服务器下使用7z进行解压缩后发现，莫名多出了几个文件、文件夹。而这个多出的文件夹下的文件的名称与外层的文件名称完全相同，那就有可能是文件加载的问题了。将PaxHeaders下的文件使用notepad++打开后发现是atime、mtime、ctime，相当于文件的元信息。| 简名 | 全名 | 中文名 | 含义 || —– | ———– | ——– | —————————————- || atime | access time | 访问时间 | 文件中的数据库最后被访问的时间 || mtime | modify time | 修改时间 | 文件内容被修改的最后时间 || ctime | change time | 变化时间 | 文件的元数据发生变化。比如权限，所有者等 |6.从目标系统前台下载对应的有问题的文件，使用notepad++打开后，发现与PaxHeaders文件夹下的同名文件的内容完全一致。7.至此，我找到了问题原因：1）在Linux的命令行生成tar包文件，最终的tar包包含了文件的元信息，在Windows下解压缩后相应的元信息生成了同名文件；2）目标系统的文件加载策略存在些许问题，并不是直接找到该文件，而更像是在某一文件夹下查找目标文件，而且支持子文件夹的查找，并返回找到的第一个文件。 解决由于是我们系统架构升级，并且没有提前预测到这种情况的发生，也没有提前告知目标系统，让他们来临时修改加载策略肯定是不可能的了，只能依靠自身来解决了。不过还好，一旦定位到问题原因，解决起来也就更加方便了。Linux下使用tar命令进行打包，既然可以生成元信息文件，那么肯定有参数控制其不生成这些信息文件。 1234567891011121314151617man tar……-H, --format=FORMAT Create archive of the given format. Valid formats are: gnu GNU tar 1.13.x format oldgnu GNU format as per tar &lt;= 1.12. pax, posix POSIX 1003.1-2001 (pax) format. ustar POSIX 1003.1-1988 (ustar) format. v7 Old V7 tar format.…… 原来的命令： 1tar -cvf test.tar test 新的命令： 12# 指定了打包格式tar --format&#x3D;gnu -cvf test.tar test","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"tar","slug":"tar","permalink":"https://born2do.github.io/tags/tar/"}],"author":"chenhy"},{"title":"【Linux】crontab执行脚本与用户执行脚本存在差异","slug":"【Linux】crontab执行脚本与用户执行脚本存在差异","date":"2021-04-28T14:22:16.000Z","updated":"2021-04-28T14:22:43.280Z","comments":true,"path":"2021/04/28/【Linux】crontab执行脚本与用户执行脚本存在差异/","link":"","permalink":"https://born2do.github.io/2021/04/28/%E3%80%90Linux%E3%80%91crontab%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC%E5%AD%98%E5%9C%A8%E5%B7%AE%E5%BC%82/","excerpt":"","text":"背景 最近公司项目在进行架构升级，硬件环境也由原来的AIX迁移到了Linux，硬件环境的不同也导致了较多问题。其中之一就是，crontab调用脚本监控系统运行情况，然而用户执行脚本与crontab执行产生了一定的差异。 排查 首先，脚本内容并没有太大改动，仅仅是将一些变量取值的写法更新的更为准确。 其次，脚本中的第三方命令均使用全路径引用，不存在找不到命令的问题。 然后，我又比对了crontab与手工执行脚本的运行日志。crontab运行日志的时间戳全部为数字与英文结合，而手工执行的运行日志中的时间戳则是数字与汉字相结合；crontab的运行日志显示连接数据库查询数据失败了，而手工执行的运行日志则显示一切正常。 经过排查，结果显而易见，crontab执行脚本时缺少用户手工执行脚本时的一些环境变量。用户在登录服务器时，会默认加载当前用户的环境变量（用户环境变量的配置以及加载不在此做过多赘述）。而crontab就不一定了，以老的AIX环境为例，crontab是会拥有当前用户的环境变量的，这也是为什么之前都是正常运行的；而新的Linux环境，明显就是必须要显示地引入当前用户的环境变量，否则会出现一系列问题。 实际上，一开始我是不建议将当前用户的所有环境变量都引入的，毕竟权限大了，谁也控制不住。我的想法是引入部分必要的环境变量就好，其他的环境变量，要用时再说。但是作为一名开发人员，我对Linux运维这块并不是过多了解，于是就找了公司里相关的运维老师。然而，在重试多次后，那位运维老师直接将当前用户的所有环境变量都引入了，简单粗暴。然后我就在嘀咕“问题原因我早就找到了，我只是想要一个最优解，然而你却把我最初的想法告诉了我，那我岂不是舍近求远？？？”。最后在项目组成员都本着“能正常运行就行”的基本原则，还是采用了全量引入当前用户环境变量的方法。 解决有两种引入方式：1.在crontab中引用当前用户环境变量 123# 在引入环境变量的同时，也可以指定脚本的解释器20 03 * * * (. /etc/profile;/bin/sh /var/test.sh)20 03 * * * (. ~/.profile;/bin/sh /var/test.sh) 2.在脚本中引用当前用户环境变量 1source /etc/profile","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"crontab","slug":"crontab","permalink":"https://born2do.github.io/tags/crontab/"}],"author":"chenhy"},{"title":"Page指令","slug":"Page指令","date":"2021-04-25T16:11:09.000Z","updated":"2021-04-25T16:11:32.292Z","comments":true,"path":"2021/04/26/Page指令/","link":"","permalink":"https://born2do.github.io/2021/04/26/Page%E6%8C%87%E4%BB%A4/","excerpt":"","text":"page指令称为页面指令，用来定义JSP页面的全局属性，该配置会作用于整个页面。 page指令的属性可以定义MIME类型、定义需要导入的包、错误页的指定等。 page指令的语法格式如下： 1&lt;%@page 属性1=&quot;属性值1&quot; 属性2=&quot;属性值2&quot; ...... %&gt; page指令page指令是针对当前页面的指令，常用的page指令如下： 1.&lt;%@page language=”java”%&gt; 设置jsp中用到的语言，用到的是java，也是目前唯一有效的设定。 2.&lt;%@page extends=”mypackage.myclass”%&gt; 设置目前jsp要继承的父类，一般不需要设置，在默认情况下，jsp页面默认的父类是HttpJspBase。 3.&lt;%@page import=”java.sql.*”% &gt; jsp页面所用到的类。 4.&lt;%@page errorPage=”error.jsp”%&gt; 设置该jsp页面出现异常时所要转到的页面，如果没设定，容器将使用当前的页面显示错误信息。 5.&lt;%@page isErrorPage=”true”%&gt; 设置该jsp页面是否作为错误显示页面，默认是false，如果设置为true，容器则会在当前页面生成一个exception对象，和4搭配使用。 6.&lt;%@page contentType=”text/html;charset=gb2312”%&gt; 设置页面文件格式和编码方式。 7.&lt;%@page isThreadSafe=”true”% &gt; 设置容器以多线程还是单线程运行该jsp页面，默认是true，是多线程。设置为false，则以单线程的方式运行该jsp页面。 8.&lt;%@page session=”true”% &gt; 设置该jsp页面是否可以用到session对象(jsp内置对象，为web容器创建)，默认是true，能用到session；设置为false，则用不到。 page指令属性page指令属性说明： 属性 定义 language=”ScriptLanguage” 指定JSP Container用什么语言来编译，目前只支持JAVA语言。默认为JAVA extends=”className” 定义此JSP网页产生的Servlet是继承哪个 import=”importList” 定义此JSP网页要使用哪些Java API session=”true|false” 决定此页面是否使用session对象。默认为true buffer=”none|size in kb” 决定输出流(Input stream)是否又缓冲区。默认为8kb autoFlush=”true|false” 决定输出流的缓冲区慢了后是否需要自动清除，缓冲区慢了后会产生异常错误(Exception).默认为true isThreadSafe=”true|false” 是否支持线程。默认为true errorPage=”url” 如果此页发生异常，网页会重新指向一个url isErrorPage=”true|false” 表示此页面是否为错误处理页面。默认为false contentType=”text/html;charset=gb2312” 表示MIME类型和JSP的编码方式。笔者使用例左 pageEncoding=”ISO-8859-1” 编码方式。（笔者已经加入使用的编码） isELLgnored=”true|false” 表示是否在此JSP页面中EL表达式。true则忽略，反之false则支持。默认为false language：定义要使用的脚本语言，目前只能是“java”，即language=”java”。 import：和一般的Java import意义一样，用于引入要使用的类，只是用逗号“,”隔开包或者类列表。默认省略，即不引入其他类或者包。例如，import=”java.io.*,java.util.Hashtable”。 session：指定所在页面是否参与HTTP会话。默认值为true，session=”true”。 buffer：指定到客户输出流的缓冲模式。如果为none，则不缓冲；如果指定数值，那么输出就用不小于这个值的缓冲区进行缓冲。与autoFlash一起使用。默认不小于8KB，根据不同的服务器可设置。例如，buffer=”64kb”。 autoFlash：如果为true缓冲区满时，到客户端输出被刷新；如果为false缓冲区满时，出现运行异常，表示缓冲区溢出。默认为true，例如autoFlash=”true”。 info：关于JSP页面的信息，定义一个字符串，可以使用servlet.getServletInfo()获得。 默认省略。例如，info=”测试页面”。 isErrorPage：表明当前页是否为其他页的errorPage目标。如果被设置为true，则可以使用exception对象。相反，如果被设置为false，则不可以使用exception对象。默认为false，例如，isErrorPage=”true”。 errorPage：定义此页面出现异常时调用的页面。默认忽略，例如errorPage=”error.jsp”。 isThreadSafe：用来设置JSP文件是否能多线程使用。如果设置为true，那么一个JSP能够同时处理多个用户的请求；相反，如果设置为false，一个JSP只能一次处理一个请求。例如，isThreadSafe=”true”。 contentType：定义JSP字符编码和页面响应的MIME类型。TYPE=MIME TYPE;charset=CHARSET。默认为TYPE=text/html,CHARSET=iso8859-1。例如contentType=”text/html;charset=gb2312” pageEncoding：JSP页面的字符编码 ，默认值为pageEncoding=”iso-8859-1”，例如pageEncoding=”gb2312”。 isELIgnored：指定EL（表达式语言）是否被忽略。如果为true，则容器忽略”${}”表达式的计算。默认值由web.xml描述文件的版本确定，servlet2.3以前的版本将忽略。例如isELIgnored=”true”。","categories":[{"name":"JSP","slug":"JSP","permalink":"https://born2do.github.io/categories/JSP/"}],"tags":[{"name":"Page","slug":"Page","permalink":"https://born2do.github.io/tags/Page/"}],"author":"chenhy"},{"title":"【Java】System.out.println()简析","slug":"【Java】System-out-println-简析","date":"2021-04-25T16:09:44.000Z","updated":"2021-04-25T16:10:18.249Z","comments":true,"path":"2021/04/26/【Java】System-out-println-简析/","link":"","permalink":"https://born2do.github.io/2021/04/26/%E3%80%90Java%E3%80%91System-out-println-%E7%AE%80%E6%9E%90/","excerpt":"","text":"Java编程中，我们经常用System.out.println();来向控制台输出变量值或是字符串，但是这条语句，究竟是什么样的，你深究过吗？ 首先，System是java.lang包中的一个类； 其次，out是System类的一个静态成员变量，而且这个成员变量是java.io.PrintStream类的引用。 最后，println()是java.io.PrintStream类里的一个方法，它的作用是向控制台输出信息。 总结：被关键字static修饰的成员变量可以直接通过”类名.成员名”来引用，而无需创建类的实例。所以System.out是调用了System类的静态成员变量out。又因为System.out是java.io.PrintStream类的实例的引用，所以可以通过 System.out.println(); 来调用此方法。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"println","slug":"println","permalink":"https://born2do.github.io/tags/println/"}],"author":"chenhy"},{"title":"vue无法加载文件vue.ps1，因为在此系统上禁止运行脚本","slug":"vue无法加载文件vue-ps1，因为在此系统上禁止运行脚本","date":"2021-04-25T00:43:45.000Z","updated":"2021-04-25T00:44:18.104Z","comments":true,"path":"2021/04/25/vue无法加载文件vue-ps1，因为在此系统上禁止运行脚本/","link":"","permalink":"https://born2do.github.io/2021/04/25/vue%E6%97%A0%E6%B3%95%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6vue-ps1%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9C%A8%E6%AD%A4%E7%B3%BB%E7%BB%9F%E4%B8%8A%E7%A6%81%E6%AD%A2%E8%BF%90%E8%A1%8C%E8%84%9A%E6%9C%AC/","excerpt":"","text":"123456vue : 无法加载文件 C:\\Users\\born2do\\AppData\\Roaming\\npm\\vue.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?Link ID&#x3D;135170 中的 about_Execution_Policies。所在位置 行:1 字符: 1+ vue create hotel-manager + CategoryInfo : SecurityError: (:) []，PSSecurityException + FullyQualifiedErrorId : UnauthorizedAccess 使用VS Code命令终端新建VUE项目，报错如题。 出错原因被系统禁止运行脚本。 解决 右键桌面左下角的小窗口，点击“Windows PowerShell(管理员)(A)”。 执行：set-ExecutionPolicy RemoteSigned （签名或运行这些脚本），在对话框中输入“y”，确认更改策略。123456PS C:\\WINDOWS\\system32&gt; set-ExecutionPolicy RemoteSigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:&#x2F;go.microsoft.com&#x2F;fwlink&#x2F;?LinkID&#x3D;135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y) [A] 全是(A) [N] 否(N) [L] 全否(L) [S] 暂停(S) [?] 帮助 (默认值为“N”): y","categories":[{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/tags/VUE/"}],"author":"chenhy"},{"title":"无法将vue项识别为 cmdlet、函数、脚本文件或可运行程序的名称","slug":"无法将vue项识别为-cmdlet、函数、脚本文件或可运行程序的名称","date":"2021-04-25T00:40:58.000Z","updated":"2021-04-25T00:41:31.330Z","comments":true,"path":"2021/04/25/无法将vue项识别为-cmdlet、函数、脚本文件或可运行程序的名称/","link":"","permalink":"https://born2do.github.io/2021/04/25/%E6%97%A0%E6%B3%95%E5%B0%86vue%E9%A1%B9%E8%AF%86%E5%88%AB%E4%B8%BA-cmdlet%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E6%88%96%E5%8F%AF%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%8D%E7%A7%B0/","excerpt":"","text":"12345vue : 无法将“vue”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ vue create hotel-manager+ ~~~ + FullyQualifiedErrorId : CommandNotFoundException 使用VS Code命令终端新建VUE项目，报错如题。 出错原因第一次学习VUE，未安装VUE程序。 解决： 安装node.js 。从官网下载对应版本的安装包，无脑安装即可。123456&#x2F;&#x2F; 查看node版本号C:\\Program Files&gt;node -vv12.19.0&#x2F;&#x2F; 查看npm版本号C:\\Program Files&gt;npm -v6.14.8 安装vue 。12345678910111213&#x2F;&#x2F; Vue CLI 2.x 安装npm install vue-cli -g&#x2F;&#x2F; Vue CLI 3 安装npm install -g @vue&#x2F;cli&#x2F;&#x2F; 若想将2.x升级至3npm uninstall -g vue-clinpm install -g @vue&#x2F;cli&#x2F;&#x2F; 查看vue版本号C:\\Program Files&gt;vue -V@vue&#x2F;cli 4.5.12 配置环境变量将node以及vue命令所在位置配置到环境变量Path中。全局搜索下npm.cmd和vue.cmd文件，将其路径添加至Path中即可。","categories":[{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/tags/VUE/"}],"author":"chenhy"},{"title":"【MySQL】MySQL安装教程","slug":"【MySQL】MySQL安装教程","date":"2021-04-24T04:57:35.000Z","updated":"2021-04-24T04:58:07.129Z","comments":true,"path":"2021/04/24/【MySQL】MySQL安装教程/","link":"","permalink":"https://born2do.github.io/2021/04/24/%E3%80%90MySQL%E3%80%91MySQL%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/","excerpt":"","text":"对于MySQL的安装，个人建议使用zip压缩包解压缩安装，在线安装很有问题（你连接不了外网，很多东西无法下载）。 在此只进行压缩包安装方式的讲解。 下载压缩包并解压。从官网（https://dev.mysql.com/downloads/mysql/）下载你自己想要的版本，下载后自行解压。 配置环境变量。 新建MYSQL_HOME变量，变量名为你的解压路径名。 编辑path变量，在末尾加上;%MYSQL_HOME%\\bin;。 创建配置文件my.ini。 在MySQL文件夹下创建my.ini文件，并编辑。内容如下： 123456789101112[mysqld]port &#x3D; 3306# 设置为自己MYSQL的安装目录basedir&#x3D;D:\\tools\\mysql-5.7.24-winx64# 设置MYSQL的数据目录，不要自己创建，后续操作会根据my.ini自动生成datadir&#x3D;D:\\tools\\mysql-5.7.24-winx64&#x2F;datamax_connections&#x3D;200character-set-server&#x3D;utf8default-storage-engine&#x3D;INNODBsql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]default-character-set&#x3D;utf8 安装MySQL服务以及初始化。 以管理员身份运行cmd.exe（位置为C:\\Windows\\System32\\cmd.exe），cd到你的MySQL安装目录的bin目录下（以下所有命令都需要进入到mysql安装目录的bin目录下进行！！！）。 执行安装mysql服务的命令：mysqld --install 成功安装后，会有“Service successfully installed”提示。 初始化MySQL：mysqld --initialize 在该步骤会初始化生成data文件夹，所以在前面我提示了不要自己创建文件夹。 启动MySQL：net start mysql MySQL登录：mysql -u root -p 在该步骤会提示你创建密码，输入你自己设定的密码即可，下次登陆时即可使用。 MySQL安装完成。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/categories/MySQL/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"author":"chenhy"},{"title":"【Java】Java中private、default、protected、public的访问权限范围","slug":"【Java】Java中private、default、protected、public的访问权限范围","date":"2021-04-24T04:56:35.000Z","updated":"2021-04-24T04:57:18.862Z","comments":true,"path":"2021/04/24/【Java】Java中private、default、protected、public的访问权限范围/","link":"","permalink":"https://born2do.github.io/2021/04/24/%E3%80%90Java%E3%80%91Java%E4%B8%ADprivate%E3%80%81default%E3%80%81protected%E3%80%81public%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E8%8C%83%E5%9B%B4/","excerpt":"","text":"Java中private、default、protected、public的访问权限范围访问权限：private&lt;default&lt;protected&lt;public 四种修饰符的访问权限范围： 权限 类内 同包 不同包子类 不同包非子类 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"访问修饰符","slug":"访问修饰符","permalink":"https://born2do.github.io/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"}],"author":"chenhy"},{"title":"【Java】HashTable和HashMap的区别","slug":"【Java】HashTable和HashMap的区别","date":"2021-04-23T12:46:34.000Z","updated":"2021-04-23T12:47:11.257Z","comments":true,"path":"2021/04/23/【Java】HashTable和HashMap的区别/","link":"","permalink":"https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91HashTable%E5%92%8CHashMap%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"关于HashMap的一些说法： a) HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。 b) HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。 c) HashMap实现不同步，线程不安全。 HashTable线程安全 d) HashMap中的key-value都是存储在Entry中的。 e) HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性 f) 解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。 注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位； 用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。 拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。 Hashtable和HashMap的区别： a) 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map b) Hashtable中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。 c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。 d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。 f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。 注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。 HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"HashTable","slug":"HashTable","permalink":"https://born2do.github.io/tags/HashTable/"},{"name":"HashMap","slug":"HashMap","permalink":"https://born2do.github.io/tags/HashMap/"}],"author":"chenhy"},{"title":"【Java】Java报错Illegal modifier for parameter x; only final is permitted","slug":"【Java】Java报错Illegal-modifier-for-parameter-x-only-final-is-permitted","date":"2021-04-23T12:45:41.000Z","updated":"2021-04-23T12:46:15.100Z","comments":true,"path":"2021/04/23/【Java】Java报错Illegal-modifier-for-parameter-x-only-final-is-permitted/","link":"","permalink":"https://born2do.github.io/2021/04/23/%E3%80%90Java%E3%80%91Java%E6%8A%A5%E9%94%99Illegal-modifier-for-parameter-x-only-final-is-permitted/","excerpt":"","text":"代码如下： 12345678public class JavaTest &#123; public static void main(String[] args) &#123; // 报错：Illegal modifier for parameter x; only final is permitted // private int x = 1; &#125;&#125; 在main方法中定义了整型变量x，并使用private进行了修饰，系统报错，报错提示为：Illegal modifier for parameter x; only final is permitted。 事实上，在java语法里，方法的形参以及方法体中的变量都是局部变量，不能使用访问权限修饰符public、private或protected。解决方法就是把main方法里的访问权限修饰符private删除或换成final。除此之外不能用其他的修饰符修饰，包括static也会报同样的错误。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"报错","slug":"报错","permalink":"https://born2do.github.io/tags/%E6%8A%A5%E9%94%99/"}],"author":"chenhy"},{"title":"【Linux】Echo详解","slug":"【Linux】Echo详解","date":"2021-04-22T14:18:10.000Z","updated":"2021-04-22T14:18:32.512Z","comments":true,"path":"2021/04/22/【Linux】Echo详解/","link":"","permalink":"https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91Echo%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"官方文档： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647NAME echo - display a line of textSYNOPSIS echo [SHORT-OPTION]... [STRING]... echo LONG-OPTIONDESCRIPTION Echo the STRING(s) to standard output. -n do not output the trailing newline -e enable interpretation of backslash escapes -E disable interpretation of backslash escapes (default) --help display this help and exit --version output version information and exit If -e is in effect, the following sequences are recognized: \\\\ backslash \\a alert (BEL) \\b backspace \\c produce no further output \\e escape \\f form feed \\n new line \\r carriage return \\t horizontal tab \\v vertical tab \\0NNN byte with octal value NNN (1 to 3 digits) \\xHH byte with hexadecimal value HH (1 to 2 digits) 说明： 12345-n 不换行输出-e 激活转义字符-E 不激活转义字符(default)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"Echo","slug":"Echo","permalink":"https://born2do.github.io/tags/Echo/"}],"author":"chenhy"},{"title":"【Linux】chmod命令给脚本赋权限","slug":"【Linux】chmod命令给脚本赋权限","date":"2021-04-22T14:17:07.000Z","updated":"2021-04-22T14:17:45.306Z","comments":true,"path":"2021/04/22/【Linux】chmod命令给脚本赋权限/","link":"","permalink":"https://born2do.github.io/2021/04/22/%E3%80%90Linux%E3%80%91chmod%E5%91%BD%E4%BB%A4%E7%BB%99%E8%84%9A%E6%9C%AC%E8%B5%8B%E6%9D%83%E9%99%90/","excerpt":"","text":"Linux环境下不同的文件类型会有不同的颜色： 蓝色表示目录； 绿色表示可执行文件，可执行的程序； 红色表示压缩文件或包文件； 浅蓝色表示链接文件； 灰色表示其它文件； 红色闪烁表示链接的文件有问题了； 黄色表示设备文件。 在Linux环境下编写并保存脚本，该脚本将会是灰色的，是无法执行的，需要为其赋权限，可执行的权限。 1chmod +x shfile.sh 即为shfile.sh赋了可执行的权限。此时文件将会显示为绿色的。 不过，大多数情况下，我都是直接 chmod 777 filename ，简单快捷。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"chmod","slug":"chmod","permalink":"https://born2do.github.io/tags/chmod/"}],"author":"chenhy"},{"title":"【Java】Java关键字","slug":"【Java】Java关键字","date":"2021-04-21T13:46:26.000Z","updated":"2021-04-21T13:47:23.770Z","comments":true,"path":"2021/04/21/【Java】Java关键字/","link":"","permalink":"https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91Java%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"Java关键字 java全部关键字及含义：","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"关键字","slug":"关键字","permalink":"https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"}],"author":"chenhy"},{"title":"【Java】ArrayList和LinkedList","slug":"【Java】ArrayList和LinkedList","date":"2021-04-21T13:45:03.000Z","updated":"2021-04-21T13:45:50.557Z","comments":true,"path":"2021/04/21/【Java】ArrayList和LinkedList/","link":"","permalink":"https://born2do.github.io/2021/04/21/%E3%80%90Java%E3%80%91ArrayList%E5%92%8CLinkedList/","excerpt":"","text":"ArrayList和LinkedList ArrayList与LinkedList都实现了List接口，继承了AbstractList类。 ArrayList底层是动态数组是实现，随机位置添加和删除，都需要移动数组的数据，而LinkedList底层是双向链表，只需要修改Node节点的引用。 随机访问数组要比链表快。 ArrayList和LinkedList的区别：","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"ArrayList","slug":"ArrayList","permalink":"https://born2do.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://born2do.github.io/tags/LinkedList/"}],"author":"chenhy"},{"title":"Navicat导入数据库","slug":"Navicat导入数据库","date":"2021-04-20T13:37:37.000Z","updated":"2021-04-20T13:37:58.051Z","comments":true,"path":"2021/04/20/Navicat导入数据库/","link":"","permalink":"https://born2do.github.io/2021/04/20/Navicat%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"右键数据库连接（我这里命名为MySQL），点击“新建数据库”，数据库名使用你即将导入的数据库名称，字符集使用“Default character set”或“utf8 – UTF-8 Unicode”（后者更为常用，但取决于你要导入的数据库的编码方式），点击“确定”完成数据库的创建。 双击新建的数据库，再右键数据库，点击“运行SQL文件”，选择要导入的.sql文件，点击“开始”，待运行完，即可完成数据库的导入。","categories":[{"name":"Navicat","slug":"Navicat","permalink":"https://born2do.github.io/categories/Navicat/"}],"tags":[{"name":"Navicat","slug":"Navicat","permalink":"https://born2do.github.io/tags/Navicat/"}],"author":"chenhy"},{"title":"【MySQL】MySQL学习Day01","slug":"【MySQL】MySQL学习Day01","date":"2021-04-20T13:36:38.000Z","updated":"2021-04-20T13:37:08.581Z","comments":true,"path":"2021/04/20/【MySQL】MySQL学习Day01/","link":"","permalink":"https://born2do.github.io/2021/04/20/%E3%80%90MySQL%E3%80%91MySQL%E5%AD%A6%E4%B9%A0Day01/","excerpt":"","text":"MySQL在DOS下的基本操作 启动MySQL服务： 1net start mysql 关闭MySQL服务： 1net stop mysql 注意：上述两个命令均不是以分号结尾。 登陆MySQL： 1mysql -u root -p 然后会让你输入密码，密码正确后即可进入MySQL。注意：该命令不是以分号结尾。 注意：有的登陆命令会是mysql -h localhost -u root -p，具体取决于你当时是怎么装MySQL的。 显示所有数据库： 1show databases; 注意：从该步骤开始，每条命令均以分号结尾。 进入数据库： 1use 数据库名; 查看该数据库中所有的表： 1show tables; 创建数据库，并且指定编码utf-8： 1create database testdb default character set &#39;utf8&#39;; 该处的“testdb”是数据库名。 创建表： 12345create table student( id int auto_increment primary key, name varchar(20) not null, age int); 查看表结构： 1describe student; 查看当前数据库编码方式： 1show variables like &#39;character_set_database&#39;; 修改当前数据库编码方式： 1alter database testdb character set gb2312; 该处的“testdb”是数据库名。 查看MySQL的各种数据的编码方式： 1show variables like &quot;%character%&quot;; 查询结果： 12345678910111213+--------------------------+----------------------------------------+| Variable_name | Value |+--------------------------+----------------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | D:\\mysql-5.7.25-winx64\\share\\charsets\\ |+--------------------------+----------------------------------------+8 rows in set, 1 warning (0.00 sec) 注意：最好在安装MySQL的时候就将数据库编码方式改为utf-8，不然后续会很麻烦。","categories":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/tags/MySQL/"}],"author":"chenhy"},{"title":"Typora修改内容字体样式","slug":"Typora修改内容字体样式","date":"2021-04-19T11:02:53.000Z","updated":"2021-04-19T11:03:48.580Z","comments":true,"path":"2021/04/19/Typora修改内容字体样式/","link":"","permalink":"https://born2do.github.io/2021/04/19/Typora%E4%BF%AE%E6%94%B9%E5%86%85%E5%AE%B9%E5%AD%97%E4%BD%93%E6%A0%B7%E5%BC%8F/","excerpt":"","text":"Typora文档编辑器，近年来越来越受到广大编程人员的喜爱，使用起来极易上手，文档格式编辑也更美观。但是，默认的中文字体样式是“宋体”，就本人而言，不喜欢。但是怎么修改呢？ 字体样式修改教程 在 Typora 中依次打开 文件-&gt;偏好设置-&gt;打开主题文件夹。 * * * * * * 这里以GitHub主题为例，修改字体样式。 用Sublime或WebStorm打开github.css，大约在40行左右有body标签样式，在font-family添加上你自己想要的字体名称，注意所有标点要用英文字符（名称是汉字的除外）。我这里增加了”楷体”。修改后保存关闭文件，再打开Typora，内容字体样式成功修改。","categories":[{"name":"Typora","slug":"Typora","permalink":"https://born2do.github.io/categories/Typora/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"https://born2do.github.io/tags/Typora/"}],"author":"chenhy"},{"title":"WebStorm找不到文件chrome","slug":"WebStorm找不到文件chrome","date":"2021-04-19T11:01:49.000Z","updated":"2021-04-19T11:02:11.294Z","comments":true,"path":"2021/04/19/WebStorm找不到文件chrome/","link":"","permalink":"https://born2do.github.io/2021/04/19/WebStorm%E6%89%BE%E4%B8%8D%E5%88%B0%E6%96%87%E4%BB%B6chrome/","excerpt":"","text":"最近重装了系统，软件也都重新装了一遍，但是在使用WebStorm的时候突然出现了无法使用google chrome，提示”windows 找不到文件chrome，请确定文件名是否正确后，再试一次”，这个问题的本质是WebStorm中关于chrome浏览器的路径是错误的，修改浏览器路径即可。 找到你本机中chrome浏览器的位置。右击桌面上的chrome浏览器图标，找到属性–&gt;快捷方式–&gt;目标，复制路径（即chrome浏览器.exe文件的路径）。 修改WebStorm中chrome浏览器的路径。打开WebStorm软件，找到file–&gt;settings–&gt;Web Browsers，在chrome那一栏最右边的path中粘贴之前复制的路径，点击OK,问题即可解决。","categories":[{"name":"WebStorm","slug":"WebStorm","permalink":"https://born2do.github.io/categories/WebStorm/"}],"tags":[{"name":"WebStorm","slug":"WebStorm","permalink":"https://born2do.github.io/tags/WebStorm/"}],"author":"chenhy"},{"title":"【Java】Java中重写与重载的区别","slug":"【Java】Java中重写与重载的区别","date":"2021-04-18T10:47:24.000Z","updated":"2021-04-18T10:47:56.533Z","comments":true,"path":"2021/04/18/【Java】Java中重写与重载的区别/","link":"","permalink":"https://born2do.github.io/2021/04/18/%E3%80%90Java%E3%80%91Java%E4%B8%AD%E9%87%8D%E5%86%99%E4%B8%8E%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"重写 发生在父类与子类之间 方法名，参数列表，返回类型（除子类中方法的返回类型是父类中返回类型的子类）必须相同 访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private) 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常 重载 重载Overload是一个类中多态性的一种表现 重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序) 重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准 总结 重载 重写（也称覆盖） 英文 overloading overriding 定义 方法名相同，参数列表不同（参数的类型、个数甚至顺序不同），对返回值无要求 方法名称，参数列表，返回值类型，完全相同 权限 对权限没有要求 被重写的方法不能拥有比父类更加严格的权限 范围 发生在同一个类中 发生在继承中","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"重写","slug":"重写","permalink":"https://born2do.github.io/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"https://born2do.github.io/tags/%E9%87%8D%E8%BD%BD/"}],"author":"chenhy"},{"title":"【基金】基金基础专业术语解释","slug":"【基金】基金基础专业术语解释","date":"2021-04-17T11:04:06.000Z","updated":"2021-04-17T11:04:28.349Z","comments":true,"path":"2021/04/17/【基金】基金基础专业术语解释/","link":"","permalink":"https://born2do.github.io/2021/04/17/%E3%80%90%E5%9F%BA%E9%87%91%E3%80%91%E5%9F%BA%E9%87%91%E5%9F%BA%E7%A1%80%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E8%A7%A3%E9%87%8A/","excerpt":"","text":"1.仓位说明建仓：开始买进一些加仓：继续买进，会拉高成本价（也即拉高成本净值）补仓：跌了买一些减仓：卖一些全仓：投入所有资金重仓：买进自有资产的80%左右半仓：用掉所有资金一半买进轻仓：只买了一小部分，比如20%-30%2.操作说明止损：亏钱卖出追涨：基金一直涨，仍一直买进杀跌：基金跌了，忍不住卖掉踏空：一直在看，没上车买进3.常见术语累计净值：基金成立到现在的价格交易确定日：确定你买入基金份额的日期北上资金：北是沪深的股票，从香港股票流入大陆股市的资金南下资金：南是香港的股票，从大陆股票流入香港股市的资金现金分红：直接获取现金分红，免个人所得税，落袋为安","categories":[{"name":"基金","slug":"基金","permalink":"https://born2do.github.io/categories/%E5%9F%BA%E9%87%91/"}],"tags":[{"name":"专业术语","slug":"专业术语","permalink":"https://born2do.github.io/tags/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"}],"author":"chenhy"},{"title":"【MD】Typora快捷键","slug":"【MD】Typora快捷键","date":"2021-04-17T03:30:37.000Z","updated":"2021-04-17T03:31:14.347Z","comments":true,"path":"2021/04/17/【MD】Typora快捷键/","link":"","permalink":"https://born2do.github.io/2021/04/17/%E3%80%90MD%E3%80%91Typora%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"","text":"Typora快捷键 无序列表：输入“-”之后输入空格 有序列表：输入数字+“.”之后输入空格 代码： 单行：一对 “`” 多行：一对 “```” 任务列表：-[空格]空格 文字 标题：ctrl+数字 表格：ctrl+t 引用：&gt;+空格 生成目录：[TOC]按回车 选中一整行：ctrl+l 选中单词：ctrl+d 选中相同格式的文字：ctrl+e 跳转到文章开头：ctrl+home 跳转到文章结尾：ctrl+end 搜索：ctrl+f 替换：ctrl+h 引用：输入&gt;之后输入空格 代码块：ctrl+alt+f 加粗：ctrl+b 倾斜：ctrl+i 下划线：ctrl+u 删除线：alt+shift+5 插入图片：直接拖动到指定位置即可或者ctrl+shift+i 插入链接：ctrl+k 一级标题：输入#之后输入空格，然后再输入内容 Typora支持YAML Front Matter， 在文章开头输入---，然后按回车即可。 常见问题1.怎么退出“无序列表”？ 答：回车删除前面的点之后，用Shift+Tab去除缩进即可。","categories":[{"name":"MD","slug":"MD","permalink":"https://born2do.github.io/categories/MD/"}],"tags":[{"name":"快捷键","slug":"快捷键","permalink":"https://born2do.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"}],"author":"chenhy"},{"title":"【Java】内部类","slug":"【Java】内部类","date":"2021-04-17T03:27:18.000Z","updated":"2021-04-17T03:27:47.561Z","comments":true,"path":"2021/04/17/【Java】内部类/","link":"","permalink":"https://born2do.github.io/2021/04/17/%E3%80%90Java%E3%80%91%E5%86%85%E9%83%A8%E7%B1%BB/","excerpt":"","text":"在Java中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。1.成员内部类（1）该类像是外部类的一个成员，可以无条件的访问外部类的所有成员属性和成员方法（包括private成员和静态成员）；（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要访问外部类中的成员，需要以下形式访问：【外部类.this.成员变量 或 外部类.this.成员方法】；（3）在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象；（5）内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如果成员内部类用private修饰，则只能在外部类的内部访问；如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被public和包访问两种权限修饰。2.局部内部类（1）局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；（2）局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。3.匿名内部类（1）一般使用匿名内部类的方法来编写事件监听代码；（2）匿名内部类是不能有访问修饰符和static修饰符的；（3）匿名内部类是唯一一种没有构造器的类；（4）匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。4.内部静态类（1）静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似；（2）不能使用外部类的非static成员变量或者方法。 提醒：大多数企业级应用开发是要求减少内部类的使用，毕竟能用内部类实现的，基本类都是可以实现的。内部类并没有太大的优势体现出来。 Java内部类思维导图","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"内部类","slug":"内部类","permalink":"https://born2do.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"}],"author":"chenhy"},{"title":"C语言零碎知识","slug":"C语言零碎知识","date":"2021-04-16T09:41:01.000Z","updated":"2021-04-16T09:41:25.827Z","comments":true,"path":"2021/04/16/C语言零碎知识/","link":"","permalink":"https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/","excerpt":"","text":"printf()格式字符 printf()格式字符 英文 含义 %c character 以字符形式输出单个字符 %s string 输出一个字符串 %d decimal 以带符号十进制整数输出 %f float 以小数形式输出浮点数（6位小数） %e exponent 以标准指数形式输出（6位小数） %g 选用%f，%e中输出宽度较小的一种格式 %o octal 以八进制无符号整数输出（无前导0） %x hex 以十六进制无符号整数输出（无前导0x） %u unsigned 以十进制无符号整数输出 printf()的格式修饰符 printf()格式修饰符 含义 m 表示数据占用的最小宽度。数据宽度大于m，按实际宽度输出；数据宽度小于m时，补空格。 n 对实数表示输出n位小数。对字符串表示最多输出的字符个数。 l 长整型整数，加在d、o、x、u前 L long double型数，加在f、e、g前 - 改变输出内容的对齐方式为左对齐，默认为右对齐 scanf()的格式字符 scanf()格式字符 含义 %c 以字符形式输入单个字符 %s 输入字符串,以非空字符开始,遇第一个空白字符结束 %d 以带符号十进制形式输入整型数据 %f 以小数形式输入浮点数 %e 以标准指数形式输入 %o 以八进制无符号形式输入（无前导0） %x 以十六进制无符号形式输入（无前导0x） scanf()的格式修饰符 scanf()格式修饰符 含义 m 表示数据占用的宽度 l 加在d、o、x、u前：输入长整型；加在f、e 前：输入双精度型 L 加在f、e 前：输入long double型 h 加在d、o、x 前:输入短整型 * 本输入项在读入后不赋给相应的变量 文件打开方式（mode）：①对应文本文件“r” 只读 必须是已存在的文件“w” 只写 不论该文件是否存在，都新建一个文件“a” 追加 向文本文件尾增加数据，该文件必须存在“r+” 读写 打开一个已存在的文件，用于读写“w+” 读写 建立一个新文件，可读可写“a+” 读写 向文件尾追加数据，也可读②对应二进制文件“rb”“wb”“ab”“rb+”“wb+”“ab+”","categories":[{"name":"C语言","slug":"C语言","permalink":"https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"零碎知识","slug":"零碎知识","permalink":"https://born2do.github.io/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"}],"author":"chenhy"},{"title":"C语言关键字","slug":"C语言关键字","date":"2021-04-16T09:38:58.000Z","updated":"2021-04-16T09:39:22.807Z","comments":true,"path":"2021/04/16/C语言关键字/","link":"","permalink":"https://born2do.github.io/2021/04/16/C%E8%AF%AD%E8%A8%80%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"","text":"由ANSI标准定义的C语言关键字共32个 : auto double int struct break else long switch case enum register typedef char extern return union const float short unsigned continue for signed void default goto sizeof volatile do if while static 根据关键字的作用，可以将关键字分为数据类型关键字和流程控制关键字两大类。 1． 数据类型关键字 A基本数据类型（5个） void ：声明函数无返回值或无参数，声明无类型指针，显式丢弃运算结果 char ：字符型类型数据，属于整型数据的一种 int ：整型数据，通常为编译器指定的机器字长 float ：单精度浮点型数据，属于浮点数据的一种 double ：双精度浮点型数据，属于浮点数据的一种 B 类型修饰关键字（4个） short ：修饰int，短整型数据，可省略被修饰的int。 long ：修饰int，长整形数据，可省略被修饰的int。 signed ：修饰整型数据，有符号数据类型 unsigned ：修饰整型数据，无符号数据类型 C 复杂类型关键字（5个） struct ：结构体声明 union ：共用体声明 enum ：枚举声明 typedef ：声明类型别名 sizeof ：得到特定类型或特定类型变量的大小 D 存储级别关键字（6个） auto ：指定为自动变量，由编译器自动分配及释放。通常在栈上分配 static ：指定为静态变量，分配在静态变量区，修饰函数时，指定函数作用域为文件内部 register ：指定为寄存器变量，建议编译器将变量存储到寄存器中使用，也可以修饰函数形参，建议编译器通过寄存器而不是堆栈传递参数 extern ：指定对应变量为外部变量，即在另外的目标文件中定义，可以认为是约定由另外文件声明的韵蟮囊桓觥耙?谩? const ：与volatile合称“cv特性”，指定变量不可被当前线程/进程改变（但有可能被系统或其他线程/进程改变） volatile ：与const合称“cv特性”，指定变量的值有可能会被系统或其他进程/线程改变，强制编译器每次从内存中取得该变量的值 2． 流程控制关键字 A 跳转结构（4个） return ：用在函数体中，返回特定值（或者是void值，即不返回值） continue ：结束当前循环，开始下一轮循环 break ：跳出当前循环或switch结构 goto ：无条件跳转语句 B 分支结构（5个） if ：条件语句 else ：条件语句否定分支（与if连用） switch ：开关语句（多重分支语句） case ：开关语句中的分支标记 default ：开关语句中的“其他”分治，可选。 C 循环结构（3个） for ：for循环结构，for(1;2;3)4;的执行顺序为1-&gt;2-&gt;4-&gt;3-&gt;2…循环，其中2为循环条件 do ：do循环结构，do 1 while(2); 的执行顺序是 1-&gt;2-&gt;1…循环，2为循环条件 while ：while循环结构，while(1) 2; 的执行顺序是1-&gt;2-&gt;1…循环，1为循环条件 以上循环语句，当循环条件表达式为真则继续循环，为假则跳出循环。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"关键字","slug":"关键字","permalink":"https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"}],"author":"chenhy"},{"title":"XML初识","slug":"XML初识","date":"2021-04-14T14:08:16.000Z","updated":"2021-04-14T14:09:19.590Z","comments":true,"path":"2021/04/14/XML初识/","link":"","permalink":"https://born2do.github.io/2021/04/14/XML%E5%88%9D%E8%AF%86/","excerpt":"","text":"1.什么是 XML? XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准 2.XML 与 HTML 的主要差异 XML 不是 HTML 的替代。 XML 和 HTML 为不同的目的而设计： XML 被设计为传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。 HTML 旨在显示信息，而 XML 旨在传输信息。 3.没有任何行为的 XMLXML 是不作为的。 也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。 下面是 John 写给 George 的便签，存储为 XML： 123456&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&#x27;t forget the meeting!&lt;/body&gt;&lt;/note&gt; 上面的这条便签具有自我描述性。它拥有标题以及留言，同时包含了发送者和接受者的信息。 但是，这个 XML 文档仍然没有做任何事情。它仅仅是包装在 XML 标签中的纯粹的信息。我们需要编写软件或者程序，才能传送、接收和显示出这个文档。 4.XML 仅仅是纯文本XML 没什么特别的。它仅仅是纯文本而已。有能力处理纯文本的软件都可以处理 XML。 不过，能够读懂 XML 的应用程序可以有针对性地处理 XML 的标签。标签的功能性意义依赖于应用程序的特性。 5.通过 XML 你可以发明自己的标签上例中的标签没有在任何 XML 标准中定义过（比如 &lt;to&gt; 和 &lt;from&gt;）。这些标签是由文档的创作者发明的。 这是因为 XML 没有预定义的标签。 在 HTML 中使用的标签（以及 HTML 的结构）是预定义的。HTML 文档只使用在 HTML 标准中定义过的标签（比如 &lt;p&gt; 、&lt;h1&gt; 等等）。 XML 允许创作者定义自己的标签和自己的文档结构。 6.XML 不是对 HTML 的替代XML 是对 HTML 的补充。 XML 不会替代 HTML，理解这一点很重要。在大多数 web 应用程序中，XML 用于传输数据，而 HTML 用于格式化并显示数据。 对 XML 最好的描述是： XML 是独立于软件和硬件的信息传输工具。 参考文章：http://www.w3school.com.cn/xml/xml_intro.asp","categories":[{"name":"XML","slug":"XML","permalink":"https://born2do.github.io/categories/XML/"}],"tags":[{"name":"XML","slug":"XML","permalink":"https://born2do.github.io/tags/XML/"}],"author":"chenhy"},{"title":"【Java】JSF中Bean的作用域","slug":"【Java】JSF中Bean的作用域","date":"2021-04-14T14:02:55.000Z","updated":"2021-04-14T14:03:23.028Z","comments":true,"path":"2021/04/14/【Java】JSF中Bean的作用域/","link":"","permalink":"https://born2do.github.io/2021/04/14/%E3%80%90Java%E3%80%91JSF%E4%B8%ADBean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/","excerpt":"","text":"JSF 2.x从JSF 2.x开始，有4个Bean范围：@ViewScoped@RequestScoped@SessionScoped@ApplicationScoped ViewScope： View范围是在JSF 2.0中添加的。 重新显示相同的JSF页面时，视图范围内的bean仍然存在。 （JSF规范将术语“视图”用于JSF页面。）一旦用户导航到另一个页面，Bean就会超出范围。 RequestScope：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。 SessionScoped：会话范围从建立会话到会话终止一直存在。 如果Web应用程序在HttpSession对象上调用invalidate方法，或者会话超时，则会话终止。 ApplicationScope：应用程序作用域在Web应用程序的整个过程中一直存在。 该范围在所有请求和所有会话之间共享。 如果应在Web应用程序的所有实例之间共享单个bean，则将托管bean放入应用程序范围。 Bean是在应用程序的任何用户首次请求时构造的，并且一直保持活动状态，直到从应用程序服务器中删除Web应用程序为止。 根据需要选择范围。 JSF 2.3从JSF 2.3开始，已弃用javax.faces.bean包中定义的所有bean作用域，以使作用域与CDI对齐。 此外，它们仅在您的bean使用@ManagedBean注释时才适用。 如果您使用的JSF版本低于2.3，请参考最后的遗留答案。 从JSF 2.3开始，这里是可以在JSF Backing Bean上使用的范围： @javax.enterprise.context.ApplicationScoped ：应用程序作用域在Web应用程序的整个持续时间内一直存在。 该范围在所有请求和所有会话之间共享。 当您拥有整个应用程序的数据时，这很有用。 @javax.enterprise.context.SessionScoped ：会话范围从建立会话的时间一直持续到会话终止为止。 会话上下文在同一HTTP会话中发生的所有请求之间共享。 当您不想为特定会话保存特定客户端的数据时，此功能很有用。 @javax.enterprise.context.ConversationScoped ：对话范围随着bean的存在而保持为日志。 范围提供2种方法： Conversation.begin()和Conversation.end() 。 这些方法应显式调用，以开始或结束Bean的生命。 @javax.enterprise.context.RequestScoped ：请求范围是短暂的。 它在提交HTTP请求时开始，在将响应发送回客户端后结束。 如果将托管bean放入请求范围，则会为每个请求创建一个新实例。 如果您担心会话范围存储的成本，则值得考虑请求范围。 @javax.faces.flow.FlowScoped ：只要Flow存在，Flow范围就会持续存在。 流可以定义为一组包含页面（或视图）的页面，这些页面定义了一个工作单元。 只要用户在Flow中进行导航，作用域就可以激活。 @javax.faces.view.ViewScoped ：视图范围内的Bean在重新显示同一JSF页面时仍然存在。 一旦用户导航到另一个页面，Bean就会超出范围。 转载自 https://my.oschina.net/u/3797416/blog/3166873 。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"JSF","slug":"JSF","permalink":"https://born2do.github.io/tags/JSF/"}],"author":"chenhy"},{"title":"【Java】Spring中注解可以在哪些地方","slug":"【Java】Spring中注解可以在哪些地方","date":"2021-04-13T13:13:37.000Z","updated":"2021-04-13T13:55:13.291Z","comments":true,"path":"2021/04/13/【Java】Spring中注解可以在哪些地方/","link":"","permalink":"https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E4%B8%AD%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9/","excerpt":"","text":"Spring中的注解根据所在位置主要分为两类： 类级别的注解：如@Component、@Repository、@Controller、@Service以及JavaEE6的@ManagedBean和@Named注解，都是添加在类上面的类级别注解。 类内部的注解：如@Autowired、@Value、@Resource以及EJB和WebService相关的注解等，都是添加在类内部的字段或者方法上的类内部注解。 正常情况下，接口以及抽象类文件中是不能使用注解的。因为spring的原理是启动服务器时读取配置文件，取得类名后利用反射机制在spring上下文中生成一个单例的对象，由spring注入属性并维护此对象的状态，抽象类/接口在反射生成对象时就已经失败了，spring无法注入，后续的其他操作也将不会进行。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"chenhy"},{"title":"【Java】Spring项目中相关注解","slug":"【Java】Spring项目中相关注解","date":"2021-04-13T13:12:35.000Z","updated":"2021-04-13T13:13:10.961Z","comments":true,"path":"2021/04/13/【Java】Spring项目中相关注解/","link":"","permalink":"https://born2do.github.io/2021/04/13/%E3%80%90Java%E3%80%91Spring%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"1.声明bean的注解@Controller 在表现层使用，控制器（注入服务）用于标注控制层。 @Service 在业务逻辑层使用，服务（注入dao）用于标注服务层，主要用来进行业务的逻辑处理。 @Repository 在数据访问层使用，（实现dao访问）用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件。 @Component 组件，通用的注解方式泛指各种组件，也即当我们的类不属于任何一种归类（@Controller、@Service等）的时候，但我们又要将该类实例化到spring容器中，我们就可以使用@Component来标注这个类。 2.注入bean的注解@Autowired：由Spring提供 @Inject：由JSR-330提供 @Resource：由JSR-250提供 都可以注解在set方法和属性上，推荐注解在属性上。 3.java配置类相关注解@Configuration 声明当前类为配置类，相当于xml形式的Spring配置(类上) @Bean 注解在方法上，声明当前方法的返回值为一个bean，替代xml中的方式(方法上) @Configuration 声明当前类为配置类，其中内部组合了@Component注解，表明这个类是一个bean(类上) @ComponentScan 用于对Component进行扫描，相当于xml中的(类上) @WishlyConfiguration 为@Configuration与@ComponentScan的组合注解，可以替代这两个注解 4.切面(AOP)相关注解Spring支持AspectJ的注解式切面编程。 @Aspect 声明一个切面(类上) 使用@After、@Before、@Around定义建言(advice)，可直接将拦截规则(切点)作为参数。 @After 在方法执行之后执行(方法上) @Before 在方法执行之前执行(方法上) @Around 在方法执行之前与之后执行(方法上) @PointCut 声明切点 在java配置类中使用@EnableAspectJAutoProxy注解开启Spring对AspectJ代理的支持(类上) 5.@Bean的属性支持@Scope 设置Spring容器如何新建Bean实例(方法上要有@Bean) 其设置类型包括：· Singleton (单例，一个Spring容器中只有一个bean实例，默认模式),· Protetype (每次调用新建一个bean),· Request (web项目中，给每个http request新建一个bean),· Session (web项目中，给每个http session新建一个bean),· GlobalSession(给每一个 global http session新建一个Bean实例) @StepScope 在Spring Batch中有涉及 @PostConstruct 由JSR-250提供，在构造函数执行完之后执行，等价于xml配置文件中bean的initMethod @PreDestory 由JSR-250提供，在Bean销毁之前执行，等价于xml配置文件中bean的destroyMethod","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"注解","slug":"注解","permalink":"https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"}],"author":"chenhy"},{"title":"【Java】在SpringBoot项目中使用单元测试","slug":"【Java】在SpringBoot项目中使用单元测试","date":"2021-04-12T13:47:55.000Z","updated":"2021-04-12T13:48:33.615Z","comments":true,"path":"2021/04/12/【Java】在SpringBoot项目中使用单元测试/","link":"","permalink":"https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91%E5%9C%A8SpringBoot%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","excerpt":"","text":"1.引入单元测试依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt; 2.使用1）在测试类上添加如下注解 12@RunWith(SpringRunner.class)@SpringBootTest 2）在测试方法中添加如下注解 1@Test 实例： 12345678910111213141516171819202122232425262728293031package com.example.demo.test;import com.example.demo.service.IUserService;import com.example.demo.service.impl.UserServiceImpl01;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserTest &#123;&#x2F;&#x2F; @Autowired&#x2F;&#x2F; @Qualifier(&quot;userServiceImpl02&quot;) @Resource(type &#x3D; UserServiceImpl01.class) IUserService userService; @Test public void test() &#123; userService.say(); &#125;&#125; 注意，包的引入千万别弄错了。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"单元测试","slug":"单元测试","permalink":"https://born2do.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"}],"author":"chenhy"},{"title":"【Java】@Autowired和@Resource","slug":"【Java】-Autowired和-Resource","date":"2021-04-12T13:46:48.000Z","updated":"2021-04-12T13:47:31.558Z","comments":true,"path":"2021/04/12/【Java】-Autowired和-Resource/","link":"","permalink":"https://born2do.github.io/2021/04/12/%E3%80%90Java%E3%80%91-Autowired%E5%92%8C-Resource/","excerpt":"","text":"@Autowired和@Resource这两个注解最大的区别： @Autowired 根据类型注入 @Resource 根据名称注入 以上是这两个注解最主要的装配方式，具体使用方式见下方。以下只针对于一个接口有一个或多个实现类的情况进行讨论。没有实现类的情况不讨论，个人觉得自动注入允许为空的情况是十分不安全的，实际开发中也没有太大意义。 @Autowired1.接口与实现类一一对应接口： 123456789package com.example.demo.service;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;public interface IUserService &#123; void say();&#125; 实现类01： 12345678910111213141516package com.example.demo.service.impl;import com.example.demo.service.IUserService;import org.springframework.stereotype.Service;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@Servicepublic class UserServiceImpl01 implements IUserService &#123; @Override public void say() &#123; System.out.println(&quot;I am UserServiceImpl01.................&quot;); &#125;&#125; 测试类： 12345678910111213141516171819202122232425package com.example.demo.test;import com.example.demo.service.IUserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserTest &#123; @Autowired IUserService userService; @Test public void test() &#123; userService.say(); &#125;&#125; 运行测试方法，控制台输出“I am UserServiceImpl01……………..”。此时，Spring容器中只有一个IUserService 的实现类UserServiceImpl01 ，byType进行注入时，会自动找到实现类UserServiceImpl01进行注入。从控制台的打印结果我们也可以看出，调用的是类UserServiceImpl01的方法。验证了@Autowired是根据类型注入的观点。 2.接口与实现类的关系为一对多新建实现类02： 12345678910111213141516package com.example.demo.service.impl;import com.example.demo.service.IUserService;import org.springframework.stereotype.Service;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@Servicepublic class UserServiceImpl02 implements IUserService &#123; @Override public void say() &#123; System.out.println(&quot;I am UserServiceImpl02.................&quot;); &#125;&#125; 运行测试方法，控制台报错如下：Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.example.demo.service.IUserService’ available: expected single matching bean but found 2: userServiceImpl01,userServiceImpl02意思就是有多个实现类，程序不知道到底该注入哪个实现类了。 测试类处理如下： 123456789101112131415161718192021222324252627package com.example.demo.test;import com.example.demo.service.IUserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserTest &#123; @Autowired @Qualifier(&quot;userServiceImpl02&quot;) IUserService userService; @Test public void test() &#123; userService.say(); &#125;&#125; 运行测试方法，控制台输出“I am UserServiceImpl02……………..”。我们新增了@Qualifier注解，该注解与@Autowired结合使用，可以在一个接口有多个实现类的情况下，指定注入的实现类的名称。此处，而我们注入了第二个实现类UserServiceImpl02。（注意，Qualifier注解中的名称首字母为小写）。 @Autowired+@Qualifier的使用，实现了bean自动注入时，先按照类型再按照名称进行注入的功能。 @Resource1.根据名称注入（byName）新建实现类： 12345678910111213141516package com.example.demo.service.impl;import com.example.demo.service.IUserService;import org.springframework.stereotype.Service;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@Servicepublic class UserService implements IUserService &#123; @Override public void say() &#123; System.out.println(&quot;I am UserService.................&quot;); &#125;&#125; 修改测试类如下： .java12345678910111213141516171819202122232425262728293031package com.example.demo.test;import com.example.demo.service.IUserService;import com.example.demo.service.impl.UserService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserTest &#123;&#x2F;&#x2F; @Autowired&#x2F;&#x2F; @Qualifier(&quot;userServiceImpl02&quot;) @Resource IUserService userService; @Test public void test() &#123; userService.say(); &#125;&#125; 其他文件不做改动。现在的整体情况是，IUserService 有3个实现类，如果按类型注入的话肯定是失败的。 运行测试方法，控制台输出“I am UserService……………..”。由此可见，@Resource在进行bean注入时，首先会按照名称（byName）进行装配。 2.根据类型注入将UserService.java全部注释掉，再次运行测试方法进行测试。 运行测试程序，此时控制台报错如下：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘com.example.demo.test.UserTest’: Injection of resource dependencies failed; nested exception is org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type ‘com.example.demo.service.IUserService’ available: expected single matching bean but found 2: userServiceImpl01,userServiceImpl02与之前测试Autowired注解的情形相同，按照类型注入失败了。测试类处理如下： 12345678910111213141516171819202122232425262728293031package com.example.demo.test;import com.example.demo.service.IUserService;import com.example.demo.service.impl.UserServiceImpl01;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import javax.annotation.Resource;&#x2F;** * @author chenhy * @date 2021&#x2F;4&#x2F;11 *&#x2F;@RunWith(SpringRunner.class)@SpringBootTestpublic class UserTest &#123;&#x2F;&#x2F; @Autowired&#x2F;&#x2F; @Qualifier(&quot;userServiceImpl02&quot;) @Resource(type &#x3D; UserServiceImpl01.class) IUserService userService; @Test public void test() &#123; userService.say(); &#125;&#125; 运行测试程序，控制台输出“I am UserServiceImpl01……………..”。通过在@Resource注解中指定注入的实现类来实现bean的注入。此外，还可以在@Resource注解中指定类名称。 总结 对比项 @Autowired @Resource 注解来源 Spring注解 JDK注解（JSR-250标准注解，属于J2EE） 装配方式 默认byType，其次byName 默认byName，其次byType 属性 required name、type 作用范围 字段、setter方法、构造器 字段、setter方法 1.处理这2个注解的BeanPostProcessor不一样CommonAnnotationBeanPostProcessor是处理@ReSource注解的；AutoWiredAnnotationBeanPostProcessor是处理@AutoWired注解的。 2.注入方式不同@Autowired只按照byType注入；@Resource默认按byName自动注入，也提供按照byType注入。 3.属性不同@Autowired按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。@Resource有两个中重要的属性：name和type。name属性指定byName，如果没有指定name属性，当注解标注在字段上，即默认取字段的名称作为bean名称寻找依赖对象，当注解标注在属性的setter方法上，即默认取属性名作为bean名称寻找依赖对象。需要注意的是，@Resource如果没有指定name属性，并且按照默认的名称仍然找不到依赖对象时， @Resource注解会回退到按类型装配。但一旦指定了name属性，就只能按名称装配了。 4.装配顺序不同@Autowired：首先通过类型来查找bean，如果只找到一个，则直接注入，如果没有找到，则抛出异常；如果找到多个bean也会抛出异常。解决方法一：可以在配置bean的时候加上@Primary注解，来提高优先级，这样就不会报错；解决方法二：会默认使用字段名来匹配，如果没有匹配上，抛出异常。如果需要直接通过bean的id来查找，可以配合@Qualifier来使用，没有找到抛出异常。这里重点需要指出，使用@Autowired 是有优先级的，@Qualifier &gt; 按类型找（如果找到多个继续使用之后的策略） &gt; @Primary &gt; 按名字找@Autowired通过设置required=false，在没有找到bean的情况下，不会抛出异常。 @Resource装配顺序：如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"@Autowired","slug":"Autowired","permalink":"https://born2do.github.io/tags/Autowired/"},{"name":"@Resource","slug":"Resource","permalink":"https://born2do.github.io/tags/Resource/"}],"author":"chenhy"},{"title":"【数据库】联合主键","slug":"【数据库】联合主键","date":"2021-04-11T12:13:50.000Z","updated":"2021-04-11T12:14:10.791Z","comments":true,"path":"2021/04/11/【数据库】联合主键/","link":"","permalink":"https://born2do.github.io/2021/04/11/%E3%80%90%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/","excerpt":"","text":"无意间看到数据库中有张表的主键有三个，没记错的话应该是“每张表都只有一个主键，唯一、不为空”，随后搜索查阅了一下。看到以下结论： 1、数据库的每张表只能有一个主键，不可能有多个主键。 2、所谓的一张表多个主键，我们称之为联合主键。 注：联合主键：就是用多个字段一起作为一张表的主键。 3、主键的主键的作用是保证数据的唯一性和完整性，同时通过主键检索表能够增加检索速度。 12345678910111213CREATE TABLE STUDENT ( STU_ID CHARACTER(4) NOT NULL, STU_NAME VARCHAR(32) NOT NULL, STU_MSG VARCHAR(128), STU_SEX VARCHAR(4), PRIMARY KEY (INST_ID, INST_RESP_CODE))","categories":[{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"联合主键","slug":"联合主键","permalink":"https://born2do.github.io/tags/%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/"}],"author":"chenhy"},{"title":"数据库易混述语总结","slug":"数据库易混述语总结","date":"2021-04-11T12:09:14.000Z","updated":"2021-04-11T12:10:34.561Z","comments":true,"path":"2021/04/11/数据库易混述语总结/","link":"","permalink":"https://born2do.github.io/2021/04/11/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD%E6%80%BB%E7%BB%93/","excerpt":"","text":"DB，数据库（DataBase） DBMS，数据库管理系统（DataBase Management System） DBA，数据库管理员（DataBase Administrator） DBS，数据库系统（DataBase System） DBS是由DB、DBMS（及其应用开发工具）、应用数据和DBA组成的存储、管理、处理和维护数据的系统。 外模式外模式又称子模式或用户模式，对应于用户级。它是某个或某几个用户所看到的数据库的数据视图，是与某一应用有关的数据的逻辑表示。外模式是从模式导出的一个子集，包含模式中允许特定用户使用的那部分数据。用户可以通过外模式描述语言来描述、定义对应于用户的数据记录(外模式)，也可以利用数据操纵语言(Data Manipulation Language，DML)对这些数据记录进行操作。外模式反映了数据库系统的用户观。 模式模式又称概念模式或逻辑模式，对应于概念级。它是由数据库设计者综合所有用户的数据，按照统一的观点构造的全局逻辑结构，是对数据库中全部数据的逻辑结构和特征的总体描述，是所有用户的公共数据视图(全局视图)。它是由数据库管理系统提供的数据模式描述语言(Data Description Language，DDL)来描述、定义的。概念模式反映了数据库系统的整体观。 内模式内模式又称存储模式，对应于物理级。它是数据库中全体数据的内部表示或底层描述，是数据库最低一级的逻辑描述，它描述了数据在存储介质上的存储方式和物理结构，对应着实际存储在外存储介质上的数据库。内模式由内模式描述语言来描述、定义的。内模式反映了数据库系统的存储观。 外模式/模式映象模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。 对应于同一个模式可以有任意多个外模式。对于每一个外模式，数据库系统都有一个外模式/模式映像，它定义了该外模式与模式之间的对应关系。这些映像定义通常包含在各模式的描述中。 当模式改变时，由数据库管理员对各个外模式/模式映像作相应的改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序可以不必修改，保证了数据与程序的逻辑独立性。 模式/内模式映像数据库中不仅只有一个模式，而且也只有一个内模式，所以模式/内模式映像是唯一的，由它定义数据库全局逻辑结构与存储结构之间的对应关系。模式/内模式映像定义通常包含在模式描述中。当数据库的存储设备和存储方法发生变化时，数据库管理员对模式/内模式映像要做相应的改变，使模式保持不变，从而应用程序也不变，保证了数据与程序的物理独立性，简称为数据的物理独立性。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"易混述语","slug":"易混述语","permalink":"https://born2do.github.io/tags/%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD/"}],"author":"chenhy"},{"title":"数据表空间和索引表空间","slug":"数据表空间和索引表空间","date":"2021-04-10T11:51:25.000Z","updated":"2021-04-10T11:51:59.518Z","comments":true,"path":"2021/04/10/数据表空间和索引表空间/","link":"","permalink":"https://born2do.github.io/2021/04/10/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/","excerpt":"","text":"Oracle强烈建议，任何一个应用程序的库表至少需要创建两个表空间，其中之一用于存储表数据，而另一个用于存储表索引数据。因为如果将表数据和索引数据放在一起，表数据的I/O操作和索引的I/O操作将产生影响系统性能的I/O竞争，降低系统的响应效率。将表数据和索引数据存放在不同的表空间中（如一个为APP_DATA，另一个为APP_IDX），并在物理层面将这两个表空间的数据文件放在不同的物理磁盘上，就可以避免这种竞争了。 oracle中，数据表空间和索引表空间的区别是表和索引分开在不同的表空间存放,放表的叫数据表空间, 放索引的叫索引表空间, 如果能分别存放在不同的硬盘上性能会更好,其与代码并无关系。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据表空间和索引表空间","slug":"数据表空间和索引表空间","permalink":"https://born2do.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/"}],"author":"chenhy"},{"title":"【Java】为什么Java中Date类的很多方法被废弃了","slug":"【Java】为什么Java中Date类的很多方法被废弃了","date":"2021-04-10T11:33:41.000Z","updated":"2021-04-10T11:39:37.944Z","comments":true,"path":"2021/04/10/【Java】为什么Java中Date类的很多方法被废弃了/","link":"","permalink":"https://born2do.github.io/2021/04/10/%E3%80%90Java%E3%80%91%E4%B8%BA%E4%BB%80%E4%B9%88Java%E4%B8%ADDate%E7%B1%BB%E7%9A%84%E5%BE%88%E5%A4%9A%E6%96%B9%E6%B3%95%E8%A2%AB%E5%BA%9F%E5%BC%83%E4%BA%86/","excerpt":"","text":"Date类的很多方法被废弃，归根结底是有缺陷、有问题，已经被新的、更完善的类、方法替代了。 Date类中有很多方法都标有删除线，是因为Date类在设计中有很多问题，如getYear指的是1900年以来的年数，getMonth是从0开始的。事实上，不止Date类，Java的日期时间相关类都存在设计问题。Java的日期类库有些混乱，据说已经重新设计了两次。 Date类已经逐渐被Calendar类所取代。 int getDate() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_MONTH) 取代。 int getDay() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.DAY_OF_WEEK) 取代。 int getHours() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.HOUR_OF_DAY) 取代。 int getMinutes() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.MINUTE) 取代。 int getMonth() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.MONTH) 取代。 int getSeconds() 已过时。从 JDK 1.1 开始，由 Calendar.get(Calendar.SECOND) 取代。 1234567891011public class Time &#123; public static void main(String[] args) &#123; Date date = new Date(); System.out.println(date.getMonth()); Calendar calendar = Calendar.getInstance(); System.out.println(calendar.get(Calendar.MONTH)); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"Date","slug":"Date","permalink":"https://born2do.github.io/tags/Date/"}],"author":"chenhy"},{"title":"元字符及其描述","slug":"元字符及其描述","date":"2021-04-09T11:58:34.000Z","updated":"2021-04-09T11:59:43.537Z","comments":true,"path":"2021/04/09/元字符及其描述/","link":"","permalink":"https://born2do.github.io/2021/04/09/%E5%85%83%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%85%B6%E6%8F%8F%E8%BF%B0/","excerpt":"","text":"元字符 描述 \\ 将下一个字符标记符、或一个向后引用、或一个八进制转义符。例如，“\\n”匹配\\n。“\\n”匹配换行符。序列“\\”匹配“\\”而“(”则匹配“(”。即相当于多种编程语言中都有的“转义字符”的概念。 ^ 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配“\\n”或“\\r”之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp对象的Multiline属性，$也匹配“\\n”或“\\r”之前的位置。 * 匹配前面的子表达式任意次。例如，zo能匹配“z”，也能匹配“zo”以及“zoo”。等价于o{0,} + 匹配前面的子表达式一次或多次(大于等于1次）。例如，“zo+”能匹配“zo”以及“zoo”，但不能匹配“z”。+等价于{1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”中的“do”。?等价于{0,1}。 {n} n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o。 {n,} n是一个非负整数。至少匹配n次。例如，“o{2,}”不能匹配“Bob”中的“o”，但能匹配“foooood”中的所有o。“o{1,}”等价于“o+”。“o{0,}”则等价于“o*”。 {n,m} m和n均为非负整数，其中n&lt;=m。最少匹配n次且最多匹配m次。例如，“o{1,3}”将匹配“fooooood”中的前三个o为一组，后三个o为一组。“o{0,1}”等价于“o?”。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符（*,+,?，{n}，{n,}，{n,m}）后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串“oooo”，“o+”将尽可能多的匹配“o”，得到结果[“oooo”]，而“o+?”将尽可能少的匹配“o”，得到结果 [‘o’, ‘o’, ‘o’, ‘o’] .点 匹配除“\\r\\n”之外的任何单个字符。要匹配包括“\\r\\n”在内的任何字符，请使用像“[\\s\\S]”的模式。 (pattern) 匹配pattern并获取这一匹配。所获取的匹配可以从产生的Matches集合得到，在VBScript中使用SubMatches集合，在JScript中则使用$0…$9属性。要匹配圆括号字符，请使用“(”或“)”。 (?:pattern) 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分时很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 (?=pattern) 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。 (?&lt;=pattern) 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 (?&lt;!pattern) 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?&lt;!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 此处用或任意一项都不能超过2位，如“(?&lt;!95|98|NT|20)Windows正确，“(?&lt;!95|980|NT|20)Windows 报错，若是单独使用则无限制，如(?&lt;!2000)Windows 正确匹配 x|y 匹配x或y。例如，“z|food”能匹配“z”或“food”(此处请谨慎)。“[zf]ood”则匹配“zood”或“food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如，“[abc]”可以匹配“plain”中的“a”。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如，“[^abc]”可以匹配“plain”中的“plin”。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，“[a-z]”可以匹配“a”到“z”范围内的任意小写字母字符。 注意:只有连字符在字符组内部时,并且出现在两个字符之间时,才能表示字符的范围; 如果出字符组的开头,则只能表示连字符本身. [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，“[^a-z]”可以匹配任何不在“a”到“z”范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置（即正则表达式的“匹配”有两种概念，一种是匹配字符，一种是匹配位置，这里的\\b就是匹配位置的）。例如，“er\\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。 \\B 匹配非单词边界。“er\\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。 \\cx 匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。 \\d 匹配一个数字字符。等价于[0-9]。grep 要加上-P，perl正则支持 \\D 匹配一个非数字字符。等价于[^0-9]。grep要加上-P，perl正则支持 \\f 匹配一个换页符。等价于\\x0c和\\cL。 \\n 匹配一个换行符。等价于\\x0a和\\cJ。 \\r 匹配一个回车符。等价于\\x0d和\\cM。 \\s 匹配任何不可见字符，包括空格、制表符、换页符等等。等价于[ \\f\\n\\r\\t\\v]。 \\S 匹配任何可见字符。等价于[^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于\\x09和\\cI。 \\v 匹配一个垂直制表符。等价于\\x0b和\\cK。 \\w 匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的”单词”字符使用Unicode字符集。 \\W 匹配任何非单词字符。等价于“[^A-Za-z0-9_]”。","categories":[{"name":"元字符","slug":"元字符","permalink":"https://born2do.github.io/categories/%E5%85%83%E5%AD%97%E7%AC%A6/"}],"tags":[{"name":"元字符","slug":"元字符","permalink":"https://born2do.github.io/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"}],"author":"chenhy"},{"title":"【Java】栈内存与堆内存的区别","slug":"【Java】栈内存与堆内存的区别","date":"2021-04-09T11:57:28.000Z","updated":"2021-04-09T11:58:14.549Z","comments":true,"path":"2021/04/09/【Java】栈内存与堆内存的区别/","link":"","permalink":"https://born2do.github.io/2021/04/09/%E3%80%90Java%E3%80%91%E6%A0%88%E5%86%85%E5%AD%98%E4%B8%8E%E5%A0%86%E5%86%85%E5%AD%98%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"栈内存与堆内存都是Java用来存储数据的地方。与C++不同，Java自动管理栈和堆，程序员不需要也不能够直接对栈或堆进行设置。 堆，用于存储对象。当Java程序使用 new 关键字创建对象时，堆内存会开辟出相应的内存来存储该对象，这些对象不需要被显式地释放，会有垃圾回收机制来处理这些长期没有被使用的对象。 优点：他是在运行时动态分配内存大小，不需要人工管理垃圾数据，会有垃圾回收机制进行相应管理。 缺点：同样，因为是在运行时动态分配内存大小，故而存取速度较慢。 栈，主要用于存放一些基本数据类型的变量和对象引用。 优点：1）存取速度快于堆，仅次于寄存器。2）栈数据可共享。 缺点：存放在栈中的数据大小与生存期必须是确定的，缺乏灵活性。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"栈内存","slug":"栈内存","permalink":"https://born2do.github.io/tags/%E6%A0%88%E5%86%85%E5%AD%98/"},{"name":"堆内存","slug":"堆内存","permalink":"https://born2do.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"}],"author":"chenhy"},{"title":"【IDEA社区版】webapp下静态资源无法访问","slug":"【IDEA社区版】webapp下静态资源无法访问","date":"2021-04-08T13:50:32.000Z","updated":"2021-04-08T13:51:07.181Z","comments":true,"path":"2021/04/08/【IDEA社区版】webapp下静态资源无法访问/","link":"","permalink":"https://born2do.github.io/2021/04/08/%E3%80%90IDEA%E7%A4%BE%E5%8C%BA%E7%89%88%E3%80%91webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/","excerpt":"","text":"一开始认为是webapp下的静态资源被拦截了，但是修改了springmvc.xml以及web.xml对静态资源的控制仍然没有反应。 打开浏览器的开发者模式，发现静态资源全部没有访问到，路径直接是 http://localhost:8080/css/*.css ，路径明显是错误的。 后改用绝对路径引入静态资源，页面正常显示。 1&lt;script src=&quot;$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js&quot;&gt;&lt;/script&gt; 说明之前使用的相对路径引入资源是错误的，修改相对路径为../js/jquery.min.js，页面也可正常显示。 以此可以认为在引入静态资源时，默认当前路径为WEB-INF。但是以相对路径引入静态资源，IDEA会显示报错，即使该项目是可以正常启动并显示的。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"webapp下静态资源无法访问","slug":"webapp下静态资源无法访问","permalink":"https://born2do.github.io/tags/webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/"}],"author":"chenhy"},{"title":"【Java】在写文件时进行输出换行","slug":"【Java】在写文件时进行输出换行","date":"2021-04-07T13:56:25.000Z","updated":"2021-04-07T13:56:44.319Z","comments":true,"path":"2021/04/07/【Java】在写文件时进行输出换行/","link":"","permalink":"https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91%E5%9C%A8%E5%86%99%E6%96%87%E4%BB%B6%E6%97%B6%E8%BF%9B%E8%A1%8C%E8%BE%93%E5%87%BA%E6%8D%A2%E8%A1%8C/","excerpt":"","text":"背景最近在做爬虫，需要将网页落地到本地的Markdown文档中。由于是多次写入，导致上一篇文档的结尾与下一篇文档的开头紧密连接在一起，格式出问题了。 解决之所以会连接在一起，是因为没有对文章末进行换行处理，处理一下就好。 在Windows操作系统中，”\\r\\n”为回车换行；而在Linux系统中，”\\n”即可。 为了兼容这两种情况，我们使用如下方法获取换行符： 1System.getProperty(&quot;line.separator&quot;)","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://born2do.github.io/tags/IO/"}],"author":"chenhy"},{"title":"【Java】Html转Markdown格式","slug":"【Java】Html转Markdown格式","date":"2021-04-07T13:55:28.000Z","updated":"2021-04-07T13:56:00.418Z","comments":true,"path":"2021/04/07/【Java】Html转Markdown格式/","link":"","permalink":"https://born2do.github.io/2021/04/07/%E3%80%90Java%E3%80%91Html%E8%BD%ACMarkdown%E6%A0%BC%E5%BC%8F/","excerpt":"","text":"背景最近在做爬虫项目，其中一个需求是将网页上的帮助文档，下载至本地并形成Markdown文档，方便离线查阅。 探索及解决找到两个具有该功能的Java类库，如下 12345678910&lt;dependency&gt; &lt;groupId&gt;com.kotcrab.remark&lt;&#x2F;groupId&gt; &lt;artifactId&gt;remark&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.houbb&lt;&#x2F;groupId&gt; &lt;artifactId&gt;html2md&lt;&#x2F;artifactId&gt; &lt;version&gt;0.0.1&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 相比较之下，我选择了remark。使用html2md进行格式转换之后，最终文档与预期的格式差异较大。而remark转换后则较为中规中矩，比较符合实际使用中的Markdown语法。 123// 将获取到的内容从HTML格式转换为Markdown格式Remark remark = new Remark();content = remark.convert(content); 转换前的Html 123&lt;h3 id=&quot;12-总体架构&quot;&gt;1.2 总体架构&lt;/h3&gt; &lt;p&gt;WebMagic的结构分为&lt;code&gt;Downloader&lt;/code&gt;、&lt;code&gt;PageProcessor&lt;/code&gt;、&lt;code&gt;Scheduler&lt;/code&gt;、&lt;code&gt;Pipeline&lt;/code&gt;四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。&lt;/p&gt; &lt;p&gt;而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。&lt;/p&gt; 转换后的Markdown 12345### 1.2 总体架构 ###WebMagic的结构分为`Downloader`、`PageProcessor`、`Scheduler`、`Pipeline`四大组件，并由Spider将它们彼此组织起来。这四大组件对应爬虫生命周期中的下载、处理、管理和持久化等功能。WebMagic的设计参考了Scapy，但是实现方式更Java化一些。而Spider则将这几个组件组织起来，让它们可以互相交互，流程化的执行，可以认为Spider是一个大的容器，它也是WebMagic逻辑的核心。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"Html转Markdown","slug":"Html转Markdown","permalink":"https://born2do.github.io/tags/Html%E8%BD%ACMarkdown/"}],"author":"chenhy"},{"title":"【Java】运算符的优先级和结合顺序","slug":"【Java】运算符的优先级和结合顺序","date":"2021-04-06T15:13:26.000Z","updated":"2021-04-06T15:15:34.718Z","comments":true,"path":"2021/04/06/【Java】运算符的优先级和结合顺序/","link":"","permalink":"https://born2do.github.io/2021/04/06/%E3%80%90Java%E3%80%91%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E9%A1%BA%E5%BA%8F/","excerpt":"","text":"1级（左结合） () 圆括号；[]下标运算符；-&gt;指向结构体成员运算符；. 结构体成员运算符。 2级（右结合） !逻辑非运算符；~按位取反运算符；++前缀增量运算符；–前缀减量运算符；+正号运算符；-负号运算符；(类型)类型转换运算符；*指针运算符；&amp;地址运算符；sizeof长度运算符。 3级（左结合） *乘法运算符；/除法运算符；%取余运算符。 4级（左结合） +加法运算符；-减法运算符。 5级（左结合） &lt;&lt;左移运算符；&gt;&gt;右移运算符。 6级（左结合） &lt;、&lt;=、&gt;、&gt;=关系运算符。 7级（左结合） ==等于运算符；!=不等于运算符。 8级（左结合） &amp;按位与运算符。 9级（左结合） ^按位异或运算符。 10级（左结合） |按位或运算符。 11级（左结合） &amp;&amp;逻辑与运算符。 12级（左结合） ||逻辑或运算符。 13级（右结合） ? :条件运算符。 14级（右结合） =、 +=、 -=、 *=、 /=、 %=、 &amp;=、 ^=、 |=、 &lt;&lt;=、 &gt;&gt;=赋值运算符。 15级（左结合） ,逗号运算符。","categories":[{"name":"C语言","slug":"C语言","permalink":"https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"}],"tags":[{"name":"运算符优先级","slug":"运算符优先级","permalink":"https://born2do.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"}],"author":"chenhy"},{"title":"【log4j】logger.isTraceEnabled()","slug":"【log4j】logger-isTraceEnabled","date":"2021-04-05T08:41:04.000Z","updated":"2021-04-05T08:41:29.459Z","comments":true,"path":"2021/04/05/【log4j】logger-isTraceEnabled/","link":"","permalink":"https://born2do.github.io/2021/04/05/%E3%80%90log4j%E3%80%91logger-isTraceEnabled/","excerpt":"","text":"我们经常可以看到，在使用日志框架时，会有如下写法： 123if (logger.isTraceEnabled()) &#123; logger.trace(&quot;trace&quot;);&#125; 为什么要这样写呢？这样写有什么好处？首先我们来看下这两个方法的源码： 123public boolean isTraceEnabled() &#123; return super.repository.isDisabled(5000) ? false : Level.TRACE.isGreaterOrEqual(this.getEffectiveLevel());&#125; 12345678public void trace(Object message) &#123; if (!super.repository.isDisabled(5000)) &#123; if (Level.TRACE.isGreaterOrEqual(this.getEffectiveLevel())) &#123; this.forcedLog(FQCN, Level.TRACE, message, (Throwable)null); &#125; &#125;&#125; 我们可以看到，在使用trace方法打印日志时，会有与isTraceEnabled方法中一样的方法调用，也就是说等同于在trace中调用了isTraceEnabled方法。那么为什么我们在使用时还要在外层进行一次判断呢？官方的说法是：出于效率考虑，看具体情况而定。我们就以下两种情况进行分析： 直接传入参数，无其他处理1logger.trace(&quot;trace&quot;); 对于这种情况，则完全没有必要在外层进行筛选判断。 传参数时引入了其他方法1logger.debug(&quot;The money is &quot; + getTotal()); 对于这种情况，则需要考虑考虑了。如果getTotal()方法是一个较为复杂的、计算量庞大的方法，则在外层进行一下判断就是很有必要的了。无论当前系统的日志级别为哪一等级，程序程序都会调用debug方法，会执行getTotal方法，只不过最后的结果可能是不打印日志而已（日志级别为info或更高）。debug中调用这个方法会消耗较大资源，得不偿失。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"https://born2do.github.io/tags/log4j/"}],"author":"chenhy"},{"title":"SLF4J日志级别","slug":"SLF4J日志级别","date":"2021-04-04T15:34:56.000Z","updated":"2021-04-04T15:35:57.663Z","comments":true,"path":"2021/04/04/SLF4J日志级别/","link":"","permalink":"https://born2do.github.io/2021/04/04/SLF4J%E6%97%A5%E5%BF%97%E7%BA%A7%E5%88%AB/","excerpt":"","text":"SLF4J将日志分为trace、debug、info、warn、error五个级别，每个级别对应记录不同的日志，对应不同的使用场景。优先级从高到低依次为trace、debug、info、warn、error，相对而言，打印的日志会越来越少。 trace: 一般用来追踪详细的程序运行流，比如程序的运行过程中，运行到了哪一个方法，进入了哪一条分支。通过trace程序的运行流程，可以判断程序是否按照期望的逻辑在运行。 debug: 这类日志往往用在判断是否有出现bug的场景，且往往记录了代码运行的详细信息，比如方法调用传入的参数信息。 info：用来记录程序运行的一些关键信息，它不像trace那样记录程序运行的整个流程，也不像debug那样为了解决问题而记录详细的信息。info记录的是整个系统的运行信息，比如系统运行到了哪一个阶段，到达了哪一个状态。 warn：用来记录一些警告信息。警告信息表示，程序进入了一个特殊的状态，在该状态下程序可以继续运行，但是不建议让程序进入该状态，因为该状态可能导致结果出现问题。 error：用来记录运行时的错误信息，表示程序运行过程中出现了需要被解决的问题，往往是一些异常。使用error日志的时候，一般会将详细的异常出现的原因记录。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"SLF4J","slug":"SLF4J","permalink":"https://born2do.github.io/tags/SLF4J/"}],"author":"chenhy"},{"title":"private final static Logger log= LoggerFactory.getLogger(HelloController.class);","slug":"private-final-static-Logger-log-LoggerFactory-getLogger-HelloController-class","date":"2021-03-30T11:15:53.000Z","updated":"2021-03-30T11:16:31.315Z","comments":true,"path":"2021/03/30/private-final-static-Logger-log-LoggerFactory-getLogger-HelloController-class/","link":"","permalink":"https://born2do.github.io/2021/03/30/private-final-static-Logger-log-LoggerFactory-getLogger-HelloController-class/","excerpt":"","text":"1private final static Logger logger= LoggerFactory.getLogger(HelloController.class); 设置为private是为了防止其他类使用当前类的日志对象；如果当前类需要被子类继承，并且都使用同一个日志对象时，可设置为protected 。 设置为static是为了让每个类中的日志对象只生成一份，日志对象是属于类的，不是属于具体的实例的。 设置成final是为了避免日志对象在运行时被修改。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"logback","slug":"logback","permalink":"https://born2do.github.io/tags/logback/"}],"author":"chenhy"},{"title":"【logback】SLF4J: Failed to load class org.slf4j.impl.StaticLoggerBinder.","slug":"【logback】SLF4J-Failed-to-load-class-org-slf4j-impl-StaticLoggerBinder","date":"2021-03-30T11:14:53.000Z","updated":"2021-03-30T11:15:27.484Z","comments":true,"path":"2021/03/30/【logback】SLF4J-Failed-to-load-class-org-slf4j-impl-StaticLoggerBinder/","link":"","permalink":"https://born2do.github.io/2021/03/30/%E3%80%90logback%E3%80%91SLF4J-Failed-to-load-class-org-slf4j-impl-StaticLoggerBinder/","excerpt":"","text":"测试logback，出现了如下报错： 12345SLF4J: Failed to load class &quot;org.slf4j.impl.StaticLoggerBinder&quot;.SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.Process finished with exit code 0 使用Maven构建的工程，logback的配置文件也都正常，但却报了上面的错误。仔细察看一番，发现从Maven仓库复制依赖时把scope也给带上了，pom文件中的范围是test，而我的调用代码写在main函数中（非test范围），所以报错了。解决办法：将pom文件中的scope给注释掉，重新加载一下依赖就好。 12345678910111213&lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;ch.qos.logback&#x2F;logback-classic --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt; &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt; &lt;version&gt;1.2.3&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt; &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt; &lt;version&gt;1.7.25&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"logback","slug":"logback","permalink":"https://born2do.github.io/tags/logback/"}],"author":"chenhy"},{"title":"【WebMagic】webmagic-selenium 找不到config.ini文件","slug":"【WebMagic】webmagic-selenium-找不到config-ini文件","date":"2021-03-29T15:44:42.000Z","updated":"2021-03-29T15:45:34.546Z","comments":true,"path":"2021/03/29/【WebMagic】webmagic-selenium-找不到config-ini文件/","link":"","permalink":"https://born2do.github.io/2021/03/29/%E3%80%90WebMagic%E3%80%91webmagic-selenium-%E6%89%BE%E4%B8%8D%E5%88%B0config-ini%E6%96%87%E4%BB%B6/","excerpt":"","text":"WebMagic原作者对于webmagic-selenium已经有较长时间没有更新了，但是我们又想要用这个来获取渲染的页面数据，该怎么办呢？鉴于Selenium 已经不再支持 PhantomJS，即使你使用了webmagic-selenium，并且添加了config.ini文件，程序仍然会报错。有人会说降低Selenium的 jar包的版本就好，但是近来即使你降低到最低版本也不行了，Selenium已经全部移除了PhantomJS的依赖，老版本也是如此。为此，我的建议是下载webmagic-selenium源码，然后修改剔除掉原有代码中对PhantomJS的使用，加入到自己的项目中使用即可。我主要做了两个文件的改动： 修改WebDriverPool.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176package com.born2do.webmagic.downloader.selenium;import org.openqa.selenium.WebDriver;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.remote.DesiredCapabilities;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.FileReader;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Properties;import java.util.concurrent.BlockingDeque;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.atomic.AtomicInteger;&#x2F;** * @author code4crafter@gmail.com &lt;br&gt; * Date: 13-7-26 &lt;br&gt; * Time: 下午1:41 &lt;br&gt; *&#x2F;class WebDriverPool &#123; private Logger logger &#x3D; LoggerFactory.getLogger(getClass()); private final static int DEFAULT_CAPACITY &#x3D; 5; private final int capacity; private final static int STAT_RUNNING &#x3D; 1; private final static int STAT_CLODED &#x3D; 2; private AtomicInteger stat &#x3D; new AtomicInteger(STAT_RUNNING); private WebDriver mDriver &#x3D; null; private static final String DEFAULT_CONFIG_FILE &#x3D; &quot;&#x2F;config.ini&quot;; private static final String DRIVER_FIREFOX &#x3D; &quot;firefox&quot;; private static final String DRIVER_CHROME &#x3D; &quot;chrome&quot;; protected static Properties sConfig; protected static DesiredCapabilities sCaps; &#x2F;** * Configure the GhostDriver, and initialize a WebDriver instance. This part * of code comes from GhostDriver. * https:&#x2F;&#x2F;github.com&#x2F;detro&#x2F;ghostdriver&#x2F;tree&#x2F;master&#x2F;test&#x2F;java&#x2F;src&#x2F;test&#x2F;java&#x2F;ghostdriver * * @author bob.li.0718@gmail.com * @throws IOException *&#x2F; public void configure() throws IOException &#123; &#x2F;&#x2F; Read config file sConfig &#x3D; new Properties(); &#x2F;&#x2F; String configFile &#x3D; DEFAULT_CONFIG_FILE; String configFile &#x3D; this.getClass().getResource(DEFAULT_CONFIG_FILE).getPath(); if (System.getProperty(&quot;selenuim_config&quot;)!&#x3D;null)&#123; configFile &#x3D; System.getProperty(&quot;selenuim_config&quot;); &#125; sConfig.load(new FileReader(configFile)); &#x2F;&#x2F; Prepare capabilities sCaps &#x3D; new DesiredCapabilities(); sCaps.setJavascriptEnabled(true); sCaps.setCapability(&quot;takesScreenshot&quot;, false); String driver &#x3D; sConfig.getProperty(&quot;driver&quot;, DRIVER_CHROME); ArrayList&lt;String&gt; cliArgsCap &#x3D; new ArrayList&lt;String&gt;(); cliArgsCap.add(&quot;--web-security&#x3D;false&quot;); cliArgsCap.add(&quot;--ssl-protocol&#x3D;any&quot;); cliArgsCap.add(&quot;--ignore-ssl-errors&#x3D;true&quot;); &#x2F;&#x2F; Start appropriate Driver if (driver.equals(DRIVER_FIREFOX)) &#123; mDriver &#x3D; new FirefoxDriver(sCaps); &#125; else if (driver.equals(DRIVER_CHROME)) &#123; mDriver &#x3D; new ChromeDriver(sCaps); &#125; &#125; &#x2F;** * check whether input is a valid URL * * @author bob.li.0718@gmail.com * @param urlString urlString * @return true means yes, otherwise no. *&#x2F; private boolean isUrl(String urlString) &#123; try &#123; new URL(urlString); return true; &#125; catch (MalformedURLException mue) &#123; return false; &#125; &#125; &#x2F;** * store webDrivers created *&#x2F; private List&lt;WebDriver&gt; webDriverList &#x3D; Collections .synchronizedList(new ArrayList&lt;WebDriver&gt;()); &#x2F;** * store webDrivers available *&#x2F; private BlockingDeque&lt;WebDriver&gt; innerQueue &#x3D; new LinkedBlockingDeque&lt;WebDriver&gt;(); public WebDriverPool(int capacity) &#123; this.capacity &#x3D; capacity; &#125; public WebDriverPool() &#123; this(DEFAULT_CAPACITY); &#125; &#x2F;** * * @return * @throws InterruptedException *&#x2F; public WebDriver get() throws InterruptedException &#123; checkRunning(); WebDriver poll &#x3D; innerQueue.poll(); if (poll !&#x3D; null) &#123; return poll; &#125; if (webDriverList.size() &lt; capacity) &#123; synchronized (webDriverList) &#123; if (webDriverList.size() &lt; capacity) &#123; &#x2F;&#x2F; add new WebDriver instance into pool try &#123; configure(); innerQueue.add(mDriver); webDriverList.add(mDriver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return innerQueue.take(); &#125; public void returnToPool(WebDriver webDriver) &#123; checkRunning(); innerQueue.add(webDriver); &#125; protected void checkRunning() &#123; if (!stat.compareAndSet(STAT_RUNNING, STAT_RUNNING)) &#123; throw new IllegalStateException(&quot;Already closed!&quot;); &#125; &#125; public void closeAll() &#123; boolean b &#x3D; stat.compareAndSet(STAT_RUNNING, STAT_CLODED); if (!b) &#123; throw new IllegalStateException(&quot;Already closed!&quot;); &#125; for (WebDriver webDriver : webDriverList) &#123; logger.info(&quot;Quit webDriver&quot; + webDriver); webDriver.quit(); webDriver &#x3D; null; &#125; &#125;&#125; 在resources目录下新增config.ini文件1234567# What WebDriver to use for the tests#driver&#x3D;firefoxdriver&#x3D;chrome#谷歌浏览器启动程序路径#chrome_exec_path&#x3D;D:\\chromedriver_win32\\chromedriver.exechrome_driver_loglevel&#x3D;DEBUG","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://born2do.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"WebMagic","slug":"WebMagic","permalink":"https://born2do.github.io/tags/WebMagic/"},{"name":"webmagic-selenium","slug":"webmagic-selenium","permalink":"https://born2do.github.io/tags/webmagic-selenium/"}],"author":"chenhy"},{"title":"【WebMagic】获取标签对象的属性值","slug":"【WebMagic】获取标签对象的属性值","date":"2021-03-29T15:43:56.000Z","updated":"2021-03-29T15:44:25.158Z","comments":true,"path":"2021/03/29/【WebMagic】获取标签对象的属性值/","link":"","permalink":"https://born2do.github.io/2021/03/29/%E3%80%90WebMagic%E3%80%91%E8%8E%B7%E5%8F%96%E6%A0%87%E7%AD%BE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E5%80%BC/","excerpt":"","text":"在使用WebMagic获取标签的过程中，如何获取到标签对象的属性值？ 在元素选择器中有两个参数，第一个参数是匹配标签的表达式，第二个参数就是属性的名字。 123// 获取div标签的data-card-value属性值String str = block.$(&quot;div&quot;, &quot;data-card-value&quot;).toString();System.out.println(&quot;data-card-value的属性值为：&quot; + str);","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://born2do.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"WebMagic","slug":"WebMagic","permalink":"https://born2do.github.io/tags/WebMagic/"}],"author":"chenhy"},{"title":"【WebMagic】解析获取JSON数据","slug":"【WebMagic】解析获取JSON数据","date":"2021-03-27T11:37:31.000Z","updated":"2021-03-27T11:37:56.926Z","comments":true,"path":"2021/03/27/【WebMagic】解析获取JSON数据/","link":"","permalink":"https://born2do.github.io/2021/03/27/%E3%80%90WebMagic%E3%80%91%E8%A7%A3%E6%9E%90%E8%8E%B7%E5%8F%96JSON%E6%95%B0%E6%8D%AE/","excerpt":"","text":"WebMagic为我们提供了JsonPathSelector用来提取JSON数据，具体用法参见下方的Demo 。 12345678910111213141516171819package com.born2do.code;import us.codecraft.webmagic.selector.JsonPathSelector;/** * @author chenhy * @date 2021/3/27 */public class WebMagicDemo01 &#123; public static void main(String[] args) &#123; String json = &quot;&#123;\\&quot;mode\\&quot;:\\&quot;xml\\&quot;,\\&quot;code\\&quot;:\\&quot; &lt;dependency&gt;\\\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\\\n &lt;optional&gt;true&lt;/optional&gt;\\\\n &lt;/dependency&gt;\\\\n\\\\n\\\\n &lt;build&gt;\\\\n &lt;plugins&gt;\\\\n &lt;plugin&gt;\\\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\\\n &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\\\\n &lt;configuration&gt;\\\\n &lt;excludes&gt;\\\\n &lt;exclude&gt;\\\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\\\n &lt;/exclude&gt;\\\\n &lt;/excludes&gt;\\\\n &lt;/configuration&gt;\\\\n &lt;/plugin&gt;\\\\n &lt;/plugins&gt;\\\\n &lt;/build&gt;\\&quot;,\\&quot;heightLimit\\&quot;:true,\\&quot;margin\\&quot;:true,\\&quot;id\\&quot;:\\&quot;Wptpj\\&quot;&#125;\\n&quot;; System.out.println(&quot;原JSON数据：\\n&quot; + json); // 构造函数中的参数jsonPathStr为匹配规则 JsonPathSelector jsonPathSelector = new JsonPathSelector(&quot;$.code&quot;); System.out.println(&quot;获取到的JSON数据中code的属性值：\\n&quot; + jsonPathSelector.select(json)); &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627原JSON数据：&#123;&quot;mode&quot;:&quot;xml&quot;,&quot;code&quot;:&quot; &lt;dependency&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\n &lt;optional&gt;true&lt;/optional&gt;\\n &lt;/dependency&gt;\\n\\n\\n &lt;build&gt;\\n &lt;plugins&gt;\\n &lt;plugin&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\\n &lt;configuration&gt;\\n &lt;excludes&gt;\\n &lt;exclude&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\n &lt;/exclude&gt;\\n &lt;/excludes&gt;\\n &lt;/configuration&gt;\\n &lt;/plugin&gt;\\n &lt;/plugins&gt;\\n &lt;/build&gt;&quot;,&quot;heightLimit&quot;:true,&quot;margin&quot;:true,&quot;id&quot;:&quot;Wptpj&quot;&#125;获取到的JSON数据中code的属性值：&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludes&gt; &lt;exclude&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;/exclude&gt; &lt;/excludes&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt;","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://born2do.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"WebMagic","slug":"WebMagic","permalink":"https://born2do.github.io/tags/WebMagic/"}],"author":"chenhy"},{"title":"【WebMagic】抓取前端渲染的页面","slug":"【WebMagic】抓取前端渲染的页面","date":"2021-03-27T11:36:31.000Z","updated":"2021-03-27T11:37:13.413Z","comments":true,"path":"2021/03/27/【WebMagic】抓取前端渲染的页面/","link":"","permalink":"https://born2do.github.io/2021/03/27/%E3%80%90WebMagic%E3%80%91%E6%8A%93%E5%8F%96%E5%89%8D%E7%AB%AF%E6%B8%B2%E6%9F%93%E7%9A%84%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"随着AJAX技术不断的普及，以及现在AngularJS这种Single-page application框架的出现，现在js渲染出的页面越来越多。对于爬虫来说，这种页面是比较讨厌的：仅仅提取HTML内容，往往无法拿到有效的信息。那么如何处理这种页面呢？总的来说有两种做法： 在抓取阶段，在爬虫中内置一个浏览器内核，执行js渲染页面后，再抓取。这方面对应的工具有Selenium、HtmlUnit或者PhantomJs。但是这些工具都存在一定的效率问题，同时也不是那么稳定。好处是编写规则同静态页面一样。 因为js渲染页面的数据也是从后端拿到，而且基本上都是AJAX获取，所以分析AJAX请求，找到对应数据的请求，也是比较可行的做法。而且相对于页面样式，这种接口变化可能性更小。缺点就是找到这个请求，并进行模拟，是一个相对困难的过程，也需要相对多的分析经验。 方法一是通过执行js渲染页面获取静态页面来抓取数据，而方法二则是找规律找到目标数据的请求URL来获取数据。本次着重讲解方法一，这种方式相对来说较为简单。 环境安装 谷歌浏览器+驱动下载谷歌浏览器，然后下载该浏览器对应版本的驱动。查看谷歌浏览器版本：chrome://settings/help驱动下载地址：源地址：http://chromedriver.storage.googleapis.com/index.html国内镜像：http://npm.taobao.org/mirrors/chromedriver/ 项目搭建我使用的是SpringBoot框架，项目的目录结构如下：各源文件如下：pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt; &lt;version&gt;2.4.0&lt;&#x2F;version&gt; &lt;&#x2F;parent&gt; &lt;groupId&gt;com.born2do&lt;&#x2F;groupId&gt; &lt;artifactId&gt;crawler&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;8&lt;&#x2F;maven.compiler.target&gt; &lt;webmagic.version&gt;0.7.4&lt;&#x2F;webmagic.version&gt; &lt;&#x2F;properties&gt; &lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-web --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-data-jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.boot&#x2F;spring-boot-starter-test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;8.0.15&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;us.codecraft&#x2F;webmagic-core --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;&#x2F;groupId&gt; &lt;artifactId&gt;webmagic-core&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;webmagic.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;us.codecraft&#x2F;webmagic-extension --&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;&#x2F;groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;&#x2F;artifactId&gt; &lt;version&gt;$&#123;webmagic.version&#125;&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.google.guava&#x2F;guava --&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;&#x2F;groupId&gt; &lt;artifactId&gt;guava&lt;&#x2F;artifactId&gt; &lt;version&gt;30.0-jre&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.apache.commons&#x2F;commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-lang3&lt;&#x2F;artifactId&gt; &lt;version&gt;3.9&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;com.kotcrab.remark&#x2F;remark --&gt; &lt;dependency&gt; &lt;groupId&gt;com.kotcrab.remark&lt;&#x2F;groupId&gt; &lt;artifactId&gt;remark&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.seleniumhq.selenium&#x2F;selenium-java --&gt; &lt;dependency&gt; &lt;groupId&gt;org.seleniumhq.selenium&lt;&#x2F;groupId&gt; &lt;artifactId&gt;selenium-java&lt;&#x2F;artifactId&gt; &lt;version&gt;2.33.0&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt;&lt;&#x2F;project&gt; CrawlerOnSpringBoot2Doc.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677package com.born2do.task;import com.born2do.webmagic.downloader.selenium.SeleniumDownloader;import com.overzealous.remark.Remark;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Spider;import us.codecraft.webmagic.processor.PageProcessor;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.Paths;import java.util.List;&#x2F;** * 获取《SpringBoot2核心技术与响应式编程》教学文档 * 说明：“语雀”前端页面较为复杂，数据有多层加密，且主要由Ajax渲染页面数据，在这里并没有对代码块以及思维导图进行进一步处理，需人工处理 * * @author chenhy * @date 2021&#x2F;3&#x2F;22 *&#x2F;@Componentpublic class CrawlerOnSpringBoot2Doc implements PageProcessor &#123; private static final String website &#x3D; &quot;https:&#x2F;&#x2F;www.yuque.com&#x2F;atguigu&#x2F;springboot&quot;; private static final String file &#x3D; &quot;D:\\\\SpringBoot2核心技术与响应式编程.md&quot;; private Site site &#x3D; Site.me().setCharset(&quot;UTF8&quot;) &#x2F;&#x2F; 编码格式 .setTimeOut(1000 * 30) &#x2F;&#x2F; 超时时间 .setRetrySleepTime(1000 * 5) &#x2F;&#x2F; 重试时间间隔 .setRetryTimes(10); &#x2F;&#x2F; 重试次数 @Override public void process(Page page) &#123; &#x2F;&#x2F; 获取所有目录的url，并加入爬虫队列中 if (website.equals(page.getUrl().toString())) &#123; List&lt;String&gt; urls &#x3D; page.getHtml().xpath(&quot;&#x2F;&#x2F;span[@class&#x3D;&#39;name&#39;]&quot;).links().all(); for (String url : urls) &#123; page.addTargetRequest(url); &#125; &#125; else &#123; &#x2F;&#x2F; 获取内容 String content &#x3D; page.getHtml().xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;index-module_title_1s0gC&#39;]&quot;).toString() + page.getHtml().xpath(&quot;&#x2F;&#x2F;div[@class&#x3D;&#39;yuque-doc-content&#39;]&quot;).toString(); &#x2F;&#x2F; 将获取到的内容从HTML格式转换为Markdown格式 Remark remark &#x3D; new Remark(); content &#x3D; remark.convert(content); page.putField(&quot;content&quot;, content); System.out.println(page.getUrl() + &quot; download over!&quot;); &#125; &#125; @Override public Site getSite() &#123; return site; &#125; @Scheduled(fixedDelay &#x3D; 1000 * 60 * 60 * 24) private void mainProcess() throws IOException &#123; Path filePath &#x3D; Paths.get(file); if (Files.exists(filePath)) &#123; Files.delete(filePath); &#125; Files.createFile(filePath); Spider.create(new CrawlerOnSpringBoot2Doc()) .addUrl(website) .setDownloader(new SeleniumDownloader(&quot;D:\\\\chromedriver_win32\\\\chromedriver.exe&quot;)) .thread(1) .addPipeline(new MarkdownPipeLine(filePath)) .run(); System.out.println(&quot;process is over!&quot;); &#125;&#125; MarkdownPipeLine.java 123456789101112131415161718192021222324252627282930313233343536373839package com.born2do.task;import org.springframework.stereotype.Component;import us.codecraft.webmagic.ResultItems;import us.codecraft.webmagic.Task;import us.codecraft.webmagic.pipeline.Pipeline;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.StandardOpenOption;import java.util.Map;&#x2F;** * @author chenhy * @date 2021&#x2F;3&#x2F;21 *&#x2F;public class MarkdownPipeLine implements Pipeline &#123; private Path filePath; public MarkdownPipeLine(Path filePath) &#123; this.filePath &#x3D; filePath; &#125; @Override public void process(ResultItems resultItems, Task task) &#123; Map&lt;String, Object&gt; result &#x3D; resultItems.getAll(); String content &#x3D; (String) result.get(&quot;content&quot;); try &#123; Files.write(filePath, content.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND); &#x2F;&#x2F; 换行 Files.write(filePath, System.getProperty(&quot;line.separator&quot;).getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; SeleniumDownloader.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135package com.born2do.webmagic.downloader.selenium;import org.openqa.selenium.By;import org.openqa.selenium.Cookie;import org.openqa.selenium.WebDriver;import org.openqa.selenium.WebElement;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Request;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.Task;import us.codecraft.webmagic.downloader.Downloader;import us.codecraft.webmagic.selector.Html;import us.codecraft.webmagic.selector.PlainText;import java.io.Closeable;import java.io.IOException;import java.util.Map;&#x2F;** * 使用Selenium调用浏览器进行渲染。目前仅支持chrome。&lt;br&gt; * 需要下载Selenium driver支持。&lt;br&gt; * * @author code4crafter@gmail.com &lt;br&gt; * Date: 13-7-26 &lt;br&gt; * Time: 下午1:37 &lt;br&gt; *&#x2F;public class SeleniumDownloader implements Downloader, Closeable &#123; private volatile WebDriverPool webDriverPool; private Logger logger &#x3D; LoggerFactory.getLogger(getClass()); private int sleepTime &#x3D; 0; private int poolSize &#x3D; 1; private static final String DRIVER_PHANTOMJS &#x3D; &quot;phantomjs&quot;; &#x2F;** * 新建 * * @param chromeDriverPath chromeDriverPath *&#x2F; public SeleniumDownloader(String chromeDriverPath) &#123; System.getProperties().setProperty(&quot;webdriver.chrome.driver&quot;, chromeDriverPath); &#125; &#x2F;** * Constructor without any filed. Construct PhantomJS browser * * @author bob.li.0718@gmail.com *&#x2F; public SeleniumDownloader() &#123; &#x2F;&#x2F; System.setProperty(&quot;phantomjs.binary.path&quot;, &#x2F;&#x2F; &quot;&#x2F;Users&#x2F;Bingo&#x2F;Downloads&#x2F;phantomjs-1.9.7-macosx&#x2F;bin&#x2F;phantomjs&quot;); &#125; &#x2F;** * set sleep time to wait until load success * * @param sleepTime sleepTime * @return this *&#x2F; public SeleniumDownloader setSleepTime(int sleepTime) &#123; this.sleepTime &#x3D; sleepTime; return this; &#125; @Override public Page download(Request request, Task task) &#123; checkInit(); WebDriver webDriver; try &#123; webDriver &#x3D; webDriverPool.get(); &#125; catch (InterruptedException e) &#123; logger.warn(&quot;interrupted&quot;, e); return null; &#125; logger.info(&quot;downloading page &quot; + request.getUrl()); webDriver.get(request.getUrl()); try &#123; Thread.sleep(sleepTime); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; WebDriver.Options manage &#x3D; webDriver.manage(); Site site &#x3D; task.getSite(); if (site.getCookies() !&#x3D; null) &#123; for (Map.Entry&lt;String, String&gt; cookieEntry : site.getCookies() .entrySet()) &#123; Cookie cookie &#x3D; new Cookie(cookieEntry.getKey(), cookieEntry.getValue()); manage.addCookie(cookie); &#125; &#125; &#x2F;* * TODO You can add mouse event or other processes * * @author: bob.li.0718@gmail.com *&#x2F; WebElement webElement &#x3D; webDriver.findElement(By.xpath(&quot;&#x2F;html&quot;)); String content &#x3D; webElement.getAttribute(&quot;outerHTML&quot;); Page page &#x3D; new Page(); page.setRawText(content); page.setHtml(new Html(content, request.getUrl())); page.setUrl(new PlainText(request.getUrl())); page.setRequest(request); webDriverPool.returnToPool(webDriver); return page; &#125; private void checkInit() &#123; if (webDriverPool &#x3D;&#x3D; null) &#123; synchronized (this) &#123; webDriverPool &#x3D; new WebDriverPool(poolSize); &#125; &#125; &#125; @Override public void setThread(int thread) &#123; this.poolSize &#x3D; thread; &#125; @Override public void close() throws IOException &#123; webDriverPool.closeAll(); &#125;&#125; WebDriverPool.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175package com.born2do.webmagic.downloader.selenium;import org.openqa.selenium.WebDriver;import org.openqa.selenium.chrome.ChromeDriver;import org.openqa.selenium.firefox.FirefoxDriver;import org.openqa.selenium.remote.DesiredCapabilities;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.FileReader;import java.io.IOException;import java.net.MalformedURLException;import java.net.URL;import java.util.ArrayList;import java.util.Collections;import java.util.List;import java.util.Properties;import java.util.concurrent.BlockingDeque;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.atomic.AtomicInteger;&#x2F;** * @author code4crafter@gmail.com &lt;br&gt; * Date: 13-7-26 &lt;br&gt; * Time: 下午1:41 &lt;br&gt; *&#x2F;class WebDriverPool &#123; private Logger logger &#x3D; LoggerFactory.getLogger(getClass()); private final static int DEFAULT_CAPACITY &#x3D; 5; private final int capacity; private final static int STAT_RUNNING &#x3D; 1; private final static int STAT_CLODED &#x3D; 2; private AtomicInteger stat &#x3D; new AtomicInteger(STAT_RUNNING); private WebDriver mDriver &#x3D; null; private static final String DEFAULT_CONFIG_FILE &#x3D; &quot;&#x2F;config.ini&quot;; private static final String DRIVER_FIREFOX &#x3D; &quot;firefox&quot;; private static final String DRIVER_CHROME &#x3D; &quot;chrome&quot;; protected static Properties sConfig; protected static DesiredCapabilities sCaps; &#x2F;** * Configure the GhostDriver, and initialize a WebDriver instance. This part * of code comes from GhostDriver. * https:&#x2F;&#x2F;github.com&#x2F;detro&#x2F;ghostdriver&#x2F;tree&#x2F;master&#x2F;test&#x2F;java&#x2F;src&#x2F;test&#x2F;java&#x2F;ghostdriver * * @author bob.li.0718@gmail.com * @throws IOException *&#x2F; public void configure() throws IOException &#123; &#x2F;&#x2F; Read config file sConfig &#x3D; new Properties(); &#x2F;&#x2F; String configFile &#x3D; DEFAULT_CONFIG_FILE; String configFile &#x3D; this.getClass().getResource(DEFAULT_CONFIG_FILE).getPath(); if (System.getProperty(&quot;selenuim_config&quot;)!&#x3D;null)&#123; configFile &#x3D; System.getProperty(&quot;selenuim_config&quot;); &#125; sConfig.load(new FileReader(configFile)); &#x2F;&#x2F; Prepare capabilities sCaps &#x3D; new DesiredCapabilities(); sCaps.setJavascriptEnabled(true); sCaps.setCapability(&quot;takesScreenshot&quot;, false); String driver &#x3D; sConfig.getProperty(&quot;driver&quot;, DRIVER_CHROME); ArrayList&lt;String&gt; cliArgsCap &#x3D; new ArrayList&lt;String&gt;(); cliArgsCap.add(&quot;--web-security&#x3D;false&quot;); cliArgsCap.add(&quot;--ssl-protocol&#x3D;any&quot;); cliArgsCap.add(&quot;--ignore-ssl-errors&#x3D;true&quot;); &#x2F;&#x2F; Start appropriate Driver if (driver.equals(DRIVER_FIREFOX)) &#123; mDriver &#x3D; new FirefoxDriver(sCaps); &#125; else if (driver.equals(DRIVER_CHROME)) &#123; mDriver &#x3D; new ChromeDriver(sCaps); &#125; &#125; &#x2F;** * check whether input is a valid URL * * @author bob.li.0718@gmail.com * @param urlString urlString * @return true means yes, otherwise no. *&#x2F; private boolean isUrl(String urlString) &#123; try &#123; new URL(urlString); return true; &#125; catch (MalformedURLException mue) &#123; return false; &#125; &#125; &#x2F;** * store webDrivers created *&#x2F; private List&lt;WebDriver&gt; webDriverList &#x3D; Collections .synchronizedList(new ArrayList&lt;WebDriver&gt;()); &#x2F;** * store webDrivers available *&#x2F; private BlockingDeque&lt;WebDriver&gt; innerQueue &#x3D; new LinkedBlockingDeque&lt;WebDriver&gt;(); public WebDriverPool(int capacity) &#123; this.capacity &#x3D; capacity; &#125; public WebDriverPool() &#123; this(DEFAULT_CAPACITY); &#125; &#x2F;** * * @return * @throws InterruptedException *&#x2F; public WebDriver get() throws InterruptedException &#123; checkRunning(); WebDriver poll &#x3D; innerQueue.poll(); if (poll !&#x3D; null) &#123; return poll; &#125; if (webDriverList.size() &lt; capacity) &#123; synchronized (webDriverList) &#123; if (webDriverList.size() &lt; capacity) &#123; &#x2F;&#x2F; add new WebDriver instance into pool try &#123; configure(); innerQueue.add(mDriver); webDriverList.add(mDriver); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; return innerQueue.take(); &#125; public void returnToPool(WebDriver webDriver) &#123; checkRunning(); innerQueue.add(webDriver); &#125; protected void checkRunning() &#123; if (!stat.compareAndSet(STAT_RUNNING, STAT_RUNNING)) &#123; throw new IllegalStateException(&quot;Already closed!&quot;); &#125; &#125; public void closeAll() &#123; boolean b &#x3D; stat.compareAndSet(STAT_RUNNING, STAT_CLODED); if (!b) &#123; throw new IllegalStateException(&quot;Already closed!&quot;); &#125; for (WebDriver webDriver : webDriverList) &#123; logger.info(&quot;Quit webDriver&quot; + webDriver); webDriver.quit(); webDriver &#x3D; null; &#125; &#125;&#125; config.ini 1234567# What WebDriver to use for the tests#driver&#x3D;firefoxdriver&#x3D;chrome#谷歌浏览器启动程序路径#chrome_exec_path&#x3D;D:\\chromedriver_win32\\chromedriver.exechrome_driver_loglevel&#x3D;DEBUG 项目地址： https://github.com/born2do/crawler.git 说明Selenium 已不再支持 PhantomJS，以前还可以通过降低jar包版本的方式解决该问题，但是现在已经不行了，即使版本再低，也不会引入PhantomJS相关的jar包了，所以webmagic作者开发的webmagic-selenium已经不能再用了（好像已经很久都没有更新版本了。。。），我这里的处理是下载源码，在源码的基础上将PhantomJS的相关内容都已经剔除了。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"https://born2do.github.io/categories/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"WebMagic","slug":"WebMagic","permalink":"https://born2do.github.io/tags/WebMagic/"}],"author":"chenhy"},{"title":"【Java】用Java实现JS中的decodeURIComponent()函数","slug":"【Java】用Java实现JS中的decodeURIComponent-函数","date":"2021-03-25T15:06:03.000Z","updated":"2021-03-25T15:06:46.306Z","comments":true,"path":"2021/03/25/【Java】用Java实现JS中的decodeURIComponent-函数/","link":"","permalink":"https://born2do.github.io/2021/03/25/%E3%80%90Java%E3%80%91%E7%94%A8Java%E5%AE%9E%E7%8E%B0JS%E4%B8%AD%E7%9A%84decodeURIComponent-%E5%87%BD%E6%95%B0/","excerpt":"","text":"为防止json数据解析出错，在B/S模式下的前后端交互中，会对数据进行编码encodeURIComponent与解码decodeURIComponent。存储时将数据编码：encodeURIComponent(需要编码的数据)使用时将数据解码：decodeURIComponent(需要解码的数据) 在爬取数据的过程中，对于使用AJAX进行页面数据渲染的网页，我们爬取到的数据往往会是下面的形式：data:%7B%22mode%22%3A%22xml%22%2C%22code%22%3A%22%20%20%20%20%20%20%20%20%3Cdependency%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-configuration-processor%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Coptional%3Etrue%3C%2Foptional%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fdependency%3E%5Cn%5Cn%5Cn%20%3Cbuild%3E%5Cn%20%20%20%20%20%20%20%20%3Cplugins%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cplugin%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-maven-plugin%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cconfiguration%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cexcludes%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cexclude%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-configuration-processor%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fexclude%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fexcludes%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fconfiguration%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fplugin%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fplugins%3E%5Cn%20%20%20%20%3C%2Fbuild%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Wptpj%22%7D 在Java项目中，我们又该如何去对这种原内容为json数据的字符串进行解码呢？网上的处理方法较多，但下面的方法最为简单： 12345678910111213package com.born2do.code;/** * @author chenhy * @date 2021/3/25 */public class DecodeDemo &#123; public static void main(String[] args) throws Exception &#123; String uri = &quot;%7B%22mode%22%3A%22xml%22%2C%22code%22%3A%22%20%20%20%20%20%20%20%20%3Cdependency%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-configuration-processor%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Coptional%3Etrue%3C%2Foptional%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fdependency%3E%5Cn%5Cn%5Cn%20%3Cbuild%3E%5Cn%20%20%20%20%20%20%20%20%3Cplugins%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cplugin%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-maven-plugin%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cconfiguration%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cexcludes%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3Cexclude%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CgroupId%3Eorg.springframework.boot%3C%2FgroupId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3CartifactId%3Espring-boot-configuration-processor%3C%2FartifactId%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fexclude%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fexcludes%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fconfiguration%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3C%2Fplugin%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fplugins%3E%5Cn%20%20%20%20%3C%2Fbuild%3E%22%2C%22heightLimit%22%3Atrue%2C%22margin%22%3Atrue%2C%22id%22%3A%22Wptpj%22%7D&quot;; String decodeStr = new java.net.URI(uri).getPath(); System.out.println(&quot;decode后的json数据为：&quot; + decodeStr); &#125;&#125; 运行结果： decode后的json数据为：{“mode”:”xml”,”code”:” \\n org.springframework.boot\\n spring-boot-configuration-processor\\n true\\n \\n\\n\\n \\n \\n \\n org.springframework.boot\\n spring-boot-maven-plugin\\n \\n \\n \\n org.springframework.boot\\n spring-boot-configuration-processor\\n \\n \\n \\n \\n \\n “,”heightLimit”:true,”margin”:true,”id”:”Wptpj”} 我们再将获取到的结果进行格式化，显示如下： 1234567&#123; &quot;mode&quot;: &quot;xml&quot;, &quot;code&quot;: &quot; &lt;dependency&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\n &lt;optional&gt;true&lt;/optional&gt;\\n &lt;/dependency&gt;\\n\\n\\n &lt;build&gt;\\n &lt;plugins&gt;\\n &lt;plugin&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\\n &lt;configuration&gt;\\n &lt;excludes&gt;\\n &lt;exclude&gt;\\n &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\\n &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;\\n &lt;/exclude&gt;\\n &lt;/excludes&gt;\\n &lt;/configuration&gt;\\n &lt;/plugin&gt;\\n &lt;/plugins&gt;\\n &lt;/build&gt;&quot;, &quot;heightLimit&quot;: true, &quot;margin&quot;: true, &quot;id&quot;: &quot;Wptpj&quot;&#125; 使用getPath()实现完美解码。","categories":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"}],"tags":[{"name":"decodeURIComponent()","slug":"decodeURIComponent","permalink":"https://born2do.github.io/tags/decodeURIComponent/"}],"author":"chenhy"},{"title":"【JS】encodeURIComponent()和decodeURIComponent()","slug":"【JS】encodeURIComponent-和decodeURIComponent","date":"2021-03-25T15:04:29.000Z","updated":"2021-03-25T15:05:25.710Z","comments":true,"path":"2021/03/25/【JS】encodeURIComponent-和decodeURIComponent/","link":"","permalink":"https://born2do.github.io/2021/03/25/%E3%80%90JS%E3%80%91encodeURIComponent-%E5%92%8CdecodeURIComponent/","excerpt":"","text":"encodeURIComponent()和decodeURIComponent()函数均为JS的全局函数，主流浏览器均支持。主要作用为编码与解码。 encodeURIComponent()定义encodeURIComponent() 函数可把字符串作为 URI 组件进行编码。 该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ‘ ( ) 。 其他字符（比如 ：;/?:@&amp;=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。 语法1encodeURIComponent(uri) 说明：uri，必需。一个字符串，含有 URI 组件或其他要编码的文本。 decodeURIComponent()定义decodeURIComponent() 函数可对 encodeURIComponent() 函数编码的 URI 进行解码。 语法1decodeURIComponent(uri) 说明：uri，必需。一个字符串，含有编码 URI 组件或其他要解码的文本。 实例123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt; &lt;title&gt;encodeAndDecode&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;script&gt;var uri&#x3D;&quot;https:&#x2F;&#x2F;www.born2do.com&#x2F;&quot;;document.write(&quot;uri &#x3D; &quot; + uri);document.write(&quot;&lt;br&gt;&quot;);var uri_encode&#x3D;encodeURIComponent(uri);document.write(&quot;encode &#x3D; &quot; + uri_encode);document.write(&quot;&lt;br&gt;&quot;);document.write(&quot;decode &#x3D; &quot; + decodeURIComponent(uri_encode));&lt;&#x2F;script&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 运行结果： uri = https://www.born2do.com/encode = https%3A%2F%2Fwww.born2do.com%2Fdecode = https://www.born2do.com/","categories":[{"name":"JS","slug":"JS","permalink":"https://born2do.github.io/categories/JS/"}],"tags":[{"name":"encodeURIComponent()","slug":"encodeURIComponent","permalink":"https://born2do.github.io/tags/encodeURIComponent/"},{"name":"decodeURIComponent()","slug":"decodeURIComponent","permalink":"https://born2do.github.io/tags/decodeURIComponent/"}],"author":"chenhy"},{"title":"【Linux】在shell脚本中获取当前主机的主机名以及IP地址","slug":"【Linux】在shell脚本中获取当前主机的主机名以及IP地址","date":"2021-03-15T13:10:25.000Z","updated":"2021-03-15T13:10:56.789Z","comments":true,"path":"2021/03/15/【Linux】在shell脚本中获取当前主机的主机名以及IP地址/","link":"","permalink":"https://born2do.github.io/2021/03/15/%E3%80%90Linux%E3%80%91%E5%9C%A8shell%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%B8%BB%E6%9C%BA%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%90%8D%E4%BB%A5%E5%8F%8AIP%E5%9C%B0%E5%9D%80/","excerpt":"","text":"在命令行模式下，获取当前主机名称： 1hostname 在命令行模式下，获取IP地址： 1ifconfig 在shell脚本中获取当前主机的主机名以及IP地址： 12echo `hostname`echo `ifconfig | grep -A1 &quot;eth0&quot; | grep &#x27;inet addr&#x27; |awk -F &#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;|awk &#x27;&#123;print $1&#125;&#x27;` 说明：`` 表示执行该语句，并返回执行后的结果；grep -A1 “eth0” 表示找出带有“eth0”的行，输出中除显示该行外，还显示之后的一行；awk 则是进行分割。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://born2do.github.io/tags/shell/"}],"author":"chenhy"},{"title":"db2中的SYSIBM.SYSDUMMY1","slug":"db2中的SYSIBM-SYSDUMMY1","date":"2021-03-14T13:40:57.000Z","updated":"2021-03-14T13:41:32.255Z","comments":true,"path":"2021/03/14/db2中的SYSIBM-SYSDUMMY1/","link":"","permalink":"https://born2do.github.io/2021/03/14/db2%E4%B8%AD%E7%9A%84SYSIBM-SYSDUMMY1/","excerpt":"","text":"SYSIBM.SYSDUMMY1是db2数据库中的一张系统表，用来存储系统的相关信息。 123456--获取当前系统日期SELECT CURRENT DATE FROM SYSIBM.SYSDUMMY1;--获取库表MYSEQ的序列值SELECT NEXTVAL FOR MYSEQ FROM SYSIBM.SYSDUMMY1;--执行数学运算SELECT 1+1 FROM SYSIBM.SYSDUMMY1;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/tags/DB2/"}],"author":"chenhy"},{"title":"Method com/mchange/v2/c3p0/impl/NewProxyPreparedStatement.isClosed()Z is abstract","slug":"Method-com-mchange-v2-c3p0-impl-NewProxyPreparedStatement-isClosed-Z-is-abstract","date":"2021-03-12T14:26:14.000Z","updated":"2021-03-12T14:27:08.807Z","comments":true,"path":"2021/03/12/Method-com-mchange-v2-c3p0-impl-NewProxyPreparedStatement-isClosed-Z-is-abstract/","link":"","permalink":"https://born2do.github.io/2021/03/12/Method-com-mchange-v2-c3p0-impl-NewProxyPreparedStatement-isClosed-Z-is-abstract/","excerpt":"","text":"问题描述学习B站上的SSM项目，使用c3p0连接池，报错如下： 123456java.lang.AbstractMethodError: Method com&#x2F;mchange&#x2F;v2&#x2F;c3p0&#x2F;impl&#x2F;NewProxyPreparedStatement.isClosed()Z is abstract at com.mchange.v2.c3p0.impl.NewProxyPreparedStatement.isClosed(NewProxyPreparedStatement.java) at org.apache.ibatis.executor.BaseExecutor.closeStatement(BaseExecutor.java:285) at org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:65)…… 原因使用的c3p0的相关jar包版本过低。 解决将c3p0-0.9.1.2.jar 换成 c3p0-0.9.5.2.jar或更高版本。","categories":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"}],"tags":[{"name":"c3p0","slug":"c3p0","permalink":"https://born2do.github.io/tags/c3p0/"}],"author":"chenhy"},{"title":"【linux】取消默认断开时间","slug":"【linux】取消默认断开时间","date":"2021-03-12T14:25:09.000Z","updated":"2021-03-12T14:27:14.605Z","comments":true,"path":"2021/03/12/【linux】取消默认断开时间/","link":"","permalink":"https://born2do.github.io/2021/03/12/%E3%80%90linux%E3%80%91%E5%8F%96%E6%B6%88%E9%BB%98%E8%AE%A4%E6%96%AD%E5%BC%80%E6%97%B6%E9%97%B4/","excerpt":"","text":"问题描述新买的阿里云服务器，使用putty连接上后，长时间没操作就断开了。关键你又要重新连接，这就很烦！！！ 思路超时断开是系统的配置，修改下配置文件就好。 解决使用root用户登录服务器 查看系统是否设置了TMOUT参数1# echo $TMOUT 如果输出空或0表示不超时，大于0的数字n表示n秒没有输入则超时断开。 修改配置文件1# vi /etc/profile 修改TMOUT=0后保存。 刷新系统配置1# source /etc/profile 超时断开问题解决。 source命令简介 source命令用法：source FileName作用：在当前bash环境下读取并执行FileName中的命令。注：该命令通常用命令”.”来替代。","categories":[{"name":"linux","slug":"linux","permalink":"https://born2do.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://born2do.github.io/tags/linux/"}],"author":"chenhy"},{"title":"【Linux】查看当前系统默认的shell解释器，修改默认解释器","slug":"【Linux】查看当前系统默认的shell解释器，修改默认解释器","date":"2021-03-12T14:24:02.000Z","updated":"2021-03-12T14:24:48.513Z","comments":true,"path":"2021/03/12/【Linux】查看当前系统默认的shell解释器，修改默认解释器/","link":"","permalink":"https://born2do.github.io/2021/03/12/%E3%80%90Linux%E3%80%91%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4%E7%9A%84shell%E8%A7%A3%E9%87%8A%E5%99%A8%EF%BC%8C%E4%BF%AE%E6%94%B9%E9%BB%98%E8%AE%A4%E8%A7%A3%E9%87%8A%E5%99%A8/","excerpt":"","text":"查看系统当前支持哪些shell解释器123456root@Administrator:~# cat &#x2F;etc&#x2F;shells# &#x2F;etc&#x2F;shells: valid login shells&#x2F;bin&#x2F;sh&#x2F;bin&#x2F;bash&#x2F;bin&#x2F;rbash&#x2F;bin&#x2F;dash 查看系统当前默认的shell解释器123456789root@Administrator:~# echo $0-bashroot@Administrator:~# echo $SHELL&#x2F;bin&#x2F;bashroot@Administrator:~# env | grep SHELLSHELL&#x3D;&#x2F;bin&#x2F;bashroot@Administrator:~# ps -p $$ PID TTY TIME CMD 1091 pts&#x2F;1 00:00:00 bash 修改默认的shell解释器12345root@Administrator:~# chsh -s &#x2F;bin&#x2F;shroot@Administrator:~# chshChanging the login shell for rootEnter the new value, or press ENTER for the default Login Shell [&#x2F;bin&#x2F;sh]: &#x2F;bin&#x2F;bash 说明：修改了系统默认shell之后不会立即生效，之后再次登录系统修改的shell才会生效。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/tags/Linux/"}],"author":"chenhy"},{"title":"Java代码注释规约及eclipse相关配置","slug":"Java代码注释规约及eclipse相关配置","date":"2021-03-11T12:31:20.000Z","updated":"2021-03-11T12:32:06.440Z","comments":true,"path":"2021/03/11/Java代码注释规约及eclipse相关配置/","link":"","permalink":"https://born2do.github.io/2021/03/11/Java%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6%E5%8F%8Aeclipse%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE/","excerpt":"","text":"Java代码注释规约1.【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用 /** 内容 */ 格式，不得使用 // xxx 方式。说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。2.【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。说明：对子类的实现要求，或者调用注意事项，请一并说明。3.【强制】所有的类都必须添加创建者和创建日期。4.【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释使用 /* */ 注释，注意与代码对齐。5.【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。6.【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。7.【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。8.【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。说明：代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。9.【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。10.【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。反例： 12// put elephant into fridgeput(elephant, fridge); 方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。11.【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1）待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。2）错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。 eclipse相关配置Window-&gt;Preferences-&gt;Java-&gt;Code Style-&gt;Code Templates-&gt;Comments-&gt; 类、接口Types-&gt;edit填入以下内容： 12345&#x2F;** * $&#123;tags&#125; * @author $&#123;user&#125; * @date $&#123;date&#125; *&#x2F; 方法体Methods-&gt;edit填入以下内容（一般会有默认格式，无需修改）： 123&#x2F;** * $&#123;tags&#125; *&#x2F; 修改保存修改后勾选下方的“Automatically add commects for new methods,types……”，然后点击“Apply and Close”即可。说明：1）以上修改的部分为强制内容，必须填写！！！也可自行额外添加其他标签内容。2）接口或抽象类的JavaDoc必须填写，实现类中对接口或是抽象类的重写方法的JavaDoc可以不写，只要有@Override注解即可。","categories":[{"name":"规约","slug":"规约","permalink":"https://born2do.github.io/categories/%E8%A7%84%E7%BA%A6/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"}],"author":"chenhy"},{"title":"【Linux】crontab定时任务","slug":"【Linux】crontab定时任务","date":"2021-03-10T12:43:35.000Z","updated":"2021-03-10T12:44:12.919Z","comments":true,"path":"2021/03/10/【Linux】crontab定时任务/","link":"","permalink":"https://born2do.github.io/2021/03/10/%E3%80%90Linux%E3%80%91crontab%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","excerpt":"","text":"Linux crontab是用来定期执行程序的命令。 查看定时任务1crontab -l 编辑定时任务1crontab -e 删除定时任务1crontab -d 说明：以上几个命令均没有添加用户角色信息，默认为编辑当前用户的crontab定时任务。 crontab内容格式： 1f1 f2 f3 f4 f5 program 其中 f1 是表示分钟，f2 表示小时，f3 表示一个月份中的第几日，f4 表示月份，f5 表示一个星期中的第几天。program 表示要执行的程序。 当 f1 为 * 时表示每分钟都要执行 program，f2 为 * 时表示每小时都要执行程序，其余类推 当 f1 为 a-b 时表示从第 a 分钟到第 b 分钟这段时间内要执行，f2 为 a-b 时表示从第 a 到第 b 小时都要执行，其余类推 当 f1 为 */n 时表示每 n 分钟个时间间隔执行一次，f2 为 */n 表示每 n 小时个时间间隔执行一次，其余类推 当 f1 为 a, b, c,… 时表示第 a, b, c,… 分钟要执行，f2 为 a, b, c,… 时表示第 a, b, c…个小时要执行，其余类推12345678* * * * *- - - - -| | | | || | | | +----- 星期中星期几 (0 - 6) (星期天 为0)| | | +---------- 月份 (1 - 12) | | +--------------- 一个月中的第几天 (1 - 31)| +-------------------- 小时 (0 - 23)+------------------------- 分钟 (0 - 59) eg： 每一分钟执行一次 /bin/ls1* * * * * &#x2F;bin&#x2F;ls 在 12 月内, 每天的早上 6 点到 12 点，每隔 3 个小时 0 分钟执行一次 /usr/bin/backup10 6-12&#x2F;3 * 12 * &#x2F;usr&#x2F;bin&#x2F;backup 每月每天的午夜 0 点 20 分, 2 点 20 分, 4 点 20 分….执行 echo “haha”120 0-23&#x2F;2 * * * echo &quot;haha&quot;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"}],"tags":[{"name":"crontab","slug":"crontab","permalink":"https://born2do.github.io/tags/crontab/"}],"author":"chenhy"},{"title":"【Excel】使用小tips","slug":"【Excel】使用小tips","date":"2021-03-10T12:42:32.000Z","updated":"2021-03-10T12:43:16.331Z","comments":true,"path":"2021/03/10/【Excel】使用小tips/","link":"","permalink":"https://born2do.github.io/2021/03/10/%E3%80%90Excel%E3%80%91%E4%BD%BF%E7%94%A8%E5%B0%8Ftips/","excerpt":"","text":"快速填充 在第一个单元格写好公式 选中第一个单元格到本列的最后一行 将光标移动到公式栏，然后按下组合键ctrl+enter 全部填充完毕 列查找VLOOKUP函数VLOOKUP(lookup_value, table_array, col_index_num, [range_lookup])VLOOKUP(查找值，查找范围，查找列数，精确匹配或者近似匹配）","categories":[{"name":"Excel","slug":"Excel","permalink":"https://born2do.github.io/categories/Excel/"}],"tags":[{"name":"Excel","slug":"Excel","permalink":"https://born2do.github.io/tags/Excel/"}],"author":"chenhy"},{"title":"【Linux】使用find命令清理指定时间之前的文件","slug":"【Linux】使用find命令清理指定时间之前的文件","date":"2021-03-09T12:39:45.000Z","updated":"2021-03-09T12:40:26.057Z","comments":true,"path":"2021/03/09/【Linux】使用find命令清理指定时间之前的文件/","link":"","permalink":"https://born2do.github.io/2021/03/09/%E3%80%90Linux%E3%80%91%E4%BD%BF%E7%94%A8find%E5%91%BD%E4%BB%A4%E6%B8%85%E7%90%86%E6%8C%87%E5%AE%9A%E6%97%B6%E9%97%B4%E4%B9%8B%E5%89%8D%E7%9A%84%E6%96%87%E4%BB%B6/","excerpt":"","text":"1find /root/logs -type f -name &quot;*&quot; -mtime +7 -exec rm -f &#123;&#125; \\; 说明：find 后面紧跟的/root/logs是要查找的目录，. 表示当前目录-type f：指定查找对象为文件-name &quot;*&quot;：指定查找对象名称为任意-mtime +7：查找7天以前的老文件-exec rm -f &#123;&#125; \\;：执行删除命令，后面有个 &#123;&#125; \\; 是必须的 扩展如果想要定期执行该命令，可以将该命令放到脚本中，然后再使用crontab定时任务进行执行操作。","categories":[{"name":"shell","slug":"shell","permalink":"https://born2do.github.io/categories/shell/"}],"tags":[{"name":"find","slug":"find","permalink":"https://born2do.github.io/tags/find/"}],"author":"chenhy"},{"title":"开源/免费工具","slug":"开源-免费工具","date":"2021-03-09T12:38:24.000Z","updated":"2021-03-09T12:39:22.923Z","comments":true,"path":"2021/03/09/开源-免费工具/","link":"","permalink":"https://born2do.github.io/2021/03/09/%E5%BC%80%E6%BA%90-%E5%85%8D%E8%B4%B9%E5%B7%A5%E5%85%B7/","excerpt":"","text":"远程登录 PuTTY官网： https://www.putty.org/ MTPUTTY （未找到相关licence，但官网表示一切免费）官网： https://ttyplus.com/ FinalShell（并非开源，仅通用版免费使用）官网： http://www.hostbuf.com/ 文件传输 WinSCP官网： https://winscp.net/ 文本编辑器 Notepad++官网： https://notepad-plus-plus.org/ Typora （并非开源，但免费）官网： https://www.typora.io/ 集成开发环境IDE Eclipse官网： https://www.eclipse.org/ 数据库连接工具 DBeaver（社区版免费）官网： https://dbeaver.io/ 数据库模型建模工具 PDMan官网： http://www.pdman.cn/ 浏览器 火狐官网： http://www.firefox.com.cn/ 数据库 MySQL官网： https://www.mysql.com/ 中间件 Apache Tomcat官网： https://tomcat.apache.org/ 图床工具 PicGo官网： https://picgo.github.io/PicGo-Doc/ 版本控制系统 Git官网： https://git-scm.com/ TortoiseSVN官网： https://tortoisesvn.net/","categories":[{"name":"工具","slug":"工具","permalink":"https://born2do.github.io/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"开源","slug":"开源","permalink":"https://born2do.github.io/tags/%E5%BC%80%E6%BA%90/"}],"author":"chenhy"},{"title":"Markdown","slug":"Markdown","date":"2021-03-08T13:28:06.000Z","updated":"2021-03-08T13:28:39.744Z","comments":true,"path":"2021/03/08/Markdown/","link":"","permalink":"https://born2do.github.io/2021/03/08/Markdown/","excerpt":"","text":"MarkdownMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 编辑器目前，主流的markdown编辑器有Typora、MarkdownPad（需要安装插件）、Atom等，但我比较中意Typora，无需安装任何插件，即装即用，轻量级软件，用起来得心应手。 Typora官网：https://www.typora.io/ 百度网盘： 链接：https://pan.baidu.com/s/1KrC2BoSP2_MBseaQ4Q0BZA提取码：3vyw 以下介绍，请复制内容到typora或其他编辑器查看效果。 对于部分样式，存在多种书写形式，建议只记一种，保持行文规范。 标题使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。注意：#号与标题内容之间要保留一个空格。 12345678910111213# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题####### 别想了，没有七级标题 段落格式段落Typora中直接回车即可换行。其他编译器，两个或两个以上空格加回车，即可换行。 字体123456*斜体文本*_斜体文本_**粗体文本**__粗体文本__***粗斜体文本***___粗斜体文本___ 分隔线可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。 123***---___ 删除线如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可。 1~www.aliyun.com~ 下划线通过HTML的&lt;u&gt;标签来实现。 1&lt;u&gt;下划线&lt;&#x2F;u&gt; 注脚1[^要注明的文本] 列表无序列表使用星号(***)、加号(+)或是减号(-**)作为列表标记。注意，符号与文字间要空格。 123456789101112* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 有序列表使用数字并加上.号来表示。注意，符号与文字间要空格。 1231. 第一项2. 第二项3. 第三项 列表嵌套只需在子列表中的选项添加四个空格即可。（使用tab键也可，会有不同效果） 1234561. 第一项： - 第一项嵌套的第一个元素 - 第一项嵌套的第二个元素2. 第二项： - 第二项嵌套的第一个元素 - 第二项嵌套的第二个元素 区块区块区块引用在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号。 1&gt; 这是区块，不信你试试 区块嵌套区块可以嵌套，增加&gt;即可。 123&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套 区块中使用列表123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项&gt; + 第一项&gt; + 第二项&gt; + 第三项 列表中使用区块123* 第一项 &gt; 区块一* 第二项 代码代码片段少量片段，使用一对反单引号（``）即可。 1&#96;System.out.println();&#96; 代码块用一对 （```） 包裹一段代码，并指定一种语言（也可以不指定） 1 这就是代码块 1 链接链接使用方法如下： 12345[链接名称](链接地址)或者&lt;链接地址&gt; 图片Markdown 图片语法格式如下： 123![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;) Typora中，快捷键ctrl+shift+i，即可快速插入图片。 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： 1234| 表头 | 表头 || ---- | ---- || 单元格 | 单元格 || 单元格 | 单元格 | 对齐方式： -: 设置内容和标题栏居右对齐。 :- 设置内容和标题栏居左对齐。 :-: 设置内容和标题栏居中对齐。 举例如下： 1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 | 表格是markdown的一大痛点，简单的合并单元格都不行（实际上借助其他插件是可以的，就是太麻烦）。个人建议，需要用到表格的时候，直接右键-&gt;插入-&gt;表格，设置下行数和列数即可，省时又省力。 总结基本的markdown语法就是这些了，也够用了。想要学习其他高级操作，可以再去网上搜索。实际上，更重要的是动手实践，用的多了自然也就会了。 参考文档：Markdown 教程 博客最早记载时间为2020年04月23日。","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://born2do.github.io/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://born2do.github.io/tags/Markdown/"}],"author":"chenhy"},{"title":"Windows端口被占用","slug":"Windows端口被占用","date":"2021-03-08T13:26:20.000Z","updated":"2021-03-08T13:27:42.763Z","comments":true,"path":"2021/03/08/Windows端口被占用/","link":"","permalink":"https://born2do.github.io/2021/03/08/Windows%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8/","excerpt":"","text":"背景启动JavaWeb项目，eclipse提示8080端口已被占用。 解决1.查看端口占用情况进入Windows命令行，输入“netstat -ano | findstr 8080”，查看8080端口是被哪个服务占用了。显示如下： 12TCP 0.0.0.0:8080 0.0.0.0:0 LISTENING 19288TCP [::]:8080 [::]:0 LISTENING 19288 2.终止服务进程输入命令“taskkill -pid 19288 -f”，19288服务终止，8080端口被释放。博客最早记载时间为2020年04月20日。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/tags/Windows/"}],"author":"chenhy"},{"title":"MYSQL解压版安装","slug":"MYSQL解压版安装","date":"2021-03-07T01:50:34.000Z","updated":"2021-03-07T01:57:00.587Z","comments":true,"path":"2021/03/07/MYSQL解压版安装/","link":"","permalink":"https://born2do.github.io/2021/03/07/MYSQL%E8%A7%A3%E5%8E%8B%E7%89%88%E5%AE%89%E8%A3%85/","excerpt":"","text":"根据自己的系统，从官网下载Mysql压缩包。将下载到的文件解压缩到自己喜欢的位置，例如我自己的位置是D:\\mysql-8.0.11-winx64。 配置环境变量。将Mysql的bin目录配置到path下面。 配置my.ini文件。在D:\\mysql-8.0.11-winx64（注意这个目录要是你自己的mysql目录）目录下新建一个配置文件，文件名叫my.ini，然后把下面的配置代码复制到在my.ini（代码中的路径要改成自己的文件存放路径）。 12345678910111213141516[mysql]# 设置mysql客户端默认字符集default-character-set&#x3D;utf8 [mysqld]#设置3306端口port &#x3D; 3306 # 设置mysql的安装目录basedir&#x3D;D:\\mysql-8.0.11-winx64# 设置mysql数据库的数据的存放目录datadir&#x3D;D:\\mysql-8.0.11-winx64\\data# 允许最大连接数max_connections&#x3D;200# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server&#x3D;utf8# 创建新表时将使用的默认存储引擎default-storage-engine&#x3D;INNODB 安装mysql服务。将目录切换到你解压文件的D:\\mysql\\mysql-5.6.33-winx64\\bin目录，初始化和启动Mysql服务： 以管理员权限运行cmd 进入mysql的bin下 初始化，生成data文件夹12mysqld --initialize-insecure （建议使用，不设置root密码）mysqld --initialize （不建议使用，生成一个随机的root密码） 安装MySql服务1mysqld -install 开始mysql服务。启动mysql 1net start mysql 更改密码安装成功并开始mysql服务后，重新进入DOS命令行，输入mysql -u root -p之后回车。登录mysql之后，设置root密码 1set password for root@localhost &#x3D; password(&#39;YourPassword&#39;); 或者使用mysqlamdin修改root密码 1mysqladmin -u root -p password NewPassword； 博客最早记载时间为2019年08月30日。","categories":[{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://born2do.github.io/tags/MYSQL/"}],"author":"chenhy"},{"title":"VC++6.0出现Error spawning cl.exe","slug":"VC-6-0出现Error-spawning-cl-exe","date":"2021-03-07T01:49:11.000Z","updated":"2021-03-07T01:50:13.891Z","comments":true,"path":"2021/03/07/VC-6-0出现Error-spawning-cl-exe/","link":"","permalink":"https://born2do.github.io/2021/03/07/VC-6-0%E5%87%BA%E7%8E%B0Error-spawning-cl-exe/","excerpt":"","text":"当我们在VC++6.0中编写好一个C语言程序后，点击“Compile（编译）”或者“Build（构建）”出现的“Compiling… ,Error spawning cl.exe”错误提示，一般都是因为路径设置的问题引起的。 首先查看VC++6.0的安装路径，一般默认安装都是安装在C:\\Program Files\\Microsoft Visual Studio目录下，但是你安装时有可能安装在其他目录中，一定要知道安装目录的路径。 打开VC++6.0程序，点击菜单栏上的“工具（T）”，在出现的下拉列表中选择“选项（O）…”，如下图所示。 弹出一个“选项”窗口，点击窗口菜单栏上的“目录”选项，点击目录（S）对应的下拉框会看到有可执行文件（executatble files）、include files、library files、source files四个选项。在“目录（S）”对应的下拉框中选择“include files”，在”路径(D)”中可以看到一共有三行路径，红线框中代表VC++6.0的安装路径，如果不是请改为安装路径。之后，对“可执行文件（executatble files）、library files、source files”做同样的修改。 改完之后，点击“确定”按钮，重新编译程序，可以发现没有出现“Compiling…,Error spawning cl.exe”这个问题了，程序可以正常编译了。 博客最早记载时间为2019年08月30日。","categories":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"}],"tags":[{"name":"VC++6.0","slug":"VC-6-0","permalink":"https://born2do.github.io/tags/VC-6-0/"}],"author":"chenhy"},{"title":"PowerPoint 2013打不开PPT文件","slug":"PowerPoint-2013打不开PPT文件","date":"2021-03-06T13:23:55.000Z","updated":"2021-03-06T13:24:28.920Z","comments":true,"path":"2021/03/06/PowerPoint-2013打不开PPT文件/","link":"","permalink":"https://born2do.github.io/2021/03/06/PowerPoint-2013%E6%89%93%E4%B8%8D%E5%BC%80PPT%E6%96%87%E4%BB%B6/","excerpt":"","text":"从网上下载的PPT文件，其本身没有问题，但就是打不开。尝试过office程序的修复，但没用。文件打开的时候会问你 是否信任其来源，点击修复。但是总是修复失败，无法读取。网上的解决办法挺多，最简单的是：右键文件属性，点击解除锁定即可。但是这种方法，治标不治本。以下是彻底解决这个问题的方法：1、使用 PowerPoint 2013 打开PPT文件时会出现如图报错：2、点击“取消”3、点击左上角的“文件”按钮，进入OFFICE 设置4、在打开的界面，点击“选项”按钮5、进入弹出的“选项”窗口，依次选择“信任中心”-&gt;“信任中心设置”进入下一个界面6、选择“受保护视图”，将右边窗口三个选项全部取消 “√”选，点击“确定”7、这时，再打开PPT， 就不会报该错误提示了。 博客最早记载时间为2019年08月30日。","categories":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"}],"tags":[{"name":"PowerPoint 2013","slug":"PowerPoint-2013","permalink":"https://born2do.github.io/tags/PowerPoint-2013/"}],"author":"chenhy"},{"title":"navicat连接MySQL出现2059错误","slug":"navicat连接MySQL出现2059错误","date":"2021-03-06T13:21:44.000Z","updated":"2021-03-06T13:23:36.523Z","comments":true,"path":"2021/03/06/navicat连接MySQL出现2059错误/","link":"","permalink":"https://born2do.github.io/2021/03/06/navicat%E8%BF%9E%E6%8E%A5MySQL%E5%87%BA%E7%8E%B02059%E9%94%99%E8%AF%AF/","excerpt":"","text":"使用navicat连接MySQL时出现2059错误。原因为高版本的MySQL更改了密码验证机制，再次更改回去即可。 进入CMD命令符窗口（win+R） 登录MySQL进入mysql安装目录的bin路径下运行mysql -u root -p命令进行登录（密码是安装mysql时设置的密码） 更改密码验证机制输入以下命令进行更改： 1ALTER USER &#39;root&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;root&#39;; root是用户名，localhost是ip地址127.0.0.1都是特指本机，mysql_native_password是旧的密码验证机制，root是密码，最后别忘了分号。 进入Navicat测试连接 博客最早记载时间为2019年08月30日。","categories":[{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"}],"tags":[{"name":"Navicat","slug":"Navicat","permalink":"https://born2do.github.io/tags/Navicat/"},{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/tags/MySQL/"}],"author":"chenhy"},{"title":"Windows使用小tips","slug":"Windows使用小tips","date":"2021-03-05T07:10:00.000Z","updated":"2021-03-06T10:21:41.710Z","comments":true,"path":"2021/03/05/Windows使用小tips/","link":"","permalink":"https://born2do.github.io/2021/03/05/Windows%E4%BD%BF%E7%94%A8%E5%B0%8Ftips/","excerpt":"","text":"widows输入法，输入后字体变为繁体解决： 打开记事本，光标停在文档内，使用ctrl+shift+f，即可在简体与繁体之间切换。 word2013无法打开pdf文件，提示无法启动转换器pdf文件解决： 方法一：(最实用) 右键单击word2013，选择属性。在兼容性里勾选以管理员身份运行此程序。再次打开pdf格式文件，出现提示，点击确定即可。 方法二： 打开系统盘C盘，依次找到路径\\Program Files\\Common Files\\Microsoft Shared\\TextConv，找到“TextConv”这个文件夹，然后将其删除。 方法三： 在桌面左下方的“开始”“运行”中输入“regedit”，进入注册表编辑器，然后依次找到 HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Shared Tools\\Text Converters\\Import\\MSWord6.wpc，这个路径，将“MSWord6.wpc”删除即可。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/categories/Windows/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/tags/Windows/"}],"author":"chenhy"},{"title":"pure开启文章目录","slug":"pure开启文章目录","date":"2021-03-04T08:15:00.000Z","updated":"2021-03-04T16:15:17.111Z","comments":true,"path":"2021/03/04/pure开启文章目录/","link":"","permalink":"https://born2do.github.io/2021/03/04/pure%E5%BC%80%E5%90%AF%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95/","excerpt":"","text":"我的Hexo博客使用的主题名为“pure”，在最开始搭建时，就将主题配置文件的关于文章目录的toc开启了，但是发现并没有效果。后搜索发现需要这样做： 主题配置文件blog/themes/pure/_config.yml里面config → toc: true开启目录 每一篇文章blog/source/_posts/xxx.md的头部都加上toc: true 文章模板blog/scaffolds/post.md的头部也加上toc: true 这样子，新老文章的目录都已经开启了。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"}],"author":"chenhy"},{"title":"Hexo博客网站安装gitalk插件","slug":"Hexo博客网站安装gitalk插件","date":"2021-03-04T07:30:00.000Z","updated":"2021-03-04T16:03:09.451Z","comments":true,"path":"2021/03/04/Hexo博客网站安装gitalk插件/","link":"","permalink":"https://born2do.github.io/2021/03/04/Hexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E5%AE%89%E8%A3%85gitalk%E6%8F%92%E4%BB%B6/","excerpt":"","text":"博客的评论系统，一开始选择了“来必力”（韩国的），但是发现注册个账号要人命，果断放弃。后在Gitalk和Gitment之间选择了Gitalk。开源免费无广告，不要因为是个白嫖党而不好意思，毕竟正是开源促进了IT业的发展。在此记录下，博客网站安装评论系统的全过程。 注册 GitHub OAuth AppsGitHub头像-&gt;Settings-&gt;Developer settings-&gt;OAuth Apps，点击“new OAuth apps”进行OAuth application的创建。注册成功后，复制ClientID以及生成的ClientSecret，待用。 新建仓库新建仓库，用于存储评论。 Hexo引入Gitalk打开主题配置文件，修改评论系统相关配置。我使用的Hexo的主题名为pure，主题配置文件中，注释相当详细，在此不做过多赘述。 上传GitHub并初始化评论系统本地的评论系统完成后，将本地博客系统上传至GitHub仓库。访问下在GitHub上的博客，会发现评论模块会提示初始化提示，使用自己的GitHub账号登陆下就好了。 Gitalk 403报错我的Gitalk一开始就显示403报错，查阅相关资料，是因为“Public demo server (cors-anywhere.herokuapp.com) will be very limited by January 2021, 31st”，网站受限了。解决方式就是点击下方的链接进行暂时权限的获取（初始化后就不用管他了）。解锁链接： http://cors-anywhere.herokuapp.com/corsdemo 。 参考链接https://www.cnblogs.com/qisi007/p/13731562.html","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"},{"name":"Gitalk","slug":"Gitalk","permalink":"https://born2do.github.io/tags/Gitalk/"}],"author":"chenhy"},{"title":"博客图床设置","slug":"博客图床设置","date":"2021-03-03T07:30:00.000Z","updated":"2021-03-03T15:46:55.254Z","comments":true,"path":"2021/03/03/博客图床设置/","link":"","permalink":"https://born2do.github.io/2021/03/03/%E5%8D%9A%E5%AE%A2%E5%9B%BE%E5%BA%8A%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"以前写博客，基本上都是在本地，博客中的图片也都是使用相对路径。在博客园也写过博客，那时图片是上传到博客园的自定义文件夹中，再去复制图片链接使用。但是，这些使用图片的方式都不太友善，不好管理。这次重新搭建整理博客，我开始使用图床了。 下载图片管理工具PicGo （不喜欢也可略过）我使用的图片管理工具为PicGo（ https://picgo.github.io/PicGo-Doc/ ）。官方文档（ https://picgo.github.io/PicGo-Doc/zh/guide/config.html ）极为详细，先无脑安装一波，然后按照官方文档进行配置就好了。 图床图床网站还是比较多的，当然，也可以在GitHub上自行搭建仓库用于存储图片。一开始，我是想用GitHub自行搭建的，但是搭建完成后发现，网络太慢了，基本上加载不出来。然后对比了多家图床网站后，选择了SMMS。速度快，无广告，存储空间还挺大，与PicGo搭配使用配置起来也比较简单。自行注册，生成token，然后配置到PicGo中，配置完成。极力推荐SMMS！！！","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"图床","slug":"博客搭建/图床","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"PicGo","slug":"PicGo","permalink":"https://born2do.github.io/tags/PicGo/"},{"name":"SMMS","slug":"SMMS","permalink":"https://born2do.github.io/tags/SMMS/"}],"author":"chenhy"},{"title":"GitHub新建仓库，默认分支由master改为main","slug":"GitHub新建仓库，默认分支由master改为main","date":"2021-03-03T05:30:00.000Z","updated":"2021-03-03T15:44:18.753Z","comments":true,"path":"2021/03/03/GitHub新建仓库，默认分支由master改为main/","link":"","permalink":"https://born2do.github.io/2021/03/03/GitHub%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%88%86%E6%94%AF%E7%94%B1master%E6%94%B9%E4%B8%BAmain/","excerpt":"","text":"在使用Hexo搭建好本地博客后，推送至GitHub仓库。由于长时间未使用GitHub了，并不知晓新建仓库的默认分支由master改为main了，在站点配置文件中branch的值写成了master。使用git上传后，在原有仓库新增了一个master分支。发现这个问题后，我直接将GitHub仓库中的master分支删除掉了，并修改本地站点配置文件中的master为main，重新进行了推送。幸好及时发现，做了更正，可谓是及时止损呐。 默认分支更名，可以去GitHub上看看 https://github.com/github/renaming.git 。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://born2do.github.io/tags/GitHub/"}],"author":"chenhy"},{"title":"hexo报错TypeError: Cannot read property 'count' of undefined","slug":"hexo报错TypeError-Cannot-read-property-'count'-of-undefined","date":"2021-03-03T04:30:00.000Z","updated":"2021-03-03T15:44:42.224Z","comments":true,"path":"2021/03/03/hexo报错TypeError-Cannot-read-property-'count'-of-undefined/","link":"","permalink":"https://born2do.github.io/2021/03/03/hexo%E6%8A%A5%E9%94%99TypeError-Cannot-read-property-'count'-of-undefined/","excerpt":"","text":"情景再现使用“hexo s”启动本地服务器时，项目报错，具体如下： 1234567891011121314151617181920D:\\blog&gt;hexo sINFO Validating configINFO Start processingFATAL &#123; err: TypeError: Cannot read property &#x27;count&#x27; of undefined at Hexo.module.exports (D:\\blog\\node_modules\\_hexo-baidu-url-submit@0.0.6@hexo-baidu-url-submit\\lib\\generator.js:4:41) at Hexo.tryCatcher (D:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at Hexo.&lt;anonymous&gt; (D:\\blog\\node_modules\\bluebird\\js\\release\\method.js:15:34) at D:\\blog\\node_modules\\hexo\\lib\\hexo\\index.js:405:22 at tryCatcher (D:\\blog\\node_modules\\bluebird\\js\\release\\util.js:16:23) at MappingPromiseArray._promiseFulfilled (D:\\blog\\node_modules\\bluebird\\js\\release\\map.js:68:38) at MappingPromiseArray.PromiseArray._iterate (D:\\blog\\node_modules\\bluebird\\js\\release\\promise_array.js:115:31) at MappingPromiseArray.init (D:\\blog\\node_modules\\bluebird\\js\\release\\promise_array.js:79:10) at MappingPromiseArray._asyncInit (D:\\blog\\node_modules\\bluebird\\js\\release\\map.js:37:10) at _drainQueueStep (D:\\blog\\node_modules\\bluebird\\js\\release\\async.js:97:12) at _drainQueue (D:\\blog\\node_modules\\bluebird\\js\\release\\async.js:86:9) at Async._drainQueues (D:\\blog\\node_modules\\bluebird\\js\\release\\async.js:102:5) at Immediate.Async.drainQueues [as _onImmediate] (D:\\blog\\node_modules\\bluebird\\js\\release\\async.js:15:14) at processImmediate (internal/timers.js:461:21)&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 而在这之前，我安装了hexo-baidu-url-submit插件。 处理从报错日志中我们可以看到是由于hexo-baidu-url-submit插件导致的，查看官方文档（ https://github.com/huiwang/hexo-baidu-url-submit ）发现是由于没有在站点配置文件配置baidu-url-submit配置项导致。这里介绍两种处理方式： 1.补全相关配置信息 注册百度站长（ https://ziyuan.baidu.com/ ）（需要有自己的域名），获取相关token等必要信息。 将baidu-url-submit配置项添加至站点配置文件中。123456#设置百度主动推送baidu_url_submit: count: 200 #比如200，代表提交最新的200个链接 host: www.baidu.com # 在百度站长平台中注册的域名，这个改为你自己的域名 token: your_token # 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里! path: baidu_urls.txt # 文本文档的地址， 新链接会保存在此文本文档里，这个默认 此外，还需要在站点配置文件中加入新的 deploy 配置项：123456deploy:- type: git repo: 【GitHub项目地址】 branch: main- type: baidu_url_submitter 2.放弃百度主动推送功能，卸载该插件即可。123npm remove hexo-baidu-url-submithexo cleanhexo g 由于没有域名，我选择了后者，放弃了百度主动推送功能。第一种处理方式是从他人博客参考获取，可行性仍有待进一步验证。 参考链接 https://blog.csdn.net/nineya_com/article/details/103445898 https://blog.yirenliu.cn/posts/42821/#%E7%99%BE%E5%BA%A6%E4%B8%BB%E5%8A%A8%E6%8E%A8%E9%80%81%E7%9A%84%E4%BD%9C%E7%94%A8","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"}],"author":"chenhy"},{"title":"hexo s 报错","slug":"hexo-s-报错","date":"2021-03-02T06:30:00.000Z","updated":"2021-03-02T15:35:39.108Z","comments":true,"path":"2021/03/02/hexo-s-报错/","link":"","permalink":"https://born2do.github.io/2021/03/02/hexo-s-%E6%8A%A5%E9%94%99/","excerpt":"","text":"情景再现在执行“hexo s”，启动本地服务器时，控制台报错如下： 123456$ hexo sINFO Validating configFATAL Permission denied. You can&#39;t use port 4000.FATAL &#123; err: Error: listen EACCES: permission denied 0.0.0.0:4000…… 处理查看报错日志，很明显是默认启动端口4000已经被占用。为了不影响现有已运行程序，我们暂时修改启动端口，命令如下： 1hexo s -p 5555 服务器成功启动。 此时，需通过 http://localhost:5555/ 来访问本地博客。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"}],"author":"chenhy"},{"title":"hexo init 403超时报错","slug":"hexo-init-403超时报错","date":"2021-03-02T06:00:00.000Z","updated":"2021-03-02T15:32:20.353Z","comments":true,"path":"2021/03/02/hexo-init-403超时报错/","link":"","permalink":"https://born2do.github.io/2021/03/02/hexo-init-403%E8%B6%85%E6%97%B6%E6%8A%A5%E9%94%99/","excerpt":"","text":"情景再现在执行“hexo init blog”，对blog文件夹初始化时，控制台报错如下： 1234$ hexo init blogINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.gitfatal: unable to access &#x27;https://github.com/hexojs/hexo-starter.git/&#x27;: Failed to connect to github.com port 443: Timed out…… 处理403网络超时报错，那么恭喜你，被墙了。解决方式如下： 1.检查是否真正由于无法连接GitHub导致。在Windows命令行下，执行如下命令： 1ping github.com 如果结果显示100%丢失，那么就是因为无法连接到GitHub导致。 12345678正在 Ping github.com [13.229.188.59] 具有 32 字节的数据:请求超时。请求超时。请求超时。请求超时。13.229.188.59 的 Ping 统计信息: 数据包: 已发送 &#x3D; 4，已接收 &#x3D; 0，丢失 &#x3D; 4 (100% 丢失)， 如果不是，请不要继续往下看了，浪费时间。请另寻他法。 2.配置本地hosts访问站长工具网站（ http://tool.chinaz.com/dns?type=1&amp;host=github.com&amp;ip= ），获取GitHub的相关DNS。先在本地ping相应的IP，如果可以连接上并且速度还行，那么可以将相关信息配置到本地hosts文件中。 113.114.40.48 github.com hosts文件配置完成后，在命令行执行如下命令： 12345$ ipconfig &#x2F;flushdnsWindows IP 配置已成功刷新 DNS 解析缓存。 3.完美解决重新打开命令行窗口，执行“hexo init blog”，你会发现片刻后Hexo初始化便完成了。 获取GitHub的DNS方式不止这一种方式，你也可以访问ipaddress网站（ https://github.com.ipaddress.com/www.github.com ）获取相关IP，更多方式请自行百度。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"}],"author":"chenhy"},{"title":"博客搭建","slug":"博客搭建","date":"2021-03-02T03:00:00.000Z","updated":"2021-03-02T15:30:13.664Z","comments":true,"path":"2021/03/02/博客搭建/","link":"","permalink":"https://born2do.github.io/2021/03/02/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"采用GitHub+Hexo搭建博客。优点：干净好看，自主性强，没广告。缺点：在建设过程中，很容易遇到墙，随之而来的便是失败了。在此，记录下博客搭建过程。 Node.js官网（ https://nodejs.org/zh-cn/download/ ）下载node.js安装包，无脑安装即可。Windows命令行下，检查是否成功安装： 12345D:\\&gt;node -vv12.19.0D:\\&gt;npm -v6.14.8 使用npm下载依赖时，由于是从国外的网站上下载内容，所以可能经常会出现不稳定的情况，所以需要下载cnpm代替npm，cnpm是国内淘宝的做的，在国内使用较为稳定。 12341.下载cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org2.下载依赖cnpm i 或者 cnpm install 在后续的npm操作中，如卡顿或是直接超时报错，建议使用cnpm代替npm。 Git官网（ https://git-scm.com/downloads ）下载Git安装包，在安装过程中如遇到“Use Windows’ default console window”，选择该项即可。剩余步骤无脑安装即可。Windows命令行下，检查是否成功安装： 12D:\\&gt;git --versiongit version 2.22.0.windows.1 配置GitHubSSH1.在本地生成SSH key1$ ssh-keygen -t rsa -C &quot;GitHub注册邮箱&quot; 一般默认在 C:\\Users\\【你的用户名】\\.ssh\\ 目录下生成相应的id_rsa.pub文件。 2.GitHub添加SSH Keysettings-&gt;SSH and GPG keys-&gt;New SSH key,title随意，key则填写id_rsa.pub中的内容。 Hexo本地博客搭建官网（ https://hexo.io/zh-cn/ ），官方文档较为详细，可先自行阅读后再进行搭建工作。 1.框架搭建123456$ D:$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 以上命令是在D盘初始化了一个blog文件夹，该文件夹存放的是Hexo静态资源。使用命令行界面进入D:\\blog，执行“hexo server”，使用浏览器访问 http://localhost:4000 即可看到我们搭建的博客网站。 2.主题替换以及相关配置文件修改从官网下载自己心仪的主题，解压缩放置到D:\\blog\\themes\\目录下。更改根目录下的_config.yml文件，修改theme后面的值为刚才解压缩的文件夹名。重新执行“hexo server”，刷新浏览器会发现博客网站主题已经改变。配置文件已经插件的下载安装，请自行查阅官网文档以及主题的帮助文档。不在此做过多介绍。 本地博客发布至GitHub在GitHub上新建仓库，名称格式为“【你的GitHub昵称】.github.io”。更改根目录下的_config.yml文件，修改deploy后面的内容。 1234deploy: type: git repo: [你的仓库地址] branch: main 使用命令行界面进入D:\\blog，执行如下命令： 123hexo cleanhexo ghexo d 至此，静态博客网站搭建完成。 实际上在搭建过程中，遇到了不少问题，并没有上述那么顺利。本文仅作流程参考，如果在搭建过程中遇到了其他问题，还请自行百度解决。后续几篇文章我将分享下我在搭建过程中遇到的一些问题以及相应的解决办法，供大家参考。","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"https://born2do.github.io/tags/GitHub/"},{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"}],"author":"chenhy"},{"title":"Welcome to my blog","slug":"Welcome-to-my-blog","date":"2021-03-02T02:00:00.000Z","updated":"2021-03-02T14:30:28.350Z","comments":true,"path":"2021/03/02/Welcome-to-my-blog/","link":"","permalink":"https://born2do.github.io/2021/03/02/Welcome-to-my-blog/","excerpt":"","text":"博客建设，从CSDN到GitHub到博客园再到GitHub，从hexo到hugo再到hexo，最终还是选择了 Github+Hexo的方式来搭建自己的博客。兜兜转转，还是她。原因如下： 使用gitpage搭建静态网站的成本为0 。 使用Hexo生成静态网站，简单、方便、美观。 Github+Hexo的搭建模式较为常见、流行，遇到问题了，网络上的解决办法比较多。 后续我会将其他网站上的博客逐步迁移至GitHub上，只在该网站上进行博客的发布。网址：https://born2do.github.io并非大神，不喜勿喷。若博客有不到位之处，还烦请指正，感谢！！！","categories":[],"tags":[],"author":"chenhy"},{"title":"Hello World","slug":"hello-world","date":"2021-02-28T15:59:12.950Z","updated":"2021-02-28T15:59:12.950Z","comments":true,"path":"2021/02/28/hello-world/","link":"","permalink":"https://born2do.github.io/2021/02/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"MySQL学习Day02","slug":"MySQL学习Day02","date":"2019-08-12T08:39:24.000Z","updated":"2021-05-13T14:35:16.867Z","comments":true,"path":"2019/08/12/MySQL学习Day02/","link":"","permalink":"https://born2do.github.io/2019/08/12/MySQL%E5%AD%A6%E4%B9%A0Day02/","excerpt":"","text":"基本概念 数据库（database），保存有组织的数据的容器。 表（table），某种特定类型数据的结构化清单。 模式（schema），关于数据库和表的布局及特性的信息。（有时也用作数据库的同义词） 列（column），表中的一个字段。所有表都是由一个或多个列组成的。 数据类型（datatype），所容许的数据的类型。每个表列都有相应的数据类型，它限制该列中存储的数据。 行（row），表中的一个记录。（行和记录是可以相互替代的，但从技术上说，行才是正确的术语。） 主键（primary key），一列（或一组列），其值能够唯一区分表中每个行。 主键值规则： 任意两行都不具有相同的主键值 每个行都必须具有一个主键值（主键值不允许NULL值） 不更新主键列中的值 不重用主键列的值 不在主键列中使用可能会更改的值。 SQL，结构化查询语言（Structured Query Language），是一种专门用来与数据库通信的语言。 DBMS，数据库管理系统（Database Management System）。 DBMS可分为两类： 一类为基于共享文件系统的DBMS，如Microsoft Access、FileMaker等，通常不用于高端或更关键的应用。 另一类为基于客户机-服务器的DBMS，如MySQL、Oracle、Microsoft SQL Server等。应用范围更广、更高端。 子句（clause），SQL语句由子句构成，有些子句是必需的，而有些则是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有select语句中的from子句。 操作符（operator），用来联结或改变where子句中的子句的关键字。也称为逻辑操作符。 AND，用在where子句中的关键字，用来指示检索满足所有给定条件的行。 OR，用在where子句中的关键字，用来表示检索匹配任一给定条件的行。 IN，where子句中用来指定要匹配值的清单的关键字，功能与OR相当。 NOT，where子句中用来否定后跟条件的关键字。 通配符（wildcard），用来匹配值的一部分的特殊字符。 搜索模式（search pattern），由字面值、通配符或两者组合构成的搜索条件。 使用MySQL 连接MySQL 1mysql -u root -p 回车后，输入密码即可进入数据库。 连接到MySQL，一般需要以下信息： 主机名（计算机名），如果连接到本地MySQL服务器，则为localhost 端口，默认为3306端口 一个合法的用户名 用户口令 常用操作： 查看数据库 1show databases; 选择数据库 1use 数据库名; 查看表 1show tables; 在MySQL中，单引号用来限定字符串。 基本操作select 语句 检索单列 1select name from tb_course; 检索多列 1select name,addr from tb_course; 列名之间以逗号分隔。 显示的数据也是按照检索时的列名顺序排列的。 检索所有列 1select * from tb_course; 提醒：尽量不要使用通配符，影响执行效率。 检索不同的行，使用DISTINCT关键字，在列名的前面。 1select distinct pwd from tb_userlogin; 限制结果。为了返回第一行或前几行，可使用LIMIT子句。 返回前几行数据 1select pwd from tb_userlogin limit 5; 运行结果： 123456789+--------+| pwd |+--------+| mrsoft || user || 111 || 555 || 111 |+--------+ 指定检索的开始行和行数 1select pwd from tb_userlogin limit 0,5; 运行结果： 123456789+--------+| pwd |+--------+| mrsoft || user || 111 || 555 || 111 |+--------+ 注意：检索出来的第一行为行0而不是行1。limit 1,1，将检索出第二行。 对于列的使用，既可以通过列名引用列，也可以使用完全限定的名字来使用列（表名和列名同时使用）。部分情形需要使用完全限定名。 order by 子句 排序数据 1select name from tb_specialty order by name; order by 子句中使用的列通常为所选择的列，如上述语句。但是，并不一定要这样，也可以使用非选择列进行排序，如下面的语句。 1select name from tb_specialty order by lengthYear; 按多个列排序 123select enterYear,name,lengthYear from tb_specialty order by enterYear,lengthYear; 在按多个列排序时，排序完全按所规定的顺序进行。 指定排序方向 默认的排序顺序是升序排序（从A到Z），也可以指定以降序顺序排序。这时使用DESC关键字。 1select name from tb_specialty order by name desc; 如果想在多个列上进行降序排序，必须对每个列指定DESC关键字。 123select enterYear,name,lengthYear from tb_specialty order by enterYear desc,lengthYear desc; 关键字ASC用于升序排序，但无多大用处，因为系统默认为升序排序。 order by 和 limit 的组合可以找出一个列的最高或最低的值。 1select id from tb_specialty order by id desc limit 1; 上述语句，找出了表tb_specialty中的最大的id值。 where 子句 过滤数据 123select enterYear,name from tb_specialty where enterYear &#x3D; 2005; 在同时使用order by 和where 子句时，应让order by位于where之后，否则将会产生错误。 1234select enterYear,name from tb_specialty where enterYear &#x3D; 2005 order by name; where子句操作符 操作符 说明 = 等于 &lt;&gt; 不等于 != 不等于 &lt; 小于 &lt;= 小于等于 &gt; 大于 &gt;= 大于等于 between 在指定的两个值之间（包括开始值和结束值） 注意：MySQL在执行匹配时默认不区分大小写。 检查单个值 123select enterYear,name,lengthYear from tb_specialty where lengthYear &lt;&#x3D; 3; 不匹配检查 123select enterYear,name,lengthYear from tb_specialty where lengthYear &lt;&gt; 3; 123select enterYear,name,lengthYear from tb_specialty where lengthYear !&#x3D; 3; 上述两个语句的结果是完全相同的。 范围值检查 1234select enterYear,name,lengthYear from tb_specialty where lengthYear between 3 and 4; between匹配范围中所有的值，包括指定的开始值和结束值。 空值检查 在一个列不包含值时，称其为包含空值NULL。 123select enterYear,name,lengthYear from tb_specialty where lengthYear is null; 数据过滤 为了进行更强的过滤控制，MySQL允许给出多个where子句。这些子句能够以and子句的方式或是or子句的方式使用。 and操作符 123select enterYear,name,lengthYear from tb_specialty where enterYear &#x3D; 2005 and lengthYear &lt;&#x3D; 3; 运行结果： 123456+-----------+--------------------+------------+| enterYear | name | lengthYear |+-----------+--------------------+------------+| 2005 | 美术装潢设计 | 2 || 2005 | 遥感技术 | 2 |+-----------+--------------------+------------+ or操作符 123select enterYear,name,lengthYear from tb_specialty where enterYear &#x3D; 2005 or lengthYear &lt;&#x3D; 3; 运行结果： 123456789+-----------+--------------------+------------+| enterYear | name | lengthYear |+-----------+--------------------+------------+| 2005 | 美术装潢设计 | 2 || 2005 | 进出口贸易 | 4 || 2010 | 计算机 | 3 || 2010 | 数据结构 | 2 || 2005 | 遥感技术 | 2 |+-----------+--------------------+------------+ and操作符在计算次序中优先级高于or操作符。然而，该知识点不需要强记，在实际操作中，使用括号即可，高效避免不必要的错误。 IN操作符 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。 IN取合法值的由逗号分隔的清单，全部括在圆括号中。 123select enterYear,name,lengthYear from tb_specialty where enterYear in (2012,2005); 运行结果： 12345678+-----------+--------------------+------------+| enterYear | name | lengthYear |+-----------+--------------------+------------+| 2005 | 美术装潢设计 | 2 || 2005 | 进出口贸易 | 4 || 2005 | 遥感技术 | 2 || 2012 | 编译原理 | NULL |+-----------+--------------------+------------+ IN操作符的优点： 语法更清楚且更直观 计算次序容易管理（使用的操作符少） IN操作符一般比OR操作符清单执行更快 最大的优点是，可以包含其它select语句，使得能够更动态地建立where子句。 NOT操作符 NOT操作符有且只有一个功能——否定后跟的任何条件。 1select enterYear,name,lengthYear from tb_specialty where enterYear not in (2012,2005); 运行结果： 123456+-----------+--------------+------------+| enterYear | name | lengthYear |+-----------+--------------+------------+| 2010 | 计算机 | 3 || 2010 | 数据结构 | 2 |+-----------+--------------+------------+ 使用通配符进行过滤 LIKE操作符，搭配通配符使用。 通配符可以在搜索模式中任意位置使用，并且可以使用多个通配符。 百分号（%）通配符，表示任何字符出现任意次数。 1select stuName,tel from tb_stuuser where stuName like &#39;张%&#39;; 运行结果： 1234567+-----------+---------------+| stuName | tel |+-----------+---------------+| 张三 | 0431-84972266 || 张天 | 0551-88569856 || 张大民 | 1212-45445484 |+-----------+---------------+ 注意：除了一个或多个字符外，%还可以匹配0个字符。 下划线（_）通配符，只匹配单个字符。 1select stuName,tel from tb_stuuser where stuName like &#39;张_&#39;; 运行结果： 123456+---------+---------------+| stuName | tel |+---------+---------------+| 张三 | 0431-84972266 || 张天 | 0551-88569856 |+---------+---------------+ 与%能匹配0个字符不同，_总是匹配一个字符，不能多也不能少。 使用通配符的技巧 不要过度使用通配符。尽量使用其它操作符。 在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处，会很影响执行效率。 仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据。 用正则表达式（regexp）进行搜索正则表达式是用来匹配文本的特殊的串（字符集合）。 基本字符匹配 123select stuName,tel from tb_stuuser where stuName regexp &#39;张&#39;; 运行结果： 1234567+-----------+---------------+| stuName | tel |+-----------+---------------+| 张三 | 0431-84972266 || 张天 | 0551-88569856 || 张大民 | 1212-45445484 |+-----------+---------------+ .是正则表达式语言中一个特殊的字符，它表示匹配任意一个字符。 1select stuName,tel from tb_stuuser where stuName regexp &#39;.天&#39;; 运行结果： 123456+---------+---------------+| stuName | tel |+---------+---------------+| 张天 | 0551-88569856 || 明天 | 1121-12349234 |+---------+---------------+ 进行OR匹配 为搜索两个（或多个）串之一，使用|。 123select stuName,tel from tb_stuuser where stuName regexp &#39;张|王&#39;; 运行结果： 12345678+-----------+---------------+| stuName | tel |+-----------+---------------+| 张三 | 0431-84972266 || 张天 | 0551-88569856 || 张大民 | 1212-45445484 || 王明 | 0551-15984951 |+-----------+---------------+ 匹配几个字符之一 为匹配特定的字符，使用[]。 1select stuName,tel from tb_stuuser where stuName regexp &#39;[12A]tom&#39;; 这里的[12A]定义了一组字符，它的意思是匹配1或2或A。 运行结果： 1234567+-----------+---------------+| stuName | tel |+-----------+---------------+| 1Tom | 87793*** || Atom | 0431-84972266 || 2Tom Chen | 0431-84972266 |+-----------+---------------+ 字符集合也可以被否定，即它们将匹配除指定字符外的任何东西。为否定一个字符集，在集合的开始处放置一个^即可。 1select stuName,tel from tb_stuuser where stuName regexp &#39;[^12A]tom&#39;; 运行结果： 12345+---------+---------------+| stuName | tel |+---------+---------------+| 5Tom | 0431-84972266 |+---------+---------------+ 匹配范围 集合可用来定义要匹配的一个或多个字符。 常见集合[0-9]（等价于[0123456789]）、[a-z]，可拆分。 1select stuName,tel from tb_stuuser where stuName regexp &#39;[1-9]tom&#39;; 运行结果： 12345678+-----------+---------------+| stuName | tel |+-----------+---------------+| 1Tom | 87793*** || 2Tom Chen | 0431-84972266 || 5Tom | 0431-84972266 || .7Tom | 0431-84972266 |+-----------+---------------+ [a-z]和[A-Z]是一样的，大小写不区分。 1select stuName,tel from tb_stuuser where stuName regexp &#39;[a-z]om&#39;; 1select stuName,tel from tb_stuuser where stuName regexp &#39;[A-Z]om&#39;; 运行结果都是： 123456789+-----------+---------------+| stuName | tel |+-----------+---------------+| 1Tom | 87793*** || Atom | 0431-84972266 || 2Tom Chen | 0431-84972266 || 5Tom | 0431-84972266 || .7Tom | 0431-84972266 |+-----------+---------------+ 匹配特殊字符 为了匹配特殊字符，必须用\\\\为前导。\\\\-表示查找-，\\\\.表示查找.。 1select stuName,tel from tb_stuuser where stuName regexp &#39;\\\\.&#39;; 运行结果： 12345+---------+---------------+| stuName | tel |+---------+---------------+| .7Tom | 0431-84972266 |+---------+---------------+ 匹配字符类 为方便工作，可以使用预定义的字符集，称为字符类（character class）。 字符类 说明 [:alnum:] 任意字母和数字（[a-zA-Z0-9]） [:alpha:] 任意字符（[a-zA-z]） [:blank:] 空格和制表（[\\\\t]） [:cntrl:] ASCII控制字符（ASCII0-31和127） [:digit:] 任意数字（[0-9]） [:graph:] 与[:print:]相同，但不包括空格 [:lower:] 任意小写字母（[a-z]） [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包括空格在内的任意空白字符（[\\\\f\\\\n\\\\r\\\\t\\\\v]） [:upper:] 任意大写字母 [:xdigit:] 任意十六进制数字（[a-fA-f0-9]） 123select stuName,tel from tb_stuuser where stuName regexp &#39;[[:alpha:]]om&#39;; 运行结果： 123456789+-----------+---------------+| stuName | tel |+-----------+---------------+| 1Tom | 87793*** || Atom | 0431-84972266 || 2Tom Chen | 0431-84972266 || 5Tom | 0431-84972266 || .7Tom | 0431-84972266 |+-----------+---------------+ 实践证明，在查询过程中，不区分大小写。 匹配多个实例 重复元字符 说明 * 0个或多个匹配 + 1个或多个匹配（{1,}） ？ 0个或1个匹配（等于{0,1}） {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围（m不超过255） 123select stuName,tel from tb_stuuser where stuName regexp &#39;[[:alpha:]]oms?q&#39;; s后的？使s可选，因为？匹配它前面的任何字符的0次或1次出现。 运行结果： 123456+----------+---------------+| stuName | tel |+----------+---------------+| 5Tomsqqq | 0431-84972266 || .7Tomqqq | 0431-84972266 |+----------+---------------+ 定位符 为了匹配任意位置的文本，需要用到下面的定位符。 定位元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 1select stuName,tel from tb_stuuser where stuName regexp &#39;^[[:digit:]]&#39;; 运行结果： 1234567891011+-----------+---------------+| stuName | tel |+-----------+---------------+| 1Tom4545 | 87793*** || 2Tom Chen | 0431-84972266 || 5Tomsqqq | 0431-84972266 || 89oms | 33 || 8仙 | 8 || 2货 | 2 || 996 | 555 |+-----------+---------------+ ^有两种用法，在集合中（[]）用于否定该集合，集合外用于指示串的开始处。 LIKE和REGEXP的不同在于，LIKE匹配整个串而REGEXP匹配子串。 创建计算字段 字段（field），基本上与列的意思相同，经常互换使用。不过数据库列一般成为列，而术语字段经常用在计算字段的连接上。 计算字段是运行时在select语句内创建的。 拼接（concatenate），将值联结到一起构成单个值。 字段拼接 在MySQL的SELECT语句中，可使用Concat()函数来拼接两个列。不区分大小写。 123select concat(stuName,&#39;(&#39;,tel,&#39;)&#39;) from tb_stuuser where stuName like &#39;张%&#39;; 运行结果： 1234567+-----------------------------+| concat(stuName,&#39;(&#39;,tel,&#39;)&#39;) |+-----------------------------+| 张三(0431-84972266) || 张天(0551-88569856) || 张大民(1212-45445484) |+-----------------------------+ 去空格函数： RTrim()：除去字符串右边的空格 LTrim()：除去字符串左边的空格 Trim()：除去字符串左右两边的空格 使用别名 别名（alias）是一个字段或值的替换名。别名用AS关键字赋予。有时也称为导出列。 别名由字母、数字、下划线（_）、符号$、￥构成，不可出现其它字符（如括号等）。 123select Concat(stuName,&#39;(&#39;,tel,&#39;)&#39;) as name_tel from tb_stuuser where stuName like &#39;张%&#39;; 运行结果： 1234567+--------------------------+| name_tel |+--------------------------+| 张三(0431-84972266) || 张天(0551-88569856) || 张大民(1212-45445484) |+--------------------------+ 执行算数计算 MySQL支持下表中列出的基本算术运算符，此外圆括号可用来区分优先顺序。 MySQL算数操作符 说明 + 加 - 减 * 乘 / 除 123select name,enterYear,enterYear+lengthYear as endYear from tb_specialty order by enterYear; 运行结果： 12345678910+--------------------+-----------+---------+| name | enterYear | endYear |+--------------------+-----------+---------+| 美术装潢设计 | 2005 | 2007 || 进出口贸易 | 2005 | 2009 || 遥感技术 | 2005 | 2007 || 计算机 | 2010 | 2013 || 数据结构 | 2010 | 2012 || 编译原理 | 2012 | NULL |+--------------------+-----------+---------+ 测试计算 有时可以省略from子句以便简单地访问和处理表达式。 select 6*9; 123运行结果： +-----+ | 6*9 | +-----+ | 54 | +-----+ 123- &#96;&#96;&#96;mysql select Trim(&#39;abc&#39;); 运行结果： 12345+-------------+| Trim(&#39;abc&#39;) |+-------------+| abc |+-------------+ select now(); 1 +---------------------+ | now() | +---------------------+ | 2019-08-14 10:05:47 | +---------------------+ 12345678910111213141516171819202122### 使用数据处理函数1. 文本处理函数 | 常用的文本处理函数 | 说明 | | ------------------ | --------------------------------- | | Left() | 返回串左边的字符 | | Length() | 返回串的长度 | | Locate() | 找出串的一个字串 | | Lower() | 将串转换为小写 | | LTrim() | 去掉串左边的空格 | | Right() | 返回串右边的字符 | | RTrim() | 去掉串右边的空格 | | Soundex() | 返回串的SOUNDEX值（模糊发音搜索） | | SubString() | 返回子串的字符 | | Upper() | 将串转换为大写 | &#96;&#96;&#96;mysql select stuName,Upper(stuName) as stuName_upcase from tb_stuuser where stuName &#x3D; &#39;alexander&#39;; 运行结果： 12345+-----------+----------------+| stuName | stuName_upcase |+-----------+----------------+| alexander | ALEXANDER |+-----------+----------------+ 日期和时间处理函数 常用日期和时间处理函数 说明 AddDate() 增加一个日期（天、周等） AddTime() 增加一个时间（时、分等） CurDate() 返回当前日期 CurTime() 返回当前时间 Date() 返回日期时间的日期部分 DateDiff() 计算两个日期之差 Date_Add() 高度灵活的日期运算函数 Date_Format() 返回一个格式化的日期或时间串 Day() 返回一个日期的天数部分 DayofWeek() 对于一个日期，返回对应的星期几 Hour() 返回一个时间的小时部分 Minute() 返回一个时间的分钟部分 Now() 返回当前日期和时间 Second() 返回一个时间的秒部分 Time() 返回一个日期时间的时间部分 Year() 返回一个日期的年份部分 Month() 返回一个日期的月份部分 123select stuName,birthday,tel from tb_stuuser where Date(birthday) between &#39;1981-08-01&#39;and &#39;1981-08-10&#39;; 运行结果： 123456789+-------------+------------+---------------+| stuName | birthday | tel |+-------------+------------+---------------+| 张三 | 1981-08-01 | 0431-84972266 || Atom | 1981-08-01 | 0431-84972266 || 2Tom Chen | 1981-08-01 | 0431-84972266 || 5Toms qqq | 1981-08-08 | 0431-84972266 || alexander | 1981-08-01 | 0431-84972266 |+-------------+------------+---------------+ 数值处理函数 常用的数值处理函数 说明 Abs() 返回一个数的绝对值 Cos() 返回一个角度的余弦 Exp() 返回一个数的指数值 Mod() 返回除操作的余数，即取余 Pi() 返回圆周率 Rand() 返回一个随机数 Sin() 返回一个角度的正弦 Sqrt() 返回一个数的平方根 Tan() 返回一个角度的正切 汇总数据 聚集函数 聚集函数（aggregate function），运行在行组上，计算和返回单个值的函数。 SQL聚集函数 说明 AVG() 返回某列的平均值（忽略列值为NULL的行） COUNT() 返回某列的行数 MAX() 返回某列的最大值（忽略列值为NULL的行） MIN() 返回某列的最小值（忽略列值为NULL的行） SUM() 返回某列值之和（忽略列值为NULL的行） AVG()函数 注意：AVG()函数忽略列值为NULL的行。 1select AVG(lengthYear) as avg_lengthYear from tb_specialty; 运行结果： 12345+--------------------+| avg_lengthYear |+--------------------+| 2.1666666666666665 |+--------------------+ COUNT()函数 两种使用方式： count(*)，对表中行的数目进行计数，不管表列中包含的是否为空值（NULL）。 1select count(*) as class_count from tb_specialty; 运行结果： 12345+-------------+| class_count |+-------------+| 6 |+-------------+ count(column)，对特定列中具有值的行进行计数，忽略NULL值的行。 1select count(lengthYear) as class_count from tb_specialty; 运行结果： 12345+-------------+| class_count |+-------------+| 5 |+-------------+ MAX()函数 1select MAX(lengthYear) as max_lengthYear from tb_specialty; 运行结果： 12345+----------------+| max_lengthYear |+----------------+| 4 |+----------------+ MIN()函数 1select MIN(lengthYear) as min_lengthYear from tb_specialty; 运行结果： 12345+----------------+| min_lengthYear |+----------------+| 2 |+----------------+ SUM()函数 1select SUM(lengthYear) as sum_lengthYear from tb_specialty; 运行结果： 12345+----------------+| sum_lengthYear |+----------------+| 13 |+----------------+ 聚集不同值 对以上5个聚集函数都可以如下使用： 对所有的行执行计算，指定ALL参数或不给参数（ALL是默认行为） 只包含不同的值，指定DISTINCT参数，distinct必须使用列名。 1select AVG(distinct lengthYear) as avg_lengthYear from tb_specialty; 运行结果： 12345+----------------+| avg_lengthYear |+----------------+| 3 |+----------------+ 可以看到，使用了distinct后，平均值明显上升。 组合聚集函数 select语句可根据需要包含多个聚集函数。 123456mysql&gt; select AVG(distinct lengthYear) as avg_lengthYear, -&gt; COUNT(lengthYear) as class_count, -&gt; MAX(lengthYear) as max_lengthYear, -&gt; MIN(lengthYear) as min_lengthYear, -&gt; SUM(lengthYear) as sum_lengthYear -&gt; from tb_specialty; 运行结果： 注意：在指定别名以包含某个聚集函数的结果时，不应该使用表中实际列名。 分组数据分组允许把数据分为多个逻辑组，以便能对每个组进行聚集计算。 创建分组 123select enterYear,COUNT(*) as nun_lengthYear from tb_specialty group by enterYear; 运行结果： 1234567+-----------+----------------+| enterYear | nun_lengthYear |+-----------+----------------+| 2005 | 3 || 2010 | 2 || 2011 | 1 |+-----------+----------------+ 错误的示例1： 1select enterYear,COUNT(*) as nun_lengthYear from tb_specialty; 运行结果： 12345+-----------+----------------+| enterYear | nun_lengthYear |+-----------+----------------+| 2005 | 6 |+-----------+----------------+ 结果是明显有问题的！！！！ 错误的示例2： 1select enterYear,lengthYear from tb_specialty group by enterYear; 运行结果： 1234567+-----------+------------+| enterYear | lengthYear |+-----------+------------+| 2005 | 2 || 2010 | 3 || 2011 | 3 |+-----------+------------+ 返回的是每个分组的第一个数据。 使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值。 123select enterYear,COUNT(*) as nun_lengthYear from tb_specialty group by enterYear with rollup; 运行结果： 12345678+-----------+----------------+| enterYear | nun_lengthYear |+-----------+----------------+| 2005 | 3 || 2010 | 2 || 2011 | 1 || NULL | 6 |+-----------+----------------+ GROUP BY子句使用，注意事项： GROUP BY 子句可以包含任意数目的列，使得对数据分组有更细致的控制。 如果在GROUP BY子句中嵌套了分组，数据将在最后规定的分组进行汇总。（在建立分组时，指定的所有列都一起计算，不能从个别列取回数据）。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（不可为聚集函数），不能使用别名。 除聚集计算语句外，select中的每个列都必须在GROUP BY子句中给出。 如果分组列中有NULL值（无论一行或多行），都将NULL作为一个分组返回。 GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前。 过滤分组 where过滤行，having过滤分组。 where在数据分组前进行过滤，having在数据分组后进行过滤。 1234select enterYear,COUNT(*) as nun_lengthYear from tb_specialty group by enterYear having count(*) &gt; 2; 运行结果： 12345+-----------+----------------+| enterYear | nun_lengthYear |+-----------+----------------+| 2005 | 3 |+-----------+----------------+ 分组和排序 ORDER BY GROUP BY 排序产生的输出 分组行。但输出可能不是分组的顺序。 任意列都可以使用（非选择的列也行） 只可能使用选择列或表达式列，而且必须使用每个选择列表达式 不一定需要 如果与聚集函数一起使用列（或表达式），则必须使用 为保证数据正确排序，一般在使用GROUP BY子句时，也应给出ORDER BY子句，且ORDER BY子句使用的列应为GROUP BY子句中的第一个列（或顺序列），否则会乱序。 select子句顺序 子句 说明 是否必须使用 select 要返回的列或表达式 是 from 从中检索数据的表 仅在从表选择数据时使用 where 行级过滤 否 group by 分组说明 仅在按组计算聚集时使用 having 组级过滤 否 order by 输出排序顺序 否 limit 要检索的行数 否 使用子查询查询（query），任何SQL语句都是查询。但此术语一般指select语句。 嵌套查询 子查询一般与IN操作符结合使用，也可使用等于（=）、不等于（&lt;&gt;）等。 123select name,enterYear from tb_specialty where id in (select id from tb_specialty where lengthYear &#x3D; 2); 运行结果： 1234567+--------------------+-----------+| name | enterYear |+--------------------+-----------+| 美术装潢设计 | 2005 || 数据结构 | 2010 || 遥感技术 | 2005 |+--------------------+-----------+ 下面的语句和上述查询的结果是一样的： 12select id from tb_specialty where lengthYear &#x3D; 2;select name,enterYear from tb_specialty where id in (1,4,5); 注意：不建议多层嵌套，影响效率。 利用子查询进行过滤，就如上面的嵌套查询 作为计算字段使用子查询（具体示例见《MySQL必知必会》p94） 相关子查询（correlated subquery），涉及外部查询的子查询。 联结表 主键（primary key），一列（或一组列），其值能够唯一区分表中每个行。 外键（foreign key），外键为某个表中的一列，它包含另一个表的主键值，定义了两个表之间的关系。 可伸缩性（scale），能够适应不断增加的工作量而不失败。设计良好的数据库或应用程序称之为可伸缩性好（scale well）。 联结，联结是一种机制，用来在一条select语句中关联表，因此称之为联结。使用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。联结不是物理实体，它在实际的数据库表中不存在。 创建联结 123mysql&gt; select students.name as name,students.age as age,teac_name as teacher,sex as teac_sex -&gt; from students,teachers -&gt; where main_teacher &#x3D; teac_name; 运行结果： 123456+--------+-----+-----------+----------+| name | age | teacher | teac_sex |+--------+-----+-----------+----------+| 张宇 | 7 | 汪子颜 | 女 || 小明 | 6 | 刘诗诗 | 女 |+--------+-----+-----------+----------+ 在联结两个表时，你实际上做的是将第一个表中的每一行与第二个表中的每一行配对。 where子句作为过滤条件，它只包含那些匹配给定条件的行。 没有where子句，第一个表中的每个行将与第二个表中的每个行配对，而不管它们逻辑上是否可以配在一起。 12mysql&gt; select students.name as name,students.age as age,teac_name as teacher,sex as teac_sex -&gt; from students,teachers; 运行结果： 12345678910+--------+-----+-----------+----------+| name | age | teacher | teac_sex |+--------+-----+-----------+----------+| 张宇 | 7 | 汪子颜 | 女 || 小明 | 6 | 汪子颜 | 女 || 张宇 | 7 | 张帅 | 男 || 小明 | 6 | 张帅 | 男 || 张宇 | 7 | 刘诗诗 | 女 || 小明 | 6 | 刘诗诗 | 女 |+--------+-----+-----------+----------+ PS：匹配的结果很好玩，似乎是以第二张表的记录为主去匹配第一张表的各条记录，具体过程我也不清楚，后面再说吧。 笛卡儿积（cartesian product），由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行数是两个表行数之积。例如上一个例子，就是笛卡儿积的应用。 应该保证所有联结都有where子句，还应保证where子句的正确性，这样才能保证MySQL返回我们想要的数据。 返回笛卡儿积的联结称为叉联结。 内部联结，也称等值联结，它是基于两个表之间的相等测试。 123mysql&gt; select students.name as name,students.age as age,teac_name as teacher,sex as teac_sex -&gt; from students inner join teachers -&gt; on main_teacher &#x3D; teac_name; 运行结果： 123456+--------+-----+-----------+----------+| name | age | teacher | teac_sex |+--------+-----+-----------+----------+| 张宇 | 7 | 汪子颜 | 女 || 小明 | 6 | 刘诗诗 | 女 |+--------+-----+-----------+----------+ 此语句的运行结果与前面创建联结中示例的结果是一样的，select语句相同、from子句不同。以inner join指定两个表之间的关系，特定的on子句进行条件限制，此处的on子句作用与where子句相同。 注意：联结时，首选inner join语法，这样不仅确保不会忘记联结条件，有时还会更高效。 多表联结 视情况而定，联结的表越多，性能下降越厉害。 创建高级联结 使用表别名 123mysql&gt; select s.name as name,s.age as age,teac_name as teacher,sex as teac_sex -&gt; from students as s,teachers as t -&gt; where s.main_teacher &#x3D; t.teac_name; 运行结果： 123456+--------+-----+-----------+----------+| name | age | teacher | teac_sex |+--------+-----+-----------+----------+| 张宇 | 7 | 汪子颜 | 女 || 小明 | 6 | 刘诗诗 | 女 |+--------+-----+-----------+----------+ 注意： 表使用了别名后，select语句要使用表的别名（或者不用），不能直接使用原来的名字，这是因为select语句在最后一步执行。 表别名只在查询执行中使用。与列别名不同，表别名不返回客户机。 自联结：与表自身进行联结 自然联结：所有的内部联结都是自然联结 外部联结：分为左外部联结和右外部联结 左外部联结： 123mysql&gt; select * -&gt; from students left outer join teachers -&gt; on main_teacher &#x3D; teac_name; 运行结果： 123456+----+--------+-----+--------------+---------+-----------+------+------+| id | name | age | main_teacher | teac_id | teac_name | age | sex |+----+--------+-----+--------------+---------+-----------+------+------+| 1 | 张宇 | 7 | 汪子颜 | 1 | 汪子颜 | 22 | 女 || 2 | 小明 | 6 | 刘诗诗 | 3 | 刘诗诗 | 20 | 女 |+----+--------+-----+--------------+---------+-----------+------+------+ 右外部联结： 123mysql&gt; select * -&gt; from students right outer join teachers -&gt; on main_teacher &#x3D; teac_name; 运行结果： 1234567+------+--------+------+--------------+---------+-----------+-----+-----+| id | name | age | main_teacher | teac_id | teac_name | age | sex |+------+--------+------+--------------+---------+-----------+-----+-----+| 1 | 张宇 | 7 | 汪子颜 | 1 | 汪子颜 | 22 | 女 || 2 | 小明 | 6 | 刘诗诗 | 3 | 刘诗诗 | 20 | 女 || NULL | NULL | NULL | NULL | 2 | 张帅 | 26 | 男 |+------+--------+------+--------------+---------+-----------+-----+-----+ 我们可以看到，左联结会保留左边表的所有数据，右联结会保留右边表的所有数据，没有匹配项则填NULL。 带聚集函数的联结 聚集函数是在select语句中做操作，而联结是在from子句中做操作。 组合查询MySQL允许执行多个查询（多条select语句），并将结果作为单个查询结果集返回。这些组合通常称为并（union）或复合查询（compound query）。 12345mysql&gt; select name,age -&gt; from students -&gt; union -&gt; select teac_name,age -&gt; from teachers; 运行结果： 123456789+-----------+-----+| name | age |+-----------+-----+| 张宇 | 7 || 小明 | 6 || 汪子颜 | 22 || 张帅 | 26 || 刘诗诗 | 20 |+-----------+-----+ 我们可以看到，union将两条查询结果合并在了一起，并以第一条查询语句的select中的字段作为表头。 UNION规则： union必须由两条或两条以上的select语句组成，语句之间用关键字union分隔。 union中的每个查询必须包含相同的列、表达式或聚集函数，次序也应一致 列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型。 注意：union从查询结果集中除去了重复的行，这是默认行为。若想返回所有匹配的行，可以使用UNION ALL。 全文本搜索并非所有的引擎都支持全文本搜索，例如InnoDB就不支持，但MyISAM支持全文本搜索。 启用全文本搜索支持。一般在建表时启用全文本搜索，在CREATE语句中接受fulltext子句，它给出被索引列的一个逗号分隔的列表。 123456789mysql&gt; create table productnotes -&gt; ( -&gt; note_id int not null auto_increment, -&gt; prod_id char(10) not null, -&gt; note_date datetime not null, -&gt; note_text text null, -&gt; primary key(note_id), -&gt; fulltext(note_text) -&gt; )engine&#x3D;MyISAM; 可以在建表时启用，也可在稍后指定（此时已有数据必须建立索引）。 注意：不要在数据导入时使用fulltext，会花费大量时间，降低效率。 进行全文本搜索。使用match()和against()函数，match()指定被搜索的列，against()指定要使用的搜索表达式。 123select note_textfrom productnoteswhere match(note_text) against(&#39;rabbit&#39;); 全文本搜索的一个重要部分就是对结果排序，具有较高等级的行先返回。 使用查询扩展 简单全文搜索 123select note_textfrom productnoteswhere match(note_text) against(&#39;baby&#39;); 带有查询扩展的全文搜索 123select note_textfrom productnoteswhere match(note_text) against(&#39;rabbit&#39; with query expansion); 简单查询返回了1条数据，而查询扩展返回了7条数据。关键字with query expansion，扩展查询的结果并不一定与查询的字符串完全相同，但一定会相关。 即使没有fulltext索引，也可以使用布尔方式的全文本搜索。但该操作非常缓慢。 123select note_textfrom productnoteswhere match(note_text) against(&#39;rabbit&#39; in boolean mode); 全文本布尔操作符不在此做过多赘述。 全文本搜索的使用说明 在索引全文本数据时，短词（3个或3个以下字符的词）会被忽略且从索引中排除。字符串长度可更改。 MySQL带有一个内建的非用词（stopword）列表，这些词在索引全文本数据时总是被忽略。列表可被覆盖。 如果一个词出现在50%以上的行中，则将它作为非用词忽略。（不适用与in boolean mode）。 若表中的行数少于3行，则全文本搜索不返回结果。 忽略词中的单引号。如don’t索引为dont。 不具有词分隔符的语言（日语和汉语），不能恰当地返回全文本搜索的结果。 仅在MyISAM数据库引擎中支持全文本搜索。 插入数据插入数据，使用INSERT语句。 12345678910111213141516171819mysql&gt; insert into customers -&gt; ( -&gt; cust_address, -&gt; cust_city, -&gt; cust_country, -&gt; cust_email -&gt; ) -&gt; values -&gt; (&#39;紫云路&#39;, -&gt; &#39;上海&#39;, -&gt; &#39;CHINA&#39;, -&gt; &#39;yys@qq.com&#39; -&gt; ), -&gt; ( -&gt; &#39;西藏路&#39;, -&gt; &#39;北京&#39;, -&gt; &#39;CHINA&#39;, -&gt; &#39;1212@163.com&#39; -&gt; ); 插入数据后的表： 在插入数据时， 如若不在表名后给出列名，则需按照数据库表中列的定义次序给出相应的数据； 给出列名后，无需理会表中列的定义次序，按照自己给的列名插入相应数据即可，该方法虽繁琐，但却安全，可以很好适应表结构的变动。 在插入多条记录时，用逗号分隔。（如示例） 可以在insert和into之间添加关键字LOW_PRIORITY，以此来降低该insert语句的优先级。对于侧重于数据检索的数据库，整体性能会有较大提升。 单条insert语句处理多个插入比使用多条insert语句快。 插入检索出的数据时，可以使用所谓的INSERT SELECT语句（注意用法）。 123mysql&gt; insert into newcustomers -&gt; (cust_address,cust_city,cust_email) -&gt; select cust_address,cust_city,cust_email from customers; 插入数据后的表： 123456+---------+--------------+--------------+--------------+-----------+| cust_id | cust_address | cust_country | cust_email | cust_city |+---------+--------------+--------------+--------------+-----------+| 1 | 紫云路 | NULL | yys@qq.com | 上海 || 2 | 西藏路 | NULL | 1212@163.com | 北京 |+---------+--------------+--------------+--------------+-----------+ 更新和删除数据 更新数据，使用UPDATE语句。不要省略where子句！！！！ 两种更新方式： 更新表中特定行 更新表中所有行（不建议，一定要小心） 更新时，若不进行限定，则会更新整个表。 1234mysql&gt; update newcustomers -&gt; set cust_email &#x3D; &#39;alex@163.com&#39;, -&gt; cust_country &#x3D; &#39;CHINA&#39; -&gt; where cust_email &#x3D; &#39;alex@qq.com&#39;; 更新结果： 123456+---------+--------------+--------------+--------------+-----------+| cust_id | cust_address | cust_country | cust_email | cust_city |+---------+--------------+--------------+--------------+-----------+| 1 | 紫云路 | NULL | yys@qq.com | 上海 || 2 | 西藏路 | CHINA | alex@163.com | 北京 |+---------+--------------+--------------+--------------+-----------+ IGNORE关键字，在UPDATE语句中使用了之后，即使在更新的过程中发生了错误也继续进行更新。 1UPDATE IGNORE customers…… 删除数据，使用DELETE语句。不要省略where子句！！！！ 两种删除方式： 删除表中特定行 删除表中所有行（不建议，一定要小心） 删除时，若不进行限定，则会删除整个表。 12mysql&gt; delete from newcustomers -&gt; where cust_id &#x3D; 1; 删除数据后的表： 12345+---------+--------------+--------------+--------------+-----------+| cust_id | cust_address | cust_country | cust_email | cust_city |+---------+--------------+--------------+--------------+-----------+| 2 | 西藏路 | CHINA | alex@163.com | 北京 |+---------+--------------+--------------+--------------+-----------+ 如果想从表中删除所有行，不要使用delete。可以使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快。truncate实际上是删除了原表并重新创建一个表，而非逐行删除表中数据。 更新和删除的指导原则 除非确实打算更新或删除每一行，否则绝对不要使用不带where子句的update或delete语句。 保证每个表都有主键。 在对update或delete语句使用where子句前，应先用select进行测试，保证它过滤的是正确的记录，以防编写的子句不正确。 使用强制实施引用完整性的数据库。 MySQL没有撤销（undo）按钮，一定要极其小心使用update、delete语句。 创建和操作表 表的创建 新表的名字，在关键字create table之后给出 表列的名字和定义，用逗号分隔。 1234567891011mysql&gt; create table customers -&gt; ( -&gt; cust_id int NOT NULL AUTO_INCREMENT, -&gt; cust_name char(50) NOT NULL, -&gt; cust_address char(50) NULL, -&gt; cust_city char(50) NULL, -&gt; cust_country char(50) NULL, -&gt; cust_contact char(50) NULL, -&gt; cust_email char(50) NULL, -&gt; PRIMARY KEY (cust_id) -&gt; )ENGINE&#x3D;InnoDB; NULL值、主键和AUTO_INCREMENT NULL值就是没有值或缺值。不要把NULL值与空串相混淆，NULL值是没有值，而空串（’’）是个有效的值，它不是无值。 主键值必须唯一。主键是一个或多个列构成，使用PRIMARY KEY ()指定。可以在创建表时定义，也可以在创建表之后定义。 123456789mysql&gt; create table orderitems -&gt; ( -&gt; order_num int not null, -&gt; order_item int not null, -&gt; prod_id char(10)not null, -&gt; quantity int not null, -&gt; item_price decimal(8,2) not null, -&gt; primary key (order_num,order_item) -&gt; )engine&#x3D;InnoDB; AUTO_INCREMENT，本列每当增加一行时自动增量。 每个表只允许一个AUTO_INCREMENT列，而且它必须被索引（如使其成为主键）。 可以通过last_insert_id()函数获得最后一个AUTO_INCREMENT值。 指定默认值、引擎类型 默认值用create table语句的列定义中的default关键字指定。MySQL只允许常量作为默认值。 123456789mysql&gt; create table orderitems -&gt; ( -&gt; order_num int not null, -&gt; order_item int not null, -&gt; prod_id char(10)not null, -&gt; quantity int not null default 1, -&gt; item_price decimal(8,2) not null, -&gt; primary key (order_num,order_item) -&gt; )engine&#x3D;InnoDB; 引擎用于管理和处理数据。 常见的引擎： InnoDB是一个可靠的事务处理引擎，它不支持全文本搜索。 MyISAM是一个性能极高的引擎，它支持全文本搜索，但不支持事务处理。 MEMORY在功能等同于MyISAM，但由于数据存储在内存（不是磁盘）中，速度很快（适用于临时表）。 注意：虽然引擎类型可以混用，但外键不能跨引擎。 更新表 为更新表定义，可使用ALTER TABLE语句。除非必要，否则不建议更新表。 在ALTER TABLE之后给出要更改的表名（该表必须存在，否则报错） 所做更改的列表 12mysql&gt; alter table customers -&gt; add cust_state char(5) not null; 12mysql&gt; alter table customers -&gt; drop column cust_state; 12&#x2F;&#x2F; 修改表列名alter table customers change column cust_state new_state char(5) null; 删除表 删除表，使用DROP TABLE语句即可。 1drop table stu; 删除表没有确认，也不能撤销，执行这条语句将永久删除该表。 重命名表 使用REMANE TABLE语句可以重命名一个表。 12mysql&gt; rename table stu to students, -&gt; teacher to teachers; 使用视图视图，是虚拟的表，建立在实体表之上。视图不包含表中的任何列或数据，它包含的是一个SQL查询。 视图的优点： 重用SQL语句。 简化复杂的SQL操作。 使用表的组成部分而不是整个表。 保护数据。 更改数据格式和表示。 视图的规则和限制： 与表一样，视图必须唯一命名（表、视图的名字都是唯一的）。 对于可以创建的视图数目没有限制。 为了创建视图，必须具有足够的访问权限，通常由数据库管理员授权。 视图可以嵌套。 order by可以用在视图中，但如果从该视图检索数据的select语句中也含有order by子句，那么视图中的order by将会被覆盖。 视图不能索引，也不能有关联的触发器或默认值。 视图可以与表一起使用。 视图的创建 视图用create view语句来创建。 使用show create view viewname;来查看创建视图的语句。 使用DROP删除视图。 更新视图，既可以先DROP再CREATE，也可以直接用CREATE OR REPLACE VIEW。对于后者，若要更新的视图不存在，则会创建一个新视图；否则，替换原有视图 123mysql&gt; CREATE OR REPLACE -&gt; VIEW specialty -&gt; as select name,lengthYear from tb_specialty; mysql&gt; create view specialty as -&gt; select name,lengthYear -&gt; from tb_specialty -&gt; where lengthYear &gt; 1; 123&#96;&#96;&#96;mysqlselect name,lengthYear from specialty where lengthYear &#x3D; 2; 运行结果： 1234567+--------------------+------------+| name | lengthYear |+--------------------+------------+| 美术装潢设计 | 2 || 数据结构 | 2 || 遥感技术 | 2 |+--------------------+------------+ 在MySQL处理上述查询语句时，它将指定的where语句添加到视图查询中的已有的where子句中，以便正确过滤数据。也极大简化了复杂SQL语句的使用。 对表的大多操作都可以实施到视图上来。 如果视图定义中有以下操作，则不能进行视图的更新： 分组（group by 和having） 联结 子查询 并 聚集函数（MIN()、COUNT()等） DISTINCT 导出（计算）列 视图主要用于检索（select）而非更新（insert、update、delete）。 高级应用使用存储过程存储过程，简单地来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件，但它的作用远不止于此。 存储过程的三大好处：简单、安全、高性能。 存储过程的创建 12345678910create procedure ordertotal( in onumber int, out ototal decimal(8,2))begin select Sum(item_price*quantity) from orderitems where order_num &#x3D; onumber into ototal;end; 存储过程的创建和Java中方法的创建很类似，方法名后跟参数，然后是方法体。 但存储过程的参数分三类，输入参数（in）、输出参数（out）、无参数。 begin和end语句用于限定存储过程体。 注意：存储过程中的注释，在内容前面放置--即可。单行注释。 mysql 命令行实用程序使用;作为分隔符，若存储过程自身内有;字符，则会在解释时报错。解决方法： 1234567891011121314delimiter &#x2F;&#x2F;create procedure ordertotal( in onumber int, out ototal decimal(8,2))begin select Sum(item_price*quantity) from orderitems where order_num &#x3D; onumber into ototal;end; &#x2F;&#x2F;delimiter; 其中，delimiter //告诉命令行实用程序使用//作为新的语句结束分隔符，而标志存储过程结束的end也被定义为end //，最后的delimiter;的作用是回复原来的语句分隔符。 除\\符号外，任何字符都可以作为语句分隔符。 执行存储过程 MySQL称存储过程的执行为调用，使用call关键字。 调用存储过程： 1call ordertotal(2005,@total); 显示结果： 1select @total; 调用存储过程时返回的参数名（即@后面的内容）可以自定义。 删除存储过程 1drop procedure ordertotal; 注意：删除时，只需给出存储过程名即可，无需添加()。 如果要删除的存储过程不存在，则上述语句便会报错。 最好使用下述语句： 1drop procedure if exist; 检查存储过程 其实就是显示存储过程的创建语句、时间、创建者等详细信息。 1show create procedure ordertotal; 使用游标游标（cursor），是一个存储在MySQL服务器上的数据库查询，他不是一条select语句，而是被该语句检索出来的结果集。游标主要用于交互式应用，其中用户需滚动屏幕上的数据，并对数据进行浏览或做出更改。 MySQL游标只能用于存储过程和函数。 创建游标，使用declare关键字。 123456create procedure processorder()begin declare ordernumbers cursor for select order_num from orders;end 打开和关闭游标 使用open打开游标 1open ordernumbers; 使用close关闭游标 1close ordernumbers 使用游标数据 在一个游标被打开后，可以使用fetch语句访问它的每一行。fetch指定检索什么数据（哪一列），检索出来的数据存储在什么地方。它还向前移动游标中的内部行指针，使下一条fetch语句检索下一行。 123456789101112131415161718192021222324252627282930create procedure processorder()begin -- 定义局部变量 declare done boolean default 0; declare o int; -- 定义游标 declare ordernumbers cursor for select order_num from orders; -- 定义continue handler declare continue handler for SQLSTATE &#39;02000&#39; set done&#x3D;1; -- 打开游标 open ordernumbers; -- 在此处定义自己需要的操作 -- 循环所有行 repeat -- 获取数据，存入中间变量o fetch ordernumbers into o; -- 结束循环 until done end repeat; -- 关闭游标 close ordernumbers; end declare语句的发布存在特定的次序：局部变量 &gt; 游标 &gt; 句柄。 continue handler，在条件出现时执行的代码。在这里，当SQLSTATE ‘02000’出现时，set done=1。 repeat用于定义循环，until done end repeat;用于控制循环结束，当done的值为1时，循环结束。 使用触发器 触发器用create trigger语句创建。 12create trigger newproduct after insert on productsfor each row select &#39;product add&#39;; 创建了名为newproduct的触发器，在insert语句成功执行后执行。for each row，对每个插入行执行，每成功插入，都会显示’product add’。 注意： 每个数据库的触发器名应唯一。 触发器按每个表每个事件每次地定义，每个表每个事件每次只允许一个触发器。故，每个表最多支持6个触发器（insert、update、delete的之前和之后）。单一触发器不能与多个事件或多个表关联。 删除触发器用drop trigger语句。 1drop trigger newproduc; 注意：触发器不能被更新或覆盖。所以想要修改触发器，只能先删除再重建。 触发器 insert触发器 在insert触发器代码内，可引用一个名为new的虚拟表，访问被插入的行 在before insert触发器中，new中的值可以被更新 delete触发器 在delete触发器代码内，可引用一个名为old的虚拟表，访问被删除的行 old中的值全部都是只读的，不能更新 update触发器 在update触发器代码中，可引用一个名为old的虚拟表访问以前的值，引用一个名为new的虚拟表访问新更新的值 在before update触发器中，new中的值可以被更新 old中的值全都是只读，不能更新 通常，before用于数据验证或净化（目的是保证插入表中的数据确实是需要的数据），适用于insert、update触发器。 123456create trigger deleteorder before delete on ordersfor each rowbegin insert into archive_orders(order_num,order_date,cust_id) values(old.order_num,old.order_date,old.cust_id);end; 管理事务处理事务处理（transaction processing）可以用来维护数据库的完整性，它保证成批的MySQL操作要么完全执行，要么完全不执行。 术语： 事务（transaction），指一组SQL语句。 回退（rollback），指撤销指定SQL语句的过程。 提交（commit），指将未存储的SQL语句结果写入数据库表。 保留点（savepoint），指事务处理中设置的临时占位符（placeholder），你可以对他发布回退（与回退整个事务处理不同）。 MySQL使用如下的语句来标志事务的开始： 1start transaction; rollback 123456789101112-- 查看students表select * from students;-- 开始事务start transaction;-- 删除表中记录delete from students;-- 确认删除成功select * from students;-- 事务回退rollback;-- 查看表中记录，恢复如初select * from students; 上述操作都是一条一条执行的。 显然，rollback只能在一个事务处理内使用（即在start transaction;语句之后）。 事务处理用来管理insert、update、delete语句，故可以回退。但select、create、drop都不能进行回退操作。 commit 一般的SQL语句都是直接针对数据库表执行和编写的。这就是隐含提交（implicit commit），即提交操作是自动进行的。 但是在事务处理块中，提交不会隐含地进行，为进行明确的提交，需要使用commit语句。 1234start transaction;delete from students;select * from students;commit; 注意：当commit或rollback语句执行后，事务会自动关闭（也称隐含事务关闭）。 保留点 应用于事务处理时的部分提交或回退。 创建保留点 1savepoint delete1; 回退到保留点 1rollback to delete1; 注意： 保留点越多越好 保留点在事务处理完成后会自动释放，也可使用release savepoint明确释放保留点。 更改默认的提交行为 针对一般SQL语句，默认是自动提交的，但也可更改。 修改MySQL不自动提交更改： 1set autocommit&#x3D;0; 注意：autocommit标志是针对每个连接而非服务器。 全球化和本地化 字符集和校对顺序 术语： 字符集，字母和符号的集合。 编码，某个字符集成员的内部表示。 校对，规定字符如何比较的指令。 查看所支持的字符集： 1show character set; 查看所支持的校对： 1show collation; 安全管理 管理用户 mysql数据库有一个名为user的表，它包含所有的用户账号。 创建用户 1create user test identified by &#39;password&#39;; 有时会报错“ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement”，使用以下语句即可： 1flush privileges; 该语句的作用是刷新权限表。 重命名用户账号 1rename user test to yang; 删除用户账号 1drop user yang; 设置访问权限 查看权限 1show grants for test; 运行结果： 12345+----------------------------------+| Grants for test@% |+----------------------------------+| GRANT USAGE ON *.* TO &#39;test&#39;@&#39;%&#39; |+----------------------------------+ usage表示根本没有权限。 授权 1grant select on students.* to test; 运行结果： 123456+--------------------------------------------+| Grants for test@% |+--------------------------------------------+| GRANT USAGE ON *.* TO &#39;test&#39;@&#39;%&#39; || GRANT SELECT ON &#96;students&#96;.* TO &#39;test&#39;@&#39;%&#39; |+--------------------------------------------+ 撤销权限 1revoke select on students.* from test; 运行结果： 12345+----------------------------------+| Grants for test@% |+----------------------------------+| GRANT USAGE ON *.* TO &#39;test&#39;@&#39;%&#39; |+----------------------------------+ 更改口令（登录密码） 1set password for test &#x3D; password(&#39;new_password&#39;); 在不指定用户名时，set password更新当前登录用户的口令。 数据库维护 备份数据 mysqldump，转储所有数据库内容到某个外部文件。 mysqlhotcopy，从一个数据库复制所有数据。 可以使用MySQL的backup table或select into outfile转储所有数据到某个外部文件。数据复原可以用restore table。 数据库维护 analyze table，用来检查表键是否正确。 1analyze table students; 运行结果： 12345+-----------------+---------+----------+----------+| Table | Op | Msg_type | Msg_text |+-----------------+---------+----------+----------+| testdb.students | analyze | status | OK |+-----------------+---------+----------+----------+ check table，用来针对许多问题对表进行检查。 1check table student; 运行结果： 12345+-----------------+-------+----------+----------+| Table | Op | Msg_type | Msg_text |+-----------------+-------+----------+----------+| testdb.students | check | status | OK |+-----------------+-------+----------+----------+ 如果MyISAM表访问产生不正确和不一致的结果，可能需要使用repair table来修复相应的表。不常用，若经常使用则表示存在更大的问题。 删除大量表中数据，使用optimize table来回收所用的空间，从而优化表的性能。 日志文件在MySQL安装目录的data文件夹下。 改善性能 使用explain语句让MySQL解释它将如何执行一条select语句。 1explain select * from students; 运行结果： 一般来说，存储过程执行得比一条一条执行其中的各条MySQL语句快。 坚决不用select *语句。 在导入数据时，应关闭自动提交。 必须索引数据库表以改善数据检索的性能。 like很慢。 OVER","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/tags/MySQL/"}],"author":"Alexander"},{"title":"Java学习Day04","slug":"Java学习Day04","date":"2019-07-25T07:58:29.000Z","updated":"2019-07-26T05:37:42.148Z","comments":true,"path":"2019/07/25/Java学习Day04/","link":"","permalink":"https://born2do.github.io/2019/07/25/Java%E5%AD%A6%E4%B9%A0Day04/","excerpt":"","text":"第六章 接口、lambda表达式与内部类6.1接口 接口是Java中最重要的概念，可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。 接口的格式： 1234interface interfaceName &#123; 全局常量 公共抽象方法&#125; 接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的。 接口被子类继承，子类（如果不是抽象类）必须重写接口中的所有抽象方法。 一个子类可以同时继承抽象类和实现接口 一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承。 允许声明接口的变量，但该接口变量必须引用实现了该接口的类对象。 接口里定义的变量自动是public static final 的，也即接口内只能定义常量。 接口内不能包含实例域或静态方法。 解决默认方法冲突。 如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了一个同样的方法，结果会是怎样？ 规则如下： 1）超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法（接口中的默认方法）会被忽略。 2）接口冲突。如果一个超接口提供了一个默认方法，另一个接口提供了同名而且参数类型（无论是否为默认参数）相同的方法，必须在实现类中覆盖这个方法来解决冲突。 回调（callback）是一种常见的程序设计模式。在这种模式中，可以指定某个特定事件发生时该采取的动作。 6.2lambda表达式 基本语法: 123(parameters) -&gt; expression或(parameters) -&gt;&#123; statements; &#125; 虽然看着很先进，其实Lambda表达式的本质只是一个”语法糖”，由编译器推断并帮你转换包装为常规的代码，因此你可以使用更少的代码来实现同样的功能。但建议不要乱用，因为这就和某些很高级的黑客写的代码一样，简洁、难懂、难以调试，维护人员想骂娘。 6.3内部类内部类（inner class）是定义在另一个类中的类。 6.4代理","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"},{"name":"内部类","slug":"内部类","permalink":"https://born2do.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"接口","slug":"接口","permalink":"https://born2do.github.io/tags/%E6%8E%A5%E5%8F%A3/"}],"author":"Alexander"},{"title":"Java学习Day03","slug":"Java学习Day03","date":"2019-07-16T03:05:30.000Z","updated":"2021-05-13T14:30:21.811Z","comments":true,"path":"2019/07/16/Java学习Day03/","link":"","permalink":"https://born2do.github.io/2019/07/16/Java%E5%AD%A6%E4%B9%A0Day03/","excerpt":"","text":"第5章 继承5.1 类、超类和子类 关键字extends表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类（superclass）、基类（base class）或父类（parent class）。 派生出来的新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。 覆盖，overriding，也称重写。 发生在继承中，子类重写超类的方法，方法名、参数列表、返回值类型全部要求相同。被重写的方法，不能比超类的访问权限更严格。 注意：要与重载区分开来 子类构造器 使用super调用构造器的语句必须是子类构造器的第一条语句。 如果子类构造器没有显式调用超类的构造器，则将自动调用超类默认（没有参数）的构造器。如果超类没有无参的构造器，子类也没有调用超类的其它构造器，则Java编译器会报错。 一个对象变量可以指示多种实际类型的现象被称为多态。在运行时能够自动选择调用哪个方法的现象称为动态绑定。 继承层次 由一个公共超类派生出来的所有类的集合被称为继承层次。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链。 总结 继承的基本概念 ​ 扩展父类的功能 Java中使用extends关键字完成继承 格式： ​ class 子类 extends 父类 { } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Person&#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void say()&#123; System.out.println(&quot;姓名：&quot;+this.getName()+&quot; 年龄：&quot;+this.getAge()); &#125; &#125;class Student extends Person&#123; private int score; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public void show ()&#123; System.out.println(&quot;成绩：&quot;+this.getScore()); &#125; &#125;public class ExtendsDemo01 &#123; public static void main(String[] args) &#123; Student s = new Student(); s.setName(&quot;张三&quot;); s.setAge(20); s.setScore(99); s.say(); s.show(); &#125;&#125; 继承的限制 在Java中只允许单继承 子类不能直接访问父类的私有成员变量 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class People &#123; private int age; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; private void say() &#123; System.out.println(&quot;I&#x27;am a father&quot;); &#125; &#125;class Worker extends People &#123; //虽不可对父类的私有成员直接访问，但可以通过其他方式进行访问，如set()和get()方法 //子类实质上是继承了父类的所有成员变量（包括私有成员变量），但私有方法并没有继承 public void tell() &#123; System.out.println(&quot;I&#x27;am a worker,I&#x27;am &quot;+getAge()); &#125;&#125;class PetWorker extends Worker &#123; //只允许单继承，不允许多继承，但可以多层继承 public void tell() &#123; System.out.println(&quot;I&#x27;am a petworker,I&#x27;am &quot;+getAge()); &#125;&#125;public class ExtendsDemo02 &#123; public static void main(String[] args) &#123; Worker wor = new Worker(); wor.setAge(30); wor.tell();// wor.say(); //私有方法没有继承，无法使用，报错 PetWorker petWor = new PetWorker(); petWor.setAge(45); petWor.tell(); &#125;&#125;//运行结果：//I&#x27;am a worker,I&#x27;am 30//I&#x27;am a petworker,I&#x27;am 45 子类对象实例化过程 在子类对象实例化时，必须先调用父类中的构造方法，之后调用子类构造方法。 1234567891011121314151617181920212223class Father &#123; public Father()&#123; System.out.println(&quot;调用父类构造方法&quot;); &#125;&#125;class Son extends Father&#123; public Son() &#123; System.out.println(&quot;调用子类构造方法&quot;); &#125;&#125;public class ExtendsDemo03 &#123; public static void main(String[] args) &#123; Son son = new Son(); &#125;&#125;//运行结果：//调用父类构造方法//调用子类构造方法 方法重写与super关键字 重写 在继承中，也存在着“重写”的概念，其实就是子类定义了和父类同名的方法。 定义： ​ 方法名称相同，返回值类型相同，参数也相同。 限制：被子类重写的方法不能拥有比父类方法更加严格的访问权限 访问权限：private&lt;default&lt;public 四种修饰符的访问权限范围： 权限 类内 同包 不同包子类 不同包非子类 private √ × × × default √ √ × × protected √ √ √ × public √ √ √ √ 1234567891011121314151617181920212223class A &#123; public void tell() &#123; System.out.println(&quot;我是tell方法&quot;); &#125;&#125;class B extends A &#123; public void tell() &#123; //方法名称相同，返回值类型相同，参数也相同。 super.tell(); //强行调用父类的方法执行 System.out.println(&quot;我重写了tell方法&quot;); &#125;&#125;public class ExtendsDemo04 &#123; public static void main(String[] args) &#123; B b = new B(); b.tell(); &#125;&#125;//运行结果：//我是tell方法//我重写了tell方法 super关键字 强行调用父类的方法执行 super也可以表示那些方法是从父类中继承而来的 多态性 Java面型对象多态性 多态性的体现： 方法的重载和重写 对象的多态性 对象的多态性： 向上转型：程序自动完成 父类 父类对象 = 子类实例 向下转型：强制类型转换 子类 子类对象 = (子类)父类实例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class A &#123; public void tell1() &#123; System.out.println(&quot;A--tell1&quot;); &#125; public void tell2() &#123; System.out.println(&quot;A--tell2&quot;); &#125;&#125;class B extends A &#123; public void tell1() &#123; System.out.println(&quot;B--tell1&quot;); &#125; public void tell3() &#123; System.out.println(&quot;B--tell3&quot;); &#125;&#125;public class PolDemo01 &#123; public static void main(String[] args) &#123;// 向上转型// B b = new B();// A a = b;// a.tell1(); //B重写了A的tell1方法，打印结果为 B--tell1// a.tell2(); //打印结果为 A--tell2 // 向下转型// A a = new A(); //a 和 b 没有明确关系，无法转型// B b = (B)a; //运行出错// 向下转型前，一定会有向上转型 A a = new B(); B b = (B)a; b.tell1(); b.tell2(); b.tell3(); &#125;&#125;//运行结果：//B--tell1//A--tell2//B--tell3 多态性的应用 1234567891011121314151617181920212223242526272829303132class A1 &#123; public void tell1() &#123; System.out.println(&quot;tell1&quot;); &#125;&#125;class B1 extends A1 &#123; public void tell2() &#123; System.out.println(&quot;tell2&quot;); &#125;&#125;class C1 extends A1 &#123; public void tell3() &#123; System.out.println(&quot;tell3&quot;); &#125;&#125;public class PolDemo02 &#123; public static void main(String[] args) &#123; say(new B1()); say(new C1()); &#125; public static void say(A1 a) &#123; a.tell1(); &#125;&#125;//运行结果：//tell1//tell1 抽象类与接口 final关键字的使用 final关键字在Java中被称为完结器，表示最终的意思。 final能声明类、方法、属性 使用final声明的类不能被继承 使用final声明的方法不能被重写 使用final声明的变量变成常量，常量是不可以被修改的。被修饰的变量名称应全部大写。 抽象类 抽象类概念：包含一个抽象方法的类就是抽象类。 抽象方法：声明而未被实现的方法，抽象方法必须使用abstract关键字声明。 抽象类被子类继承，子类（如果不是抽象类）必须重写抽象类中的所有抽象方法。 定义格式： 12345678//抽象类abstract class className &#123; 属性 方法 //抽象方法,用abstract修饰，在“()”后直接加上“;” //eg: //public abstract void say();&#125; 抽象类不能直接实例化，要通过其子类进行实例化。 12345678910111213141516171819202122232425262728293031323334//抽象类abstract class Abs &#123; private int age; public void say() &#123; &#125;//抽象方法 public abstract void print(); public abstract void tell();&#125;class AbsSon extends Abs &#123; //重写抽象类中的所有抽象方法 public void print() &#123; &#125; public void tell() &#123; &#125;&#125;public class AbsDemo &#123; public static void main(String[] args) &#123;// 抽象类不能直接被实例化，要通过其子类进行实例化// Abs abs = new Abs(); AbsSon abs = new AbsSon(); abs.say(); abs.print(); abs.tell(); &#125;&#125; 接口的实现 接口是Java中最重要的概念，可以理解为一种特殊的类，里面全部是由全局常量和公共的抽象方法所组成。 接口的格式： 1234interface interfaceName &#123; 全局常量 公共抽象方法&#125; 接口的实现也必须通过子类，使用关键字implements，而且接口是可以多实现的。 接口被子类继承，子类（如果不是抽象类）必须重写接口中的所有抽象方法。 一个子类可以同时继承抽象类和实现接口 一个接口不能继承一个抽象类，但是却可以通过extends关键字同时继承多个接口，实现接口的多继承。 123456789101112131415161718192021222324252627282930313233343536373839//接口interface Inter1 &#123; public static final int AGE = 20; public abstract void tell() ;&#125;interface Inter2 &#123; public abstract void say();&#125;abstract class AbsDemo01 &#123; public abstract void print();&#125;class A extends Abs implements Inter1,Inter2 &#123; //重写所继承的所有接口中的所有抽象方法 public void tell() &#123; &#125; public void say() &#123; &#125; //重写所继承的所有抽象类中的所有抽象方法 public void print() &#123; &#125;&#125;//通过extends关键字同时继承多个接口interface Inter3 extends Inter1,Inter2&#123; &#125;public class InterDemo01 &#123; public static void main(String[] args) &#123; A a = new A(); a.tell(); a.say(); System.out.println(A.AGE); a.print(); &#125;&#125; 抽象类和接口的对比 参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常Java类的区别 除了不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有public、protected和default这些修饰符 接口方法默认修饰符是public。你不可以使用其它修饰符。 main方法 抽象方法可以有main方法并且我们可以运行它 接口没有main方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。 什么时候使用抽象类和接口： 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 5.2 Object所有类的超类 Object类是Java中所有类的始祖，在Java中每个类都是由它扩展而来。 Object类型的变量可以引用任何类型的对象，但若要对其具体内容进行具体操作，还是需要知道对象的原始类型，并进行相应的转换。 在Java中，只有基本类型不是对象，如数值、字符、布尔值等。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类。 equals方法 Object类中的equals方法用于检测一个对象是否等于另一个对象，本质上是比较两个对象是否具有相同的引用。 hashCode方法 散列码（hash code）是由对象导出的一个整型值。散列码是没有规律的。不同的对象，散列码基本不同。 1234String s = &quot;OK&quot;;System.out.println(s.hashCode());//运行结果：//java.io.PrintStream@15db9742 toString方法 toString方法用于返回表示对象值的字符串。（个人感觉还不如用空字符串连接其它数据，如int a = 12; String s = &quot;&quot;+a;） 5.3 泛型数组列表 ArrayList是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面， 例如ArrayList&lt;Father&gt; test = new ArrayList&lt;Father&gt;(); 注意：从Java SE7开始，可以省去右边的参数类型，即 ArrayList&lt;Father&gt; test = new ArrayList&lt;&gt;(); ArrayList类用起来与数组类似，但在添加或删除元素时，具有自动调节数组容量的功能。也可设置初始容量。 add()，添加元素到数组列表 get()，从数组列表取元素 set()，替换数组列表相应位置已有的元素 remove()，删除元素 size()，返回当前数组列表中包含的实际元素数目。 trimToSize()，将存储区域的大小调整为当前元素数量所需存储空间数目，多余的内存将会被gc回收。 示例 123456789101112131415161718192021222324252627282930313233343536373839public class ArrList &#123; public static void main(String[] args) &#123; // 创建ArrayList实例，并设置初始容量100 ArrayList&lt;Person&gt; human = new ArrayList&lt;&gt;(100); human.add((new Person(&quot;张三&quot;,34))); Person p = human.get(0); System.out.println(&quot;姓名：&quot;+p.name); System.out.println(&quot;年龄：&quot;+p.age); System.out.println(&quot;此时的ArrayList的实际元素数目为&quot;+human.size()); human.remove(human.size()-1); System.out.println(&quot;删除成功！&quot;); System.out.println(&quot;此时的ArrayList的实际元素数目为&quot;+human.size()); &#125;&#125;class Person &#123; String name; int age; public Person(String name,int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 5.4 对象包装器与自动装箱 所有的基本类型都有一个与之对应的类。如，Integer类对应基本类型int。Integer、Long、Float、Double、Short、Byte、Character、Boolean、Void均称之为对象包装器类。 ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); 程序调用list.add(3);将会自动变成list.add(Integer.valueOf(3));，这种变换称为“自动装箱”。 编译器将list.add(Integer.valueOf(3));翻译成list.add(3);，这种变换称为“自动拆箱”。 简单一句话：装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。 5.5 参数数量可变的方法 printf方法就是参数可变的方法。 个人觉得目前用不上，很鸡肋。 5.6 枚举类枚举类是类！ 1public enum Size &#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;; 5.7 反射 反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵Java代码的程序。 能够分析类能力的程序称为反射。 反射机制极其强大： 在运行时分析类的能力。 在运行时查看对象。 实现通用的数组操纵代码。 利用Method对象。 5.8 继承的设计技巧 将公共操作和域放在超类 不要使用受保护的域 使用继承实现“is-a”关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多使用反射","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"},{"name":"继承","slug":"继承","permalink":"https://born2do.github.io/tags/%E7%BB%A7%E6%89%BF/"}],"author":"Alexander"},{"title":"Java学习Day02","slug":"Java学习Day02","date":"2019-07-14T03:02:51.000Z","updated":"2021-05-13T14:29:57.043Z","comments":true,"path":"2019/07/14/Java学习Day02/","link":"","permalink":"https://born2do.github.io/2019/07/14/Java%E5%AD%A6%E4%B9%A0Day02/","excerpt":"","text":"第4章 对象与类4.1 面向对象程序设计概述 OOA、OOD、OOP OO，Object-Oriented，面向对象。OO方法是一种把面向对象的思想应用于软件开发过程中，指导开发活动的系统方法。 OOA，Object-Oriented Analysis，面向对象分析 OOD，Object-Oriented Design，面向对象设计 OOP，Object-Oriented Programming，面向对象编程 类是构造对象的模板或蓝图。由类构造对象的过程称为创建类的实例（instance）。 Java方法创建 方法的定义（方法名首字母小写，驼峰命名法） 123访问修饰符 返回值类型 方法名()&#123; 方法主体&#125; 类的创建及类与对象的关系 类的定义（类名首字母大写） 1234class 类名称&#123; 属性; 方法;&#125; 类与对象的关系：对象是类的实例，类是对象的模板。类是抽象的概念，而对象是具体实例。 Java面向对象思想编程 面向对象三大特性： 封装 对外部不可见 继承 扩展类的功能 多态 1.方法的重载 2.对象的多态性 Java方法递归调用 eg： 12345678910public static void main(String[] args)&#123; System.out.println(addNumber(100));&#125;public static int addNumber(int num)&#123; if (num == 1)&#123;//程序出口 return 1; &#125;else&#123; return num+addNumber(num-1); &#125;&#125; 对象的三个主要特性： 行为（behavior）——可以对对象施加哪些操作/方法 状态（state）——施加方法时，对象是如何响应的 标识（identity）——如何辨别具有相同行为与状态的不同对象 类之间的关系 依赖（“uses-a”），如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。但这种依赖性应减少。 聚合（“has-a”），聚合关系意味着类A的对象包含着类B的对象。 继承（“is-a”），是一种表示特殊与一般的关系。一般而言，如果类A扩展类B，类A不但包含从类B继承的方法，还会拥有一些额外的功能。 UML（Unified Modeling Language），统一建模语言，用于绘制类图，用来描述类之间的关系。类用矩形表示，类之间的关系用带有各种修饰符的箭头表示。 4.2 使用预定义类 对象与对象变量 对象，在构造器前加上new操作符，即可构造出新对象。 一个对象变量，并没有实际包含一个对象，而仅仅引用一个对象。 对象存储在堆内存中，而对象变量也即引用存储在栈内存中。 12345678910111213141516171819202122232425262728public class People &#123; String name; int age; // 构造器（constructor），是一种特殊的方法，又称构造方法 // 如果自己不重新构造，系统会默认自动生成无参的构造方法； // 相反，如果自己写了构造方法，如若需要无参的构造方法，则需手动添加无参的构造方法。 public People() &#123; &#125; public People(String name, int age) &#123; this.name = name; this.age = age; &#125; public static void main(String[] args) &#123; // 此处的chinese只是一个对象变量，既不是对象，也没有引用对象 People chinese; // chinese初始化后，对象变量chinese引用了一个对象，我们也称chinese为“引用” // 此处的 new People(&quot;张三&quot;,22) 构造了新对象，存储在堆内存中 chinese = new People(&quot;张三&quot;,22); &#125;&#125; Java类库中的Date类、LocalDate类 Date类存在问题，很多方法已经被弃置了，不用。 LocalDate类，需使用静态工厂方法构造新对象。 1 4.3 用户自定义类 类的定义（类名首字母大写） 1234class 类名称&#123; 属性; 方法;&#125; 一个源文件，只能有一个公共类，但可以有任意数目的非公有类。公共类的名称与源文件名称应完全相同。当一个源文件有多个类时，经编译器编译后，会生成多个.class字节码文件。 构造器 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个、1个或多个参数 构造器没有返回值 构造器总是伴随着new操作一起调用 隐式参数与显示参数 在每一个方法中，关键字this表示隐式参数。 位于方法名后面括号中的参数，称为显示参数。 封装性 目的：保护某些属性和方法不被外部所看见 封装的实现： 为属性和方法进行封装是通过关键字private声明的 实现该属性的set和get方法，为外部所访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Person &#123; private int age; private String name; //快捷生成方式：右击-&gt;source-&gt;Generate Getter and Setter…… //get方法 public int getAge() &#123; return age; &#125; //set方法 public void setAge(int age) &#123; if(age&gt;0&amp;&amp;age&lt;150)&#123; this.age = age; &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public void tell()&#123; System.out.println(&quot;姓名：&quot;+getName()+&quot; &quot;+&quot;年龄：&quot;+getAge()); &#125; &#125;public class Demo01 &#123; public static void main(String[] args) &#123; Person per = new Person();// per.name = &quot;张三&quot;;// per.age = 30;// per.setAge(-30);//最后age结果为0 per.setAge(30);//设置 per.setName(&quot;张三&quot;); per.tell(); //使用 对象.属性/方法 进行使用 System.out.println(&quot;姓名：&quot;+per.getName()+&quot; &quot;+&quot;年龄：&quot;+per.getAge()); &#125;&#125; final关键字 修饰类。当用final去修饰一个类的时候，表示这个类不能被继承。 注意： 被final修饰的类，final类中的成员变量可以根据自己的实际需要设计为fianl。 final类中的成员方法都会被隐式的指定为final方法。 在JDK中，被设计为final类的有String、System等。 修饰方法。被final修饰的方法不能被重写。注意： 一个类的private方法会隐式的被指定为final方法。 如果父类中有final修饰的方法，那么子类不能去重写。 修饰成员变量。注意： 必须初始化值，而且是只能初始化一次。 被fianl修饰的成员变量赋值，有两种方式：1、直接赋值 2、全部在构造方法中赋初值。 如果修饰的成员变量是基本类型，则表示这个变量的值不能改变。 如果修饰的成员变量是一个引用类型，则是说这个引用的地址的值不能修改，但是这个引用所指向的对象里面的内容还是可以改变的。 4.4 静态域与静态方法 若将域定义为static，则该域为静态域，每个类中只有一个这样的域。静态域属于类，而不属于任何独立的对象。 静态方法是一种不能面向对象实施操作的方法。也就是说，不需要对象就能调用。 静态方法不可以调用非静态方法，但非静态方法可以调用静态方法。 使用静态方法的情况： 一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（例如Math.pow）。 一个方法只需要访问类的静态域。 工厂方法。 类似LocalDate和NumberFormat的类使用静态工厂方法来构造对象。 123456789public static void main(String[] args) &#123; NumberFormat currencyFormat = NumberFormat.getCurrencyInstance(); NumberFormat percentFormat = NumberFormat.getPercentInstance(); double x = 0.111; System.out.println(currencyFormat.format(x)); System.out.println(percentFormat.format(x)); &#125; 结果为： 12￥0.1111% 为什么NumberFormat等类不利用构造器完成这些操作呢？原因如下： 无法命名构造器。构造器的名字必须与类名相同，但是，这里希望将得到的货币实例和百分比实例采用不同的名字。 当使用构造器时，无法改变所构造的对象类型。而Factory方法将返回一个DecimalFormat类对象，这是NumberFormat子类。 4.5 方法参数 Java程序设计语言总是采用按值调用。 方法参数共有两种类型： 基本数字类型（数字、布尔值） 对象引用 4.6 对象构造 重载（overloading）。在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。 123456public void getAge() &#123; System.out.println(&quot;默认值18&quot;);&#125;public void getAge(int age) &#123; System.out.println(&quot;年龄：&quot;+age);&#125; 通过关键字“this”，构造器可以调用同一个类的另一个构造器。 对象析构与finalize方法 由于Java有自动的垃圾回收器，不需要人工回收内存，所以Java不支持析构器。 finalize方法会在垃圾回收器清除对象之前调用，回收内存。但尽量不要使用，因为很难知道这个方法什么时候才能够调用。 4.7 包 使用import语句导入一个特定的类或整个包。import语句要在package语句后面，源文件的顶部。 关于包的引入，在开发过程中，会有提示，直接引入即可。 4.8 类路径 类存储在文件系统的子目录中。类的路径必须与包名匹配。 类也可存储在JAR（Java归档）文件中。 4.9 文档注释JavaDoc注释，可生成API文档，使用“/** */”。eclipse中的快捷键：打出“/**”，然后回车即可。 具体的注释内的内容，视情况而定。 4.10 类设计技巧 一定要保证数据私有 一定要对数据初始化 不要再类中使用过多的基本类型。也即，用其他的类代替多个相关的基本类型的使用。 不是所有的域都需要独立的域访问器和域更改器。 将职责过多的类进行分解 类名和方法名要能够体现他们的职责 优先使用不可变的类。如果类是不可变的，就可以安全地在多个线程间共享其对象。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"},{"name":"对象与类","slug":"对象与类","permalink":"https://born2do.github.io/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"}],"author":"Alexander"},{"title":"Java学习Day01","slug":"Java学习Day01","date":"2019-07-11T08:19:55.000Z","updated":"2021-05-13T14:28:50.491Z","comments":true,"path":"2019/07/11/Java学习Day01/","link":"","permalink":"https://born2do.github.io/2019/07/11/Java%E5%AD%A6%E4%B9%A0Day01/","excerpt":"","text":"第1章 Java程序设计概述 Java三大特性：封装、继承、多态。 封装：就是指对对象中的属性进行了私有化，只提供了两个公共的set和get方法，设置属性和获取属性值。提供数据的安全性。 继承：就是指一个类不仅拥有已有类的属性和方法，还可以拥有自己的属性和方法。注意：子类并不能真正继承父类的构造，但可以调用。 多态：就是指重载和重写。重载：指一个类中有两个同名不同参的方法。重写：指子类中拥有与父类同名同参的方法。 在Java的web浏览器中运行的Java程序称为applet。（该技术已经过时，很少使用） 第2章 Java程序设计环境 JDK与JRE的联系与区别： JDK，Java Development Kit 的缩写，Java开发工具包。 JRE，Java Runtime Environment的缩写，Java运行环境。 jdk包含了jre、编译器等其它工具。jdk是开发者需要的环境，而jre则是专门为不需要编译器的用户而提供。 JDK的安装与设置，请参考https://www.runoob.com/java/java-environment-setup.html 第3章 Java的基本程序设计结构3.1 一个简单的Java一个用程序123456789public class FirstSample &#123; public static void main(String[] args) &#123; System.out.println(&quot;Hello Java!!!&quot;); &#125;&#125; public——访问修饰符，用于定义访问权限。 class——关键字。 FirstSample——类名（自己定义）。 static——关键字。 void——关键字，表明无返回参数。 main——方法名，可自定义，在该处的“main”为主方法。 System.out.println();——用于输出内容到控制台。 命名规范： 类名以大写字母开头。 包名、方法名以小写字母开头。 所有的命名都遵循“驼峰命名法”。 3.2 注释三种注释方式： 单行注释，使用“//”。eclipse中的快捷键：ctrl+/。 多行注释，使用“/* */”。eclipse中的快捷键：ctrl+shift+/。 JavaDoc注释，可生成API文档，使用“/** */”。eclipse中的快捷键：打出“/**”，然后回车即可。 3.3 数据类型Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。 整型： byte（1字节） short （2字节） int（4字节）（最常用） long（8字节），长整型数值会有后缀“L”或“l”（建议使用“L”，不易混淆）。十六进制数值有前缀“0x”或“0X”，八进制数值也有前缀，但不建议使用八进制，容易出问题。 注意：Java中没有任何无符号（unsigned）形式的int、short、long、byte类型。 浮点类型： float（4字节），单精度数值有后缀“f”或“F”。 double（8字节）（最常用），双精度数值有后缀“d”或“D”。 没有后缀的浮点数值（如3.14）默认为double类型。 特殊浮点数值： NaN（not a number，不是一个数字），5/0则会出现该结果。double z = Double.NaN; 正无穷大，正整数除以0结果为正无穷大。double x = Double.POSITIVE_INFINITY; 负无穷大。double y = Double.NEGATIVE_INFINITY; char类型 char类型变量或字面量值需要2字节的空间。 char类型的字面量值要用单引号括起来。 特殊字符的转义序列不在此做过多赘述。 boolean类型 boolean（布尔）类型有两个值：false和true，用于判定逻辑条件。整型值和布尔值之间不能进行相互转换。 3.4 变量 变量声明及初始化 123456789//变量声明double salary;int vacationDays;//变量初始化salary = 3.14;vacationDays = 12;//也可在声明变量的同时进行初始化double salary = 3.14;int vacationDays = 12; Java中，不区分变量的声明与定义。 常量 在Java中，利用关键字final指示常量。关键字final表示这个变量只能被赋值一次，一旦被赋值就不能再更改。常量名使用全大写。 若希望某个常量在一个类的多个方法中使用，通常将这些常量定义为类常量，使用 static final 修饰。类常量的定义位于main方法的外部。 1234567891011public class FirstSample &#123; //类常量的定义位于main方法的外部。 public static final double PI = 3.14; public static void main(String[] args) &#123; System.out.println(&quot;Hello Java!!!&quot;); &#125;&#125; 3.5 运算符 算数运算符：+、-、*、/、%（加、减、乘、除、取余） 当参与运算的两个操作数精度不同时，低精度操作数会自动转换成高精度参与运算。 取余操作只针对整型数值。 整数被0除会产生异常，而浮点数被0除将会得到无穷大或NaN。 数学函数与常量 12345//求平方根double x = Math.sqrt(4); //幂运算double y = Math.pow(3, 3); Math类里面的方法均为静态方法。 可以通过在数学方法名和变量名前添加前缀“Math”来调用相应方法，也可以在源文件引入相关的包：import static java.lang.Math.*; 数值类型之间的转换 自动类型转换： 小类型向大类型转换： 小类型向大类型转换会自动完成，由JVM负责。也称为”隐式类型转换“。 自动转换规则：符号位自动扩展，负数补1，正数补0。 自动类型转换包含以下情况： byte-&gt;short-&gt;int-&gt;long-&gt;float-&gt;double int和char类型的数据在某些情况下可以相互转换 整数到浮点数转换会损失精确度。 强制类型转换： 大类型向小类型转换： 强制类型转换，简称强转，也称为“显式类型转换”。 强转时，要注意边界数风险问题。 强转时，可能发生数据丢失或错误问题。 自增与自减运算符 n++：先赋值，再自增1 n–：先赋值，再自减1 ++n：先自增1，再赋值 –n：先自减1，再赋值 关系运算符 Java关系运算的种类： == != &gt; &lt; &gt;= &lt;= 关系运算的最后结果为true或false。 逻辑运算符 逻辑运算是在关系运算基础之上的运算，能处理更复杂的问题。运算的结果为true或false。 Java逻辑运算的种类： 运算种类 运算符号 运算表达式 与运算（长路运算） &amp; 关系运算1 &amp; 关系运算2 与运算（短路运算） &amp;&amp; 关系运算1 &amp;&amp; 关系运算2 或运算（长路运算） | 关系运算1 | 关系运算2 或运算（短路运算） || 关系运算1 || 关系运算2 非运算 ! !(关系运算) 长路运算与短路运算的区别： ​ 长路运算会将逻辑运算符两侧的运算先执行完成后再进行逻辑运算 ，而短路运算先执行逻辑运算符左侧的部分，如果符合要求则直接输出逻辑运算结果，而不再对右侧的进行运算。 注意： 长路与运算&amp;，在两边都是整数时，是逐位与运算；在两边是关系运算时，是逻辑运算。 长路或运算|，在两边都是整数时，是逐位或运算；在两边是关系运算时，是逻辑运算。 三种逻辑运算的优先级为：非运算&gt;与运算&gt;或运算 安全起见，使用小括号将先要运算的关系式括起来。 括号与运算符级别，不做过多赘述，没意义！想要先运算的，添加括号即可，没人神经病去记那些运算符优先级。 枚举类型的使用： 123456789public class FirstSample &#123; public static void main(String[] args) &#123; Size s = Size.SMALL; &#125; enum Size &#123;SMALL,MEDIUM,LARGE,EXTER_LARGE&#125;;&#125; 3.6 字符串 实例化String对象 直接赋值（更为常用） 使用关键字new String内容的比较 1234567891011String str = &quot;hello&quot;;String str1 = new String(&quot;hello&quot;);System.out.println(str.equals(str1));//输出的结果为true//“==”比较的是地址//“equals”比较的是内容//字符串的遍历for(int i=0;i&lt;str.length();i++)&#123; char ch = str.charAt(i); System.out.println(ch);&#125; 字符串内容是不可更改的，改变的是堆内存地址的指向。 String字符串常用方法 字符串长度：length() 字符串转换数组：toCharArray() 从字符串中取出指定位置的字符：charAt() 字符串与Byte数组的转换：getBytes() 过滤字符串中存在的字符：indexOf() 去掉字符串的前后空格：trim() 从字符串中取出子字符串：subString() 大小写的转换：toLowerCase() toUpperCase() 判断字符串的开头结尾字符：endWith() startWith() 替换String字符串中的一个字符：replace() StringBuffer: 缓冲区，本身也是操作字符串，但与String不同，StringBuffer是可以更改的。 操作类，必须通过实例化进行操作。 123StringBuffer sb = new StringBuffer();//实例化sb.append(&quot;Java笔记&quot;)；//添加内容System.out.println(sb.toString()); StringBuffer常用方法 append() 添加字符串 insert(位置int,字符串String) 插入字符串 replace(开始替换位置int,结束替换位置int,字符串String) 替换字符串 indexOf() 过滤字符串中存在的字符 StringBuffer： ​ 一个可变的字符序列，StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候，速度更快。但若涉及线程安全方面，建议使用StringBuffer。 常用方法： append() insert() 3.7 输入输出 标准输出流。System.out.println(); 标准输入流。 12Scanner in = new Scanner(System.in);String name = in.nextLine(); int nextInt(); double nextDouble(); 格式化输出 System.out.printf(&quot;%s,%8.3f\\n&quot;,&quot;string&quot;,1111.22222); 1234567 %s，输出字符串。 %8.3f，输出浮点数，总长度为8，小数点保留3位，右对齐。如果为”%-8.3f“，则表示左对齐。- &#96;&#96;&#96;java System.out.println(String.format(&quot;%.16f&quot;, sum)); 保留数字小数点后16位，并转换成字符串输出。 System.out.printf(&quot;%tc&quot;,new Date()); 12345678910111213141516171819 格式化当前日期及时间，并打印。具体的格式，见《Java核心技术-卷Ⅰ》的p59。4. 文件的输入与输出 - 文件读取 &gt; 1. Scanner in &#x3D; new Scanner(Paths.get(&quot;文件路径&quot;),&quot;文件编码方式&quot;); &gt; 2. Scanner in &#x3D; new Scanner(new File(&quot;文件路径&quot;)); &gt; 3. Scanner in &#x3D; new Scanner(new BufferedReader(new FileReader(&quot;文件路径&quot;))); 读取文件并在控制台输出： &#96;&#96;&#96;java &#x2F;&#x2F;如果文件路径包含反斜杠，则需要在每个反斜杠之前加一个额外的反斜杠 Scanner in &#x3D; new Scanner(new File(&quot;文件路径&quot;)); while(in.hasNext())&#123; System.out.println(in.next()); &#125; 文件写入 PrintWriter out = new PrintWriter(“文件路径”,”文件编码方式”); //会覆盖掉已有内容 out.println(“我爱Java”); 追加内容写入文件： 12345678910File f = new File(&quot;文件路径&quot;);FileWriter fw = new FileWriter(f, true); PrintWriter pw = new PrintWriter(fw);pw.println(&quot;我爱Java&quot;);pw.println(&quot;Java爱我&quot;);pw.flush();fw.flush();pw.close();fw.close();System.out.println(&quot;写入成功！&quot;); 3.8 控制流程 块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句。块确定了变量的作用域（一般来说，变量出了大括号就失去了作用）。一个块可以嵌套在另一个块中。不能在嵌套的两个块中声明同名的变量。 条件语句 if语句 123if(条件表达式)&#123; 条件表达式结果为true时，执行本代码块&#125; if else 语句 12345if(条件表达式)&#123; 条件表达式结果为true时，执行本代码块&#125;else&#123; 条件表达式结果为false时，执行本代码块&#125; if嵌套语句 123456789if(条件表达式1)&#123; 条件表达式1结果为true时，执行本代码块&#125;else if(……)&#123; ……&#125;else if(条件表达式n)&#123; 条件表达式n结果为true时，执行本代码块&#125;else&#123; 条件表达式n结果为false时，执行本代码块&#125; 循环结构语句 while 循环 当满足条件时进入循环，执行循环体；当条件不满足时，跳出循环。 1234while(循环继续的条件表达式)&#123; 条件表达式为true时，执行本代码块。继续循环。 条件表达式为false时，退出while循环。&#125; do while 循环 123do&#123; 循环内容;&#125;while(循环继续的条件表达式); for 循环 123for(循环变量初始化;循环继续的条件表达式;循环变量值变更)&#123; 循环内容&#125; switch语句 123456789101112switch(表达式)&#123; // case与字面量值之间要有空格 case 常量值1: 代码块1; break; case 常量值2: 代码块2; break; …… default: 以上常量值均不是时，执行本代码块。&#125; switch语句的“贯穿”现象：当一个case结束后没有break;语句，则会一直向下执行，直至退出switch语句块。 中断控制语句： goto语句不被Java所使用，goto也仅作为保留字。 break;语句用于跳出当前循环或语句块。 带标签的break语句。 12345678int n = 5;break_out: //break标签for(;;)&#123; //无限循环 if(n&gt;0) &#123; break break_out; &#125;&#125;System.out.println(&quot;我是带标签的break语句！&quot;); 注意：标签必须放在希望跳出的最外层循环之前，并且必须紧跟一个冒号。 continue;语句，用于跳过当前循环，进入下一次循环。 3.9 大数值 java.math包中的两个类：BigInteger和BigDecimal，可以处理包含任意长度数字序列的数值。 12345678910int x = 6;// 使用静态的valueOf方法可以将普通数值转换位大数值BigInteger a = BigInteger.valueOf(x);// 也可以先存储为字符串再进行转换BigInteger b = new BigInteger(&quot;111111111111&quot;); // 计算a*bBigInteger result = a.multiply(b);System.out.println(a+&quot;*&quot;+b+&quot;=&quot;+result); 在进行算术运算时，需要用到大数值类中的add、multiply等方法。 3.10 数组 数组，是有序的元素序列。数组中的每个元素具有相同的数组名，下标是其元素的唯一标识。 数组的下标是从0开始的。 声明及开辟数组空间 数组的声明 声明形式一：type arrayName[]; 声明形式二：type[] arrayName; 为数组分配内存空间，如果不分配内存，将不能访问它的任何元素。 我们使用new关键字来为数组分配内存空间。 eg: 12int[] score=null;//数组的声明score = new int[3];//为数组开辟内存空间，也称为实例化 数组初始化方式有2种： 动态初始化 123int[] score=null;//数组的声明score = new int[3];//为数组开辟内存空间，也称为实例化//也可直接写成 int[] score = new int[3]; 静态初始化 1int[] score=&#123;1,2,3&#125;; 匿名数组 1234int[] small = &#123;98,36&#125;;// 此处的 new int[] &#123;1,2,3,4,88,77&#125;即为匿名数组small = new int[] &#123;1,2,3,4,88,77&#125;; 匿名数组可以在不创建新变量的情况下重新初始化一个数组。 数组遍历 方法一：for循环 12345int[] a = &#123; 45, 4, 89, 48, 78787 &#125;;for (int i = 0; i &lt; a.length; i++) &#123; System.out.println(a[i]);&#125; 方法二：for each循环 123for(int element:a) &#123; System.out.println(element);&#125; 方法三：Arrays.toString 123int[] a = &#123; 45, 4, 89, 48, 78787 &#125;;System.out.println(Arrays.toString(a));// 结果为[45, 4, 89, 48, 78787] 数组拷贝 如果需要将一个数组的所有值拷贝到一个新的数组中去，需要用到Arrays类中的copyOf方法： 1Arrays.copyOf(original, newLength) 第二个参数是新数组的长度，通常用该方法增加数组的大小。 如果数组元素是数值型，那么多余的元素将被赋值为0；如果数组元素是布尔型，则将赋值为false。相反，如果长度小于原始数组的长度，则只拷贝最前面的数组元素。 数组排序 优化过的数组排序方法Arrays.sort()： 12int[] a = &#123;1,45,2&#125;;Arrays.sort(a); 多维数组 二维数组的声明与分配内存 12type arrayName[][];arrayName[][] = new type[行][列]; 二维数组的遍历： 1）两层for循环 2）两层for each循环 3）Arrays.deepToString(a); 注意： 数组中的null与空是两个完全不同的概念 数组长度可以为0 数组声明后未赋值前，int类型数据默认为0，布尔类型数据默认为false，对象类型默认为null。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"}],"author":"Alexander"}],"categories":[{"name":"GIT","slug":"GIT","permalink":"https://born2do.github.io/categories/GIT/"},{"name":"清理","slug":"清理","permalink":"https://born2do.github.io/categories/%E6%B8%85%E7%90%86/"},{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/categories/MySQL/"},{"name":"FTP","slug":"FTP","permalink":"https://born2do.github.io/categories/FTP/"},{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/categories/Java/"},{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/categories/DB2/"},{"name":"maven","slug":"maven","permalink":"https://born2do.github.io/categories/maven/"},{"name":"刷题","slug":"刷题","permalink":"https://born2do.github.io/categories/%E5%88%B7%E9%A2%98/"},{"name":"VUE+SpringBoot","slug":"VUE-SpringBoot","permalink":"https://born2do.github.io/categories/VUE-SpringBoot/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"https://born2do.github.io/categories/SpringBoot/"},{"name":"前后端分离","slug":"前后端分离","permalink":"https://born2do.github.io/categories/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"},{"name":"vue","slug":"vue","permalink":"https://born2do.github.io/categories/vue/"},{"name":"数据库","slug":"数据库","permalink":"https://born2do.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"LICENSE ","slug":"LICENSE","permalink":"https://born2do.github.io/categories/LICENSE/"},{"name":"LICENSE","slug":"LICENSE","permalink":"https://born2do.github.io/categories/LICENSE/"},{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"error","slug":"error","permalink":"https://born2do.github.io/categories/error/"},{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/categories/Windows/"},{"name":"下载","slug":"下载","permalink":"https://born2do.github.io/categories/%E4%B8%8B%E8%BD%BD/"},{"name":"IP","slug":"IP","permalink":"https://born2do.github.io/categories/IP/"},{"name":"JSP","slug":"JSP","permalink":"https://born2do.github.io/categories/JSP/"},{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/categories/VUE/"},{"name":"Navicat","slug":"Navicat","permalink":"https://born2do.github.io/categories/Navicat/"},{"name":"Typora","slug":"Typora","permalink":"https://born2do.github.io/categories/Typora/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://born2do.github.io/categories/WebStorm/"},{"name":"基金","slug":"基金","permalink":"https://born2do.github.io/categories/%E5%9F%BA%E9%87%91/"},{"name":"MD","slug":"MD","permalink":"https://born2do.github.io/categories/MD/"},{"name":"C语言","slug":"C语言","permalink":"https://born2do.github.io/categories/C%E8%AF%AD%E8%A8%80/"},{"name":"XML","slug":"XML","permalink":"https://born2do.github.io/categories/XML/"},{"name":"元字符","slug":"元字符","permalink":"https://born2do.github.io/categories/%E5%85%83%E5%AD%97%E7%AC%A6/"},{"name":"爬虫","slug":"爬虫","permalink":"https://born2do.github.io/categories/%E7%88%AC%E8%99%AB/"},{"name":"JS","slug":"JS","permalink":"https://born2do.github.io/categories/JS/"},{"name":"linux","slug":"linux","permalink":"https://born2do.github.io/categories/linux/"},{"name":"规约","slug":"规约","permalink":"https://born2do.github.io/categories/%E8%A7%84%E7%BA%A6/"},{"name":"Excel","slug":"Excel","permalink":"https://born2do.github.io/categories/Excel/"},{"name":"shell","slug":"shell","permalink":"https://born2do.github.io/categories/shell/"},{"name":"工具","slug":"工具","permalink":"https://born2do.github.io/categories/%E5%B7%A5%E5%85%B7/"},{"name":"Markdown","slug":"Markdown","permalink":"https://born2do.github.io/categories/Markdown/"},{"name":"博客搭建","slug":"博客搭建","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"图床","slug":"博客搭建/图床","permalink":"https://born2do.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/%E5%9B%BE%E5%BA%8A/"}],"tags":[{"name":"GIT","slug":"GIT","permalink":"https://born2do.github.io/tags/GIT/"},{"name":"maven","slug":"maven","permalink":"https://born2do.github.io/tags/maven/"},{"name":"注解","slug":"注解","permalink":"https://born2do.github.io/tags/%E6%B3%A8%E8%A7%A3/"},{"name":"AOP","slug":"AOP","permalink":"https://born2do.github.io/tags/AOP/"},{"name":"MySQL","slug":"MySQL","permalink":"https://born2do.github.io/tags/MySQL/"},{"name":"error","slug":"error","permalink":"https://born2do.github.io/tags/error/"},{"name":"crontab","slug":"crontab","permalink":"https://born2do.github.io/tags/crontab/"},{"name":"IO流","slug":"IO流","permalink":"https://born2do.github.io/tags/IO%E6%B5%81/"},{"name":"函数","slug":"函数","permalink":"https://born2do.github.io/tags/%E5%87%BD%E6%95%B0/"},{"name":"表空间","slug":"表空间","permalink":"https://born2do.github.io/tags/%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"name":"缓冲池","slug":"缓冲池","permalink":"https://born2do.github.io/tags/%E7%BC%93%E5%86%B2%E6%B1%A0/"},{"name":"跨域","slug":"跨域","permalink":"https://born2do.github.io/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"表分区","slug":"表分区","permalink":"https://born2do.github.io/tags/%E8%A1%A8%E5%88%86%E5%8C%BA/"},{"name":"DB2","slug":"DB2","permalink":"https://born2do.github.io/tags/DB2/"},{"name":"Java","slug":"Java","permalink":"https://born2do.github.io/tags/Java/"},{"name":"String","slug":"String","permalink":"https://born2do.github.io/tags/String/"},{"name":"StringBuffer","slug":"StringBuffer","permalink":"https://born2do.github.io/tags/StringBuffer/"},{"name":"StringBuilder","slug":"StringBuilder","permalink":"https://born2do.github.io/tags/StringBuilder/"},{"name":"树形目录结构","slug":"树形目录结构","permalink":"https://born2do.github.io/tags/%E6%A0%91%E5%BD%A2%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"},{"name":"github","slug":"github","permalink":"https://born2do.github.io/tags/github/"},{"name":"环境变量","slug":"环境变量","permalink":"https://born2do.github.io/tags/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"},{"name":"tar","slug":"tar","permalink":"https://born2do.github.io/tags/tar/"},{"name":"Page","slug":"Page","permalink":"https://born2do.github.io/tags/Page/"},{"name":"println","slug":"println","permalink":"https://born2do.github.io/tags/println/"},{"name":"VUE","slug":"VUE","permalink":"https://born2do.github.io/tags/VUE/"},{"name":"软件安装","slug":"软件安装","permalink":"https://born2do.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"访问修饰符","slug":"访问修饰符","permalink":"https://born2do.github.io/tags/%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"},{"name":"HashTable","slug":"HashTable","permalink":"https://born2do.github.io/tags/HashTable/"},{"name":"HashMap","slug":"HashMap","permalink":"https://born2do.github.io/tags/HashMap/"},{"name":"报错","slug":"报错","permalink":"https://born2do.github.io/tags/%E6%8A%A5%E9%94%99/"},{"name":"Echo","slug":"Echo","permalink":"https://born2do.github.io/tags/Echo/"},{"name":"chmod","slug":"chmod","permalink":"https://born2do.github.io/tags/chmod/"},{"name":"关键字","slug":"关键字","permalink":"https://born2do.github.io/tags/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"ArrayList","slug":"ArrayList","permalink":"https://born2do.github.io/tags/ArrayList/"},{"name":"LinkedList","slug":"LinkedList","permalink":"https://born2do.github.io/tags/LinkedList/"},{"name":"Navicat","slug":"Navicat","permalink":"https://born2do.github.io/tags/Navicat/"},{"name":"Typora","slug":"Typora","permalink":"https://born2do.github.io/tags/Typora/"},{"name":"WebStorm","slug":"WebStorm","permalink":"https://born2do.github.io/tags/WebStorm/"},{"name":"重写","slug":"重写","permalink":"https://born2do.github.io/tags/%E9%87%8D%E5%86%99/"},{"name":"重载","slug":"重载","permalink":"https://born2do.github.io/tags/%E9%87%8D%E8%BD%BD/"},{"name":"专业术语","slug":"专业术语","permalink":"https://born2do.github.io/tags/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"},{"name":"快捷键","slug":"快捷键","permalink":"https://born2do.github.io/tags/%E5%BF%AB%E6%8D%B7%E9%94%AE/"},{"name":"内部类","slug":"内部类","permalink":"https://born2do.github.io/tags/%E5%86%85%E9%83%A8%E7%B1%BB/"},{"name":"零碎知识","slug":"零碎知识","permalink":"https://born2do.github.io/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/"},{"name":"XML","slug":"XML","permalink":"https://born2do.github.io/tags/XML/"},{"name":"JSF","slug":"JSF","permalink":"https://born2do.github.io/tags/JSF/"},{"name":"单元测试","slug":"单元测试","permalink":"https://born2do.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"name":"@Autowired","slug":"Autowired","permalink":"https://born2do.github.io/tags/Autowired/"},{"name":"@Resource","slug":"Resource","permalink":"https://born2do.github.io/tags/Resource/"},{"name":"联合主键","slug":"联合主键","permalink":"https://born2do.github.io/tags/%E8%81%94%E5%90%88%E4%B8%BB%E9%94%AE/"},{"name":"易混述语","slug":"易混述语","permalink":"https://born2do.github.io/tags/%E6%98%93%E6%B7%B7%E8%BF%B0%E8%AF%AD/"},{"name":"数据表空间和索引表空间","slug":"数据表空间和索引表空间","permalink":"https://born2do.github.io/tags/%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E7%B4%A2%E5%BC%95%E8%A1%A8%E7%A9%BA%E9%97%B4/"},{"name":"Date","slug":"Date","permalink":"https://born2do.github.io/tags/Date/"},{"name":"元字符","slug":"元字符","permalink":"https://born2do.github.io/tags/%E5%85%83%E5%AD%97%E7%AC%A6/"},{"name":"栈内存","slug":"栈内存","permalink":"https://born2do.github.io/tags/%E6%A0%88%E5%86%85%E5%AD%98/"},{"name":"堆内存","slug":"堆内存","permalink":"https://born2do.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"},{"name":"webapp下静态资源无法访问","slug":"webapp下静态资源无法访问","permalink":"https://born2do.github.io/tags/webapp%E4%B8%8B%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE/"},{"name":"IO","slug":"IO","permalink":"https://born2do.github.io/tags/IO/"},{"name":"Html转Markdown","slug":"Html转Markdown","permalink":"https://born2do.github.io/tags/Html%E8%BD%ACMarkdown/"},{"name":"运算符优先级","slug":"运算符优先级","permalink":"https://born2do.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/"},{"name":"log4j","slug":"log4j","permalink":"https://born2do.github.io/tags/log4j/"},{"name":"SLF4J","slug":"SLF4J","permalink":"https://born2do.github.io/tags/SLF4J/"},{"name":"logback","slug":"logback","permalink":"https://born2do.github.io/tags/logback/"},{"name":"WebMagic","slug":"WebMagic","permalink":"https://born2do.github.io/tags/WebMagic/"},{"name":"webmagic-selenium","slug":"webmagic-selenium","permalink":"https://born2do.github.io/tags/webmagic-selenium/"},{"name":"decodeURIComponent()","slug":"decodeURIComponent","permalink":"https://born2do.github.io/tags/decodeURIComponent/"},{"name":"encodeURIComponent()","slug":"encodeURIComponent","permalink":"https://born2do.github.io/tags/encodeURIComponent/"},{"name":"shell","slug":"shell","permalink":"https://born2do.github.io/tags/shell/"},{"name":"c3p0","slug":"c3p0","permalink":"https://born2do.github.io/tags/c3p0/"},{"name":"linux","slug":"linux","permalink":"https://born2do.github.io/tags/linux/"},{"name":"Linux","slug":"Linux","permalink":"https://born2do.github.io/tags/Linux/"},{"name":"Excel","slug":"Excel","permalink":"https://born2do.github.io/tags/Excel/"},{"name":"find","slug":"find","permalink":"https://born2do.github.io/tags/find/"},{"name":"开源","slug":"开源","permalink":"https://born2do.github.io/tags/%E5%BC%80%E6%BA%90/"},{"name":"Markdown","slug":"Markdown","permalink":"https://born2do.github.io/tags/Markdown/"},{"name":"Windows","slug":"Windows","permalink":"https://born2do.github.io/tags/Windows/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://born2do.github.io/tags/MYSQL/"},{"name":"VC++6.0","slug":"VC-6-0","permalink":"https://born2do.github.io/tags/VC-6-0/"},{"name":"PowerPoint 2013","slug":"PowerPoint-2013","permalink":"https://born2do.github.io/tags/PowerPoint-2013/"},{"name":"Hexo","slug":"Hexo","permalink":"https://born2do.github.io/tags/Hexo/"},{"name":"Gitalk","slug":"Gitalk","permalink":"https://born2do.github.io/tags/Gitalk/"},{"name":"PicGo","slug":"PicGo","permalink":"https://born2do.github.io/tags/PicGo/"},{"name":"SMMS","slug":"SMMS","permalink":"https://born2do.github.io/tags/SMMS/"},{"name":"GitHub","slug":"GitHub","permalink":"https://born2do.github.io/tags/GitHub/"},{"name":"接口","slug":"接口","permalink":"https://born2do.github.io/tags/%E6%8E%A5%E5%8F%A3/"},{"name":"继承","slug":"继承","permalink":"https://born2do.github.io/tags/%E7%BB%A7%E6%89%BF/"},{"name":"对象与类","slug":"对象与类","permalink":"https://born2do.github.io/tags/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/"}]}